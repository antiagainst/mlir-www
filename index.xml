<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>MLIR</title><link>https://mlir.llvm.org/</link><description>Recent content on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 19 Oct 2017 15:26:15 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/index.xml" rel="self" type="application/rss+xml"/><item><title>Users of MLIR</title><link>https://mlir.llvm.org/users/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/users/</guid><description> Flang: the LLVM Fortran compiler The high level IR of the Fortran compiler is modeled using MLIR.
TensorFlow</description></item><item><title>FAQ</title><link>https://mlir.llvm.org/getting_started/faq/</link><pubDate>Fri, 29 Nov 2019 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/faq/</guid><description>TODO</description></item><item><title>Developer Guide</title><link>https://mlir.llvm.org/getting_started/developerguide/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/developerguide/</guid><description>This document attempts to describe a few developer policies used in MLIR (such as coding standards used) as well as development approach (such as, testing methods).
Style guide MLIR follows the LLVM style guide. We also adhere to the following (which deviate from or are not specified in the LLVM style guide):
Adopts camelBack; Except for IR units (Region, Block, and Operation), non-nullable output arguments are passed by non-const reference in general.</description></item><item><title>Glossary</title><link>https://mlir.llvm.org/getting_started/glossary/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/glossary/</guid><description>This glossary contains definitions of MLIR-specific terminology. It is intended to be a quick reference document. For terms which are well-documented elsewhere, definitions are kept brief and the header links to the more in-depth documentation.
Block A sequential list of operations without control flow.
Also called a basic block.
Conversion The transformation of code represented in one dialect into a semantically equivalent representation in another dialect (i.e. inter-dialect conversion) or the same dialect (i.</description></item><item><title>Testing Guide</title><link>https://mlir.llvm.org/getting_started/testingguide/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/getting_started/testingguide/</guid><description>Testing is an integral part of any software infrastructure. In general, all commits to the MLIR repository should include an accompanying test of some form. Commits that include no functional changes, such as API changes like symbol renaming, should be tagged with NFC(no functional changes). This signals to the reviewer why the change doesn&amp;rsquo;t/shouldn&amp;rsquo;t include a test.
MLIR generally separates testing into two main categories, Check tests and Unit tests.</description></item><item><title>Dialect &#39;affine&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/affineops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/affineops/</guid><description>[TOC]
Operation definition affine.for (AffineForOp) for operation
Description: The &amp;ldquo;affine.for&amp;rdquo; operation represents an affine loop nest, defining an SSA value for its induction variable. It has one region capturing the loop body. The induction variable is represented as a argument of this region. This SSA value always has type index, which is the size of the machine word. The stride, represented by step, is a positive constant integer which defaults to &amp;ldquo;1&amp;rdquo; if not present.</description></item><item><title>Dialect &#39;fxpmath&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/fxpmathops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/fxpmathops/</guid><description>[TOC]
Operation definition fxpmath.clampis (fxpmath::ClampISOp) Clamps a signed-integer like argument to a min/max range.
Description: Element-wise equivalent to: r = std::min(clamp_max, std::max(e, clamp_min))
Operands: operand: integer-like Attributes: Attribute MLIR Type Description clamp_min IntegerAttr arbitrary integer attribute attribute clamp_max IntegerAttr arbitrary integer attribute attribute Results: &amp;laquo;unnamed&amp;raquo;: integer-like fxpmath.convertis (fxpmath::ConvertISOp) Does an element-wise conversion from a signed integer to signed integer</description></item><item><title>Dialect &#39;gpu&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/gpuops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/gpuops/</guid><description>[TOC]
Operation definition gpu.all_reduce (gpu::AllReduceOp) Reduce values among workgroup.
Description: The &amp;ldquo;all_reduce&amp;rdquo; op reduces the value of every work item across a local workgroup. The result is equal for all work items of a workgroup.
For example, both
%1 = &amp;quot;gpu.all_reduce&amp;quot;(%0) ({}) { op = &amp;quot;add&amp;quot; } : (f32) -&amp;gt; (f32) %2 = &amp;quot;gpu.all_reduce&amp;quot;(%0) ({ ^bb(%lhs : f32, %rhs : f32): %sum = addf %lhs, %rhs : f32 &amp;quot;gpu.</description></item><item><title>Dialect &#39;linalg&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/linalgdoc/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/linalgdoc/</guid><description>The linalg dialect groups together a set of types, operations and transformations that are useful to implement a structured abstraction where ops can lower to scalar load/store and operations or to more general library calls.
The linalg dialect manipulates the following types and operations:
Core data types and special ops. The following abstractions are used by the linalg dialect:
Views The current implementation uses the strided memref abstraction. In the future other abstractions than strided memref will be used.</description></item><item><title>Dialect &#39;loop&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/loopops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/loopops/</guid><description>[TOC]
Operation definition loop.for (ForOp) for operation
Description: The &amp;ldquo;loop.for&amp;rdquo; operation represents a loop nest taking 3 SSA value as operands that represent the lower bound, upper bound and step respectively. The operation defines an SSA value for its induction variable. It has one region capturing the loop body. The induction variable is represented as an argument of this region. This SSA value always has type index, which is the size of the machine word.</description></item><item><title>Dialect &#39;nvvm&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/nvvmops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/nvvmops/</guid><description>[TOC]
Operation definition nvvm.barrier0 (NVVM::Barrier0Op) Description: Operands: Attributes: Results: nvvm.read.ptx.sreg.ntid.x (NVVM::BlockDimXOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ntid.y (NVVM::BlockDimYOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ntid.z (NVVM::BlockDimZOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ctaid.x (NVVM::BlockIdXOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.read.ptx.sreg.ctaid.y (NVVM::BlockIdYOp) Description: Operands: Attributes: Results: res: LLVM dialect type nvvm.</description></item><item><title>Dialect &#39;quant&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/quantops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/quantops/</guid><description>[TOC]
Operation definition quant.const_fake_quant (quant::ConstFakeQuant) Simulates the effect of uniform quantization with const range.
Description: Given a const min, max, num_bits and narrow_range attribute, applies the same uniform quantization simulation as is done by the TensorFlow fake_quant_with_min_max_args op. See the fakeQuantAttrsToType() utility method and the quant-convert-simulated-quantization pass for futher details.
Operands: inputs: tensor of 32-bit float values Attributes: Attribute MLIR Type Description min FloatAttr 32-bit float attribute attribute max FloatAttr 32-bit float attribute attribute num_bits IntegerAttr 64-bit integer attribute attribute narrow_range BoolAttr bool attribute attribute is_signed BoolAttr bool attribute attribute Results: outputs: tensor of 32-bit float values quant.</description></item><item><title>Dialect &#39;rocdl&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/rocdlops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/rocdlops/</guid><description>[TOC]
Operation definition rocdl.workgroup.dim.x (ROCDL::BlockDimXOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.dim.y (ROCDL::BlockDimYOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.dim.z (ROCDL::BlockDimZOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.id.x (ROCDL::BlockIdXOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.id.y (ROCDL::BlockIdYOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.workgroup.id.z (ROCDL::BlockIdZOp) Description: Operands: Attributes: Results: res: LLVM dialect type rocdl.</description></item><item><title>Dialect &#39;spv&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/spirvops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/spirvops/</guid><description>The SPIR-V dialect in MLIR.
SPIR-V is the Khronos Group&amp;rsquo;s binary intermediate language for representing graphical-shader stages and compute kernels for multiple Khronos APIs, including OpenCL, OpenGL, and Vulkan. See https://www.khronos.org/registry/spir-v for more details.
This dialect aims to be a simple proxy for the SPIR-V binary format to enable straightforward and lightweight conversion from/to the binary format. Ops in this dialect should stay at the same semantic level and try to be a mechanical mapping to the corresponding SPIR-V instructions; but they may deviate representationally to allow using MLIR mechanisms.</description></item><item><title>Dialect &#39;vector&#39; definition</title><link>https://mlir.llvm.org/docs/dialects/vectorops/</link><pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate><guid>https://mlir.llvm.org/docs/dialects/vectorops/</guid><description>[TOC]
Operation definition vector.broadcast (vector::BroadcastOp) broadcast operation
Description: Broadcasts the scalar or k-D vector value in the source operand to a n-D result vector such that the broadcast makes sense, i.e., the source operand is duplicated to match the given rank and sizes in the result vector. The legality rules are: * the source operand must have the same element type as the result type * a k-D vector can be broadcast to a n-D vector if * k &amp;lt;= n, and * the sizes in the trailing dimensions n-k &amp;lt; i &amp;lt;= n with j=i+k-n match exactly as s_j = t_i or s_j = 1:</description></item></channel></rss>