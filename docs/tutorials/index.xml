<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Tutorials on MLIR</title><link>https://mlir.llvm.org/docs/tutorials/</link><description>Recent content in Tutorials on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/tutorials/index.xml" rel="self" type="application/rss+xml"/><item><title>Dialect Conversion</title><link>https://mlir.llvm.org/docs/tutorials/dialectconversion/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/dialectconversion/</guid><description>This document describes a framework in MLIR in which to perform operation conversions between, and within dialects. This framework allows for transforming illegal operations to those supported by a provided conversion target, via a set of pattern-based operation rewriting patterns.
[TOC]
To utilize the framework, a few things must be provided:
A Conversion Target A set of Rewrite Patterns A Type Converter (Optional) Modes of Conversion When applying a conversion to a set of operations, there are several conversion modes that can be selected from:</description></item><item><title>Interfaces</title><link>https://mlir.llvm.org/docs/tutorials/interfaces/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/interfaces/</guid><description>MLIR is generic and very extensible; it allows for opaquely representing many different dialects that have their own operations, attributes, types, and so on. This allows for dialects to be very expressive in their semantics and for MLIR to capture many different levels of abstraction. The downside to this is that transformations and analyses must be extremely conservative about the operations that they encounter, and must special-case the different dialects that they support.</description></item><item><title>Introduction to Operation Traits</title><link>https://mlir.llvm.org/docs/tutorials/traits/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/traits/</guid><description>[TOC]
MLIR allows for a truly open operation ecosystem, as any dialect may define operations that suit a specific level of abstraction. Traits are a mechanism in which to abstract implementation details and properties that are common across many different operations. Traits may be used to specify special properties and constraints of the operation, including whether the operation has side effects or whether its output has the same type as the input.</description></item><item><title>Quickstart on Graph Rewrite</title><link>https://mlir.llvm.org/docs/tutorials/quickstartrewrites/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/tutorials/quickstartrewrites/</guid><description>This document will present a quickstart to adding graph rewrites. We shall start by defining an operation, showing multiple ways to define the rewrite using patterns, as well as defining the rewrite using a graph walker (note: using patterns and the rewrite engine is preferred, showing the walker is for demonstration purposes).
See MLIR specification for more information about MLIR, the structure of the IR, operations, etc. See Table-driven Operation Definition and Declarative Rewrite Rule for the detailed explanation of all available mechanisms for defining operations and rewrites in a table-driven manner.</description></item></channel></rss>