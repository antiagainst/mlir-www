<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Introduction to Operation Traits - MLIR: Multi-Level IR Compiler Framework</title><meta name=description content="&lt;insert something insighful here&gt;"><meta name=generator content="Hugo 0.59.1"><link href=https://joker-eph.github.io/www-mlir/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://joker-eph.github.io/www-mlir/docs/tutorials/traits/><link rel=stylesheet href=https://joker-eph.github.io/www-mlir/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://joker-eph.github.io/www-mlir/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://joker-eph.github.io/www-mlir/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><img src=https://joker-eph.github.io/www-mlir//mlir-logo.png width=40px>MLIR: Multi-Level IR Compiler Framework</h1><a href=https://github.com/llvm/llvm-project/mlir class=github><i class="fab fa-github"></i></a><p class=description>&lt;insert something insighful here&gt;</p></header><div class=global-menu><nav><ul><li><a href=/www-mlir/getting_started/faq/>FAQ</a></li><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li></ul></nav></div><div class=content-container><main><h1>Introduction to Operation Traits</h1><p>[TOC]</p><p>MLIR allows for a truly open operation ecosystem, as any dialect may define
operations that suit a specific level of abstraction. <code>Traits</code> are a mechanism
in which to abstract implementation details and properties that are common
across many different operations. <code>Traits</code> may be used to specify special
properties and constraints of the operation, including whether the operation has
side effects or whether its output has the same type as the input. Some examples
of traits are <code>Commutative</code>, <code>SingleResult</code>, <code>Terminator</code>, etc. See the more
<a href=#traits>comprehensive list</a> below for more examples of what is possible.</p><h2 id=defining-a-trait>Defining a Trait</h2><p>Traits may be defined in C++ by inheriting from the
<code>OpTrait::TraitBase&lt;ConcreteType, TraitType&gt;</code> class. This base class takes as
template parameters:</p><ul><li>ConcreteType<ul><li>The concrete operation type that this trait was attached to.</li></ul></li><li>TraitType<ul><li>The type of the trait class that is being defined, for use with the
<a href=https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern><code>Curiously Recurring Template Pattern</code></a>.</li></ul></li></ul><p>A derived trait class is expected to take a single template that corresponds to
the <code>ConcreteType</code>. An example trait definition is shown below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ConcreteType</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>MyTrait</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OpTrait</span><span class=o>::</span><span class=n>TraitBase</span><span class=o>&lt;</span><span class=n>ConcreteType</span><span class=p>,</span> <span class=n>MyTrait</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=p>};</span>
</code></pre></div><p>Derived traits may also provide a <code>verifyTrait</code> hook, that is called when
verifying the concrete operation. The trait verifiers will currently always be
invoked before the main <code>Op::verify</code>.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ConcreteType</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>MyTrait</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OpTrait</span><span class=o>::</span><span class=n>TraitBase</span><span class=o>&lt;</span><span class=n>ConcreteType</span><span class=p>,</span> <span class=n>MyTrait</span><span class=o>&gt;</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=c1>/// Override the &#39;verifyTrait&#39; hook to add additional verification on the
</span><span class=c1></span>  <span class=c1>/// concrete operation.
</span><span class=c1></span>  <span class=k>static</span> <span class=n>LogicalResult</span> <span class=n>verifyTrait</span><span class=p>(</span><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>};</span>
</code></pre></div><p>Note: It is generally good practice to define the implementation of the
<code>verifyTrait</code> hook out-of-line as a free function when possible to avoid
instantiating the implementation for every concrete operation type.</p><h3 id=parametric-traits>Parametric Traits</h3><p>The above demonstrates the definition of a simple self-contained trait. It is
also often useful to provide some static parameters to the trait to control its
behavior. Given that the definition of the trait class is rigid, i.e. we must
have a single template argument for the concrete operation, the templates for
the parameters will need to be split out. An example is shown below:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>template</span> <span class=o>&lt;</span><span class=kt>int</span> <span class=n>Parameter</span><span class=o>&gt;</span>
<span class=k>class</span> <span class=nc>MyParametricTrait</span> <span class=p>{</span>
<span class=k>public</span><span class=o>:</span>
  <span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span> <span class=n>ConcreteType</span><span class=o>&gt;</span>
  <span class=k>class</span> <span class=nc>Impl</span> <span class=o>:</span> <span class=k>public</span> <span class=n>OpTrait</span><span class=o>::</span><span class=n>TraitBase</span><span class=o>&lt;</span><span class=n>ConcreteType</span><span class=p>,</span> <span class=n>Impl</span><span class=o>&gt;</span> <span class=p>{</span>
    <span class=c1>// Inside of &#39;Impl&#39; we have full access to the template parameters
</span><span class=c1></span>    <span class=c1>// specified above.
</span><span class=c1></span>  <span class=p>};</span>
<span class=p>};</span>
</code></pre></div><h2 id=attaching-a-trait>Attaching a Trait</h2><p>Traits may be used when defining a derived operation type, by simply adding the
name of the trait class to the <code>Op</code> class after the concrete operation type:</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=c1>/// Here we define &#39;MyOp&#39; along with the &#39;MyTrait&#39; and `MyParameteric trait
</span><span class=c1>/// classes we defined previously.
</span><span class=c1></span><span class=k>class</span> <span class=nc>MyOp</span> <span class=o>:</span> <span class=k>public</span> <span class=n>Op</span><span class=o>&lt;</span><span class=n>MyOp</span><span class=p>,</span> <span class=n>MyTrait</span><span class=p>,</span> <span class=n>MyParametricTrait</span><span class=o>&lt;</span><span class=mi>10</span><span class=o>&gt;::</span><span class=n>Impl</span><span class=o>&gt;</span> <span class=p>{};</span>
</code></pre></div><p>To use a trait in the <a href=OpDefinitions.md>ODS</a> framework, we need to provide a
definition of the trait class. This can be done using the <code>NativeOpTrait</code> and
<code>ParamNativeOpTrait</code> classes. <code>ParamNativeOpTrait</code> provides a mechanism in which
to specify arguments to a parametric trait class with an internal <code>Impl</code>.</p><div class=highlight><pre class=chroma><code class=language-td data-lang=td>// The argument is the c++ trait class name.
def MyTrait : NativeOpTrait&lt;&#34;MyTrait&#34;&gt;;

// The first argument is the parent c++ class name. The second argument is a
// string containing the parameter list.
class MyParametricTrait&lt;int prop&gt;
  : NativeOpTrait&lt;&#34;MyParametricTrait&#34;, !cast&lt;string&gt;(!head(parameters))&gt;;</code></pre></div><p>These can then be used in the <code>traits</code> list of an op definition:</p><div class=highlight><pre class=chroma><code class=language-td data-lang=td>def OpWithInferTypeInterfaceOp : Op&lt;...[MyTrait, MyParametricTrait&lt;10&gt;]&gt; { ... }</code></pre></div><p>See the documentation on <a href=OpDefinitions.md>operation definitions</a> for more
details.</p><h2 id=using-a-trait>Using a Trait</h2><p>Traits may be used to provide additional methods, static fields, or other
information directly on the concrete operation. <code>Traits</code> internally become
<code>Base</code> classes of the concrete operation, so all of these are directly
accessible. To expose this information opaquely to transformations and analyses,
<a href=Interfaces.md><code>interfaces</code></a> may be used.</p><p>To query if a specific operation contains a specific trait, the <code>hasTrait&lt;&gt;</code>
method may be used. This takes as a template parameter the trait class, which is
the same as the one passed when attaching the trait to an operation.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>Operation</span> <span class=o>*</span><span class=n>op</span> <span class=o>=</span> <span class=p>..;</span>
<span class=k>if</span> <span class=p>(</span><span class=n>op</span><span class=o>-&gt;</span><span class=n>hasTrait</span><span class=o>&lt;</span><span class=n>MyTrait</span><span class=o>&gt;</span><span class=p>()</span> <span class=o>||</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>hasTrait</span><span class=o>&lt;</span><span class=n>MyParametricTrait</span><span class=o>&lt;</span><span class=mi>10</span><span class=o>&gt;::</span><span class=n>Impl</span><span class=o>&gt;</span><span class=p>())</span>
  <span class=p>...;</span>
</code></pre></div><h2 id=trait-list>Trait List</h2><p>MLIR provides a suite of traits that provide various functionalities that are
common across many different operations. Below is a list of some key traits that
may be used directly by any dialect. The format of the header for each trait
section goes as follows:</p><ul><li><code>Header</code><ul><li>(<code>C++ class</code> &ndash; <code>ODS class</code>(if applicable))</li></ul></li></ul><h3 id=broadcastable>Broadcastable</h3><ul><li><code>OpTrait::BroadcastableTwoOperandsOneResult</code> &ndash; <code>Broadcastable</code></li></ul><p>This trait provides the API for operations that are known to have
<a href=https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html>broadcast-compatible</a>
operand and result types. Specifically, starting from the most varying
dimension, each dimension pair of the two operands&rsquo; types should either be the
same or one of them is one. Also, the result type should have the corresponding
dimension equal to the larger one, if known. Shapes are checked partially if
ranks or dimensions are not known. For example, an op with <code>tensor&lt;?x2xf32&gt;</code> and
<code>tensor&lt;2xf32&gt;</code> as operand types and <code>tensor&lt;3x2xf32&gt;</code> as the result type is
broadcast-compatible.</p><p>Ths trait assumes the op has two operands and one result, and it asserts if the
pre-condition is not satisfied.</p><h3 id=commutative>Commutative</h3><ul><li><code>OpTrait::IsCommutative</code> &ndash; <code>Commutative</code></li></ul><p>This trait adds the property that the operation is commutative, i.e. <code>X op Y ==
Y op X</code></p><h3 id=function-like>Function-Like</h3><ul><li><code>OpTrait::FunctionLike</code></li></ul><p>This trait provides APIs for operations that behave like functions. In
particular:</p><ul><li>Ops must be symbols, i.e. also have the <code>Symbol</code> trait;</li><li>Ops have a single region with multiple blocks that corresponds to the body
of the function;</li><li>the absence of a region corresponds to an external function;</li><li>arguments of the first block of the region are treated as function
arguments;</li><li>they can have argument and result attributes that are stored in dictionary
attributes on the operation itself.</li></ul><p>This trait does <em>NOT</em> provide type support for the functions, meaning that
concrete Ops must handle the type of the declared or defined function.
<code>getTypeAttrName()</code> is a convenience function that returns the name of the
attribute that can be used to store the function type, but the trait makes no
assumption based on it.</p><h3 id=hasparent>HasParent</h3><ul><li><code>OpTrait::HasParent&lt;typename ParentOpType&gt;</code> &ndash; <code>HasParent&lt;string op&gt;</code></li></ul><p>This trait provides APIs and verifiers for operations that can only be nested
within regions that are attached to operations of <code>ParentOpType</code>.</p><h3 id=isolatedfromabove>IsolatedFromAbove</h3><ul><li><code>OpTrait::IsIsolatedFromAbove</code> &ndash; <code>IsolatedFromAbove</code></li></ul><p>This trait signals that the regions of an operations are known to be isolated
from above. This trait asserts that the regions of an operation will not
capture, or reference, SSA values defined above the region scope. This means
that the following is invalid if <code>foo.region_op</code> is defined as
<code>IsolatedFromAbove</code>:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>%result = constant 10 : i32
foo.region_op {
  foo.yield %result : i32
}</code></pre></div><p>This trait is an important structural property of the IR, and enables operations
to have <a href=WritingAPass.md>passes</a> scheduled under them.</p><h3 id=nosideeffect>NoSideEffect</h3><ul><li><code>OpTrait::HasNoSideEffect</code> &ndash; <code>NoSideEffect</code></li></ul><p>This trait signifies that the operation is pure and has no visible side effects.</p><h3 id=single-block-with-implicit-terminator>Single Block with Implicit Terminator</h3><ul><li><code>OpTrait::SingleBlockImplicitTerminator&lt;typename TerminatorOpType&gt;</code> :
<code>SingleBlockImplicitTerminator&lt;string op&gt;</code></li></ul><p>This trait provides APIs and verifiers for operations with regions that have a
single block that must terminate with <code>TerminatorOpType</code>.</p><h3 id=symbol>Symbol</h3><ul><li><code>OpTrait::Symbol</code> &ndash; <code>Symbol</code></li></ul><p>This trait is used for operations that define a <code>Symbol</code>.</p><p>TODO(riverriddle) Link to the proper document detailing the design of symbols.</p><h3 id=symboltable>SymbolTable</h3><ul><li><code>OpTrait::SymbolTable</code> &ndash; <code>SymbolTable</code></li></ul><p>This trait is used for operations that define a <code>SymbolTable</code>.</p><p>TODO(riverriddle) Link to the proper document detailing the design of symbols.</p><h3 id=terminator>Terminator</h3><ul><li><code>OpTrait::IsTerminator</code> &ndash; <code>Terminator</code></li></ul><p>This trait provides verification and functionality for operations that are known
to be <a href=LangRef.md#terminator-operations>terminators</a>.</p><div class=edit-meta>Last updated on 29 Nov 2019<br>Published on 29 Nov 2019<br><a href=https://github.com/joker-eph/www-mlir//edit/master/content/docs/Tutorials/Traits.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/www-mlir/docs/tutorials/toy/ch-7/ title="Chapter 7: Adding a Composite Type to Toy"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Chapter 7: Adding a Composite Type to Toy</a>
<a class="nav nav-next" href=/www-mlir/docs/tutorials/toy/ title="Toy Tutorial">Next - Toy Tutorial <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://joker-eph.github.io/www-mlir/>Home</a></li><li><a href=/www-mlir/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/www-mlir/getting_started/faq/>FAQ</a></li><li><a href=/www-mlir/getting_started/developerguide/>Developer Guide</a></li><li><a href=/www-mlir/getting_started/glossary/>Glossary</a></li><li><a href=/www-mlir/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/www-mlir/docs/>Docs</a><ul class=sub-menu><li class=parent><a href=/www-mlir/docs/tutorials/>Tutorials</a><ul class=sub-menu><li><a href=/www-mlir/docs/tutorials/dialectconversion/>Dialect Conversion</a></li><li><a href=/www-mlir/docs/tutorials/interfaces/>Interfaces</a></li><li class=active><a href=/www-mlir/docs/tutorials/traits/>Introduction to Operation Traits</a></li><li><a href=/www-mlir/docs/tutorials/quickstartrewrites/>Quickstart on Graph Rewrite</a></li><li><a href=/www-mlir/docs/tutorials/toy/>Toy Tutorial</a><ul class=sub-menu><li><a href=/www-mlir/docs/tutorials/toy/ch-1/>Chapter 1: Intro</a></li><li><a href=/www-mlir/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/www-mlir/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/www-mlir/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/www-mlir/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/www-mlir/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/www-mlir/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li><a href=/www-mlir/docs/dialects/>Dialect</a><ul class=sub-menu><li><a href=/www-mlir/docs/dialects/affine/>Affine</a></li><li><a href=/www-mlir/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/www-mlir/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/www-mlir/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/www-mlir/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/www-mlir/docs/dialects/vector/>Vector Dialect</a></li></ul></li><li><a href=/www-mlir/docs/design/>Design</a><ul class=sub-menu><li><a href=/www-mlir/docs/design/canonicalization/>Canonicalization</a></li><li><a href=/www-mlir/docs/design/rationalesimplifiedpolyhedralform/>Case for a Simplified Polyhedral Form</a></li><li><a href=/www-mlir/docs/design/rationale/>Design Rationale</a></li><li><a href=/www-mlir/docs/design/diagnostics/>Diagnostics Infrastructure</a></li><li><a href=/www-mlir/docs/design/edsc/>EDSC: Declarative Builders</a></li><li><a href=/www-mlir/docs/design/genericdagrewriter/>Generic DAG Rewriter Infrastructure</a></li><li><a href=/www-mlir/docs/design/mlirforgraphalgorithms/>Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/www-mlir/docs/design/quantization/>Quantization</a></li><li><a href=/www-mlir/docs/design/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/www-mlir/docs/design/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/www-mlir/docs/design/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li></ul></li><li><a href=/www-mlir/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/www-mlir/docs/langref/>Core Specification</a></li><li><a href=/www-mlir/docs/passes/>Passes</a></li><li><a href=/www-mlir/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/www-mlir/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>