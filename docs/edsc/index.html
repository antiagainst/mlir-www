<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Background: declarative builders API - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/edsc/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Background: declarative builders API</h1><p>The main purpose of the declarative builders API is to provide an intuitive way
of constructing MLIR programmatically. In the majority of cases, the IR we wish
to construct exhibits structured control-flow. Declarative builders provide an
API to make MLIR construction and manipulation very idiomatic, for the
structured control-flow case, in C++.</p><h2 id=scopedcontext>ScopedContext</h2><p><code>mlir::edsc::ScopedContext</code> provides an implicit thread-local context,
supporting a simple declarative API with globally accessible builders. These
declarative builders are available within the lifetime of a <code>ScopedContext</code>.</p><h2 id=valuehandle-and-indexhandle>ValueHandle and IndexHandle</h2><p><code>mlir::edsc::ValueHandle</code> and <code>mlir::edsc::IndexHandle</code> provide typed
abstractions around an <code>mlir::Value</code>. These abstractions are &ldquo;delayed&rdquo;, in the
sense that they allow separating declaration from definition. They may capture
IR snippets, as they are built, for programmatic manipulation. Intuitive
operators are provided to allow concise and idiomatic expressions.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>ValueHandle</span> <span class=n>zero</span> <span class=o>=</span> <span class=n>constant_index</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
<span class=n>IndexHandle</span> <span class=n>i</span><span class=p>,</span> <span class=n>j</span><span class=p>,</span> <span class=n>k</span><span class=p>;</span>
</code></pre></div><h2 id=intrinsics>Intrinsics</h2><p><code>mlir::edsc::ValueBuilder</code> is a generic wrapper for the <code>mlir::Builder::create</code>
method that operates on <code>ValueHandle</code> objects and return a single ValueHandle.
For instructions that return no values or that return multiple values, the
<code>mlir::edsc::InstructionBuilder</code> can be used. Named intrinsics are provided as
syntactic sugar to further reduce boilerplate.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=k>using</span> <span class=n>load</span> <span class=o>=</span> <span class=n>ValueBuilder</span><span class=o>&lt;</span><span class=n>LoadOp</span><span class=o>&gt;</span><span class=p>;</span>
<span class=k>using</span> <span class=n>store</span> <span class=o>=</span> <span class=n>InstructionBuilder</span><span class=o>&lt;</span><span class=n>StoreOp</span><span class=o>&gt;</span><span class=p>;</span>
</code></pre></div><h2 id=loopbuilder-and-affineloopnestbuilder>LoopBuilder and AffineLoopNestBuilder</h2><p><code>mlir::edsc::AffineLoopNestBuilder</code> provides an interface to allow writing
concise and structured loop nests.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++>  <span class=n>ScopedContext</span> <span class=nf>scope</span><span class=p>(</span><span class=n>f</span><span class=p>.</span><span class=n>get</span><span class=p>());</span>
  <span class=n>ValueHandle</span> <span class=nf>i</span><span class=p>(</span><span class=n>indexType</span><span class=p>),</span>
              <span class=n>j</span><span class=p>(</span><span class=n>indexType</span><span class=p>),</span>
              <span class=n>lb</span><span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>getArgument</span><span class=p>(</span><span class=mi>0</span><span class=p>)),</span>
              <span class=n>ub</span><span class=p>(</span><span class=n>f</span><span class=o>-&gt;</span><span class=n>getArgument</span><span class=p>(</span><span class=mi>1</span><span class=p>));</span>
  <span class=n>ValueHandle</span> <span class=nf>f7</span><span class=p>(</span><span class=n>constant_float</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>APFloat</span><span class=p>(</span><span class=mf>7.0f</span><span class=p>),</span> <span class=n>f32Type</span><span class=p>)),</span>
              <span class=n>f13</span><span class=p>(</span><span class=n>constant_float</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>APFloat</span><span class=p>(</span><span class=mf>13.0f</span><span class=p>),</span> <span class=n>f32Type</span><span class=p>)),</span>
              <span class=n>i7</span><span class=p>(</span><span class=n>constant_int</span><span class=p>(</span><span class=mi>7</span><span class=p>,</span> <span class=mi>32</span><span class=p>)),</span>
              <span class=n>i13</span><span class=p>(</span><span class=n>constant_int</span><span class=p>(</span><span class=mi>13</span><span class=p>,</span> <span class=mi>32</span><span class=p>));</span>
  <span class=n>AffineLoopNestBuilder</span><span class=p>(</span><span class=o>&amp;</span><span class=n>i</span><span class=p>,</span> <span class=n>lb</span><span class=p>,</span> <span class=n>ub</span><span class=p>,</span> <span class=mi>3</span><span class=p>)([</span><span class=o>&amp;</span><span class=p>]{</span>
      <span class=n>lb</span> <span class=o>*</span> <span class=nf>index_t</span><span class=p>(</span><span class=mi>3</span><span class=p>)</span> <span class=o>+</span> <span class=n>ub</span><span class=p>;</span>
      <span class=n>lb</span> <span class=o>+</span> <span class=n>index_t</span><span class=p>(</span><span class=mi>3</span><span class=p>);</span>
      <span class=n>AffineLoopNestBuilder</span><span class=p>(</span><span class=o>&amp;</span><span class=n>j</span><span class=p>,</span> <span class=n>lb</span><span class=p>,</span> <span class=n>ub</span><span class=p>,</span> <span class=mi>2</span><span class=p>)([</span><span class=o>&amp;</span><span class=p>]{</span>
          <span class=n>ceilDiv</span><span class=p>(</span><span class=n>index_t</span><span class=p>(</span><span class=mi>31</span><span class=p>)</span> <span class=o>*</span> <span class=n>floorDiv</span><span class=p>(</span><span class=n>i</span> <span class=o>+</span> <span class=n>j</span> <span class=o>*</span> <span class=n>index_t</span><span class=p>(</span><span class=mi>3</span><span class=p>),</span> <span class=n>index_t</span><span class=p>(</span><span class=mi>32</span><span class=p>)),</span>
                  <span class=n>index_t</span><span class=p>(</span><span class=mi>32</span><span class=p>));</span>
          <span class=p>((</span><span class=n>f7</span> <span class=o>+</span> <span class=n>f13</span><span class=p>)</span> <span class=o>/</span> <span class=n>f7</span><span class=p>)</span> <span class=o>%</span> <span class=n>f13</span> <span class=o>-</span> <span class=n>f7</span> <span class=o>*</span> <span class=n>f13</span><span class=p>;</span>
          <span class=p>((</span><span class=n>i7</span> <span class=o>+</span> <span class=n>i13</span><span class=p>)</span> <span class=o>/</span> <span class=n>i7</span><span class=p>)</span> <span class=o>%</span> <span class=n>i13</span> <span class=o>-</span> <span class=n>i7</span> <span class=o>*</span> <span class=n>i13</span><span class=p>;</span>
      <span class=p>});</span>
  <span class=p>});</span>
</code></pre></div><h2 id=indexedvalue>IndexedValue</h2><p><code>mlir::edsc::IndexedValue</code> provides an index notation around load and store
operations on abstract data types by overloading the C++ assignment and
parenthesis operators. The relevant loads and stores are emitted as appropriate.</p><h2 id=putting-it-all-together>Putting it all together</h2><p>With declarative builders, it becomes fairly concise to build rank and
type-agnostic custom operations even though MLIR does not yet have generic
types. Here is what a definition of a general pointwise add looks in
Tablegen with declarative builders.</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=n>def</span> <span class=nl>AddOp</span> <span class=p>:</span> <span class=n>Op</span><span class=o>&lt;</span><span class=s>&#34;x.add&#34;</span><span class=o>&gt;</span><span class=p>,</span>
    <span class=n>Arguments</span><span class=o>&lt;</span><span class=p>(</span><span class=n>ins</span> <span class=nl>Tensor</span><span class=p>:</span><span class=err>$</span><span class=n>A</span><span class=p>,</span> <span class=nl>Tensor</span><span class=p>:</span><span class=err>$</span><span class=n>B</span><span class=p>)</span><span class=o>&gt;</span><span class=p>,</span>
    <span class=n>Results</span><span class=o>&lt;</span><span class=p>(</span><span class=n>outs</span> <span class=nl>Tensor</span><span class=p>:</span> <span class=err>$</span><span class=n>C</span><span class=p>)</span><span class=o>&gt;</span> <span class=p>{</span>
  <span class=n>code</span> <span class=n>referenceImplementation</span> <span class=o>=</span> <span class=p>[{</span>
    <span class=k>auto</span> <span class=n>ivs</span> <span class=o>=</span> <span class=n>makeIndexHandles</span><span class=p>(</span><span class=n>view_A</span><span class=p>.</span><span class=n>rank</span><span class=p>());</span>
    <span class=k>auto</span> <span class=n>pivs</span> <span class=o>=</span> <span class=n>makePIndexHandles</span><span class=p>(</span><span class=n>ivs</span><span class=p>);</span>
    <span class=n>IndexedValue</span> <span class=nf>A</span><span class=p>(</span><span class=n>arg_A</span><span class=p>),</span> <span class=n>B</span><span class=p>(</span><span class=n>arg_B</span><span class=p>),</span> <span class=n>C</span><span class=p>(</span><span class=n>arg_C</span><span class=p>);</span>
    <span class=n>AffineLoopNestBuilder</span><span class=p>(</span><span class=n>pivs</span><span class=p>,</span> <span class=n>view_A</span><span class=p>.</span><span class=n>getLbs</span><span class=p>(),</span> <span class=n>view_A</span><span class=p>.</span><span class=n>getUbs</span><span class=p>(),</span> <span class=n>view_A</span><span class=p>.</span><span class=n>getSteps</span><span class=p>())(</span>
      <span class=p>[</span><span class=o>&amp;</span><span class=p>]{</span>
        <span class=n>C</span><span class=p>(</span><span class=n>ivs</span><span class=p>)</span> <span class=o>=</span> <span class=n>A</span><span class=p>(</span><span class=n>ivs</span><span class=p>)</span> <span class=o>+</span> <span class=n>B</span><span class=p>(</span><span class=n>ivs</span><span class=p>)</span>
      <span class=p>});</span>
  <span class=p>}];</span>
<span class=p>}</span>
</code></pre></div><p>Depending on the function signature on which this emitter is called, the
generated IR resembles the following, for a 4-D memref of <code>vector&lt;4xi8&gt;</code>:</p><pre><code>// CHECK-LABEL: func @t1(%lhs: memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;, %rhs: memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;, %result: memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;) -&gt; () {
//       CHECK: affine.for {{.*}} = 0 to 3 {
//       CHECK:   affine.for {{.*}} = 0 to 4 {
//       CHECK:     affine.for {{.*}} = 0 to 5 {
//       CHECK:       affine.for {{.*}}= 0 to 6 {
//       CHECK:         {{.*}} = load %arg1[{{.*}}] : memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;
//       CHECK:         {{.*}} = load %arg0[{{.*}}] : memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;
//       CHECK:         {{.*}} = addi {{.*}} : vector&lt;4xi8&gt;
//       CHECK:         store {{.*}}, %arg2[{{.*}}] : memref&lt;3x4x5x6xvector&lt;4xi8&gt;&gt;
</code></pre><p>or the following, for a 0-D <code>memref&lt;f32&gt;</code>:</p><pre><code>// CHECK-LABEL: func @t3(%lhs: memref&lt;f32&gt;, %rhs: memref&lt;f32&gt;, %result: memref&lt;f32&gt;) -&gt; () {
//       CHECK: {{.*}} = load %arg1[] : memref&lt;f32&gt;
//       CHECK: {{.*}} = load %arg0[] : memref&lt;f32&gt;
//       CHECK: {{.*}} = addf {{.*}}, {{.*}} : f32
//       CHECK: store {{.*}}, %arg2[] : memref&lt;f32&gt;
</code></pre><p>Similar APIs are provided to emit the lower-level <code>loop.for</code> op with
<code>LoopNestBuilder</code>. See the <code>builder-api-test.cpp</code> test for more usage examples.</p><p>Since the implementation of declarative builders is in C++, it is also available
to program the IR with an embedded-DSL flavor directly integrated in MLIR. We
make use of these properties in the tutorial.</p><p>Spoiler: MLIR also provides Python bindings for these builders, and a
full-fledged Python machine learning DSL with automatic differentiation
targeting MLIR was built as an early research collaboration.</p><div class=edit-meta>Last updated on 1 Jan 1970<br>Published on 1 Jan 1970<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/EDSC.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/tutorials/toy/ch-7/ title="Chapter 7: Adding a Composite Type to Toy"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Chapter 7: Adding a Composite Type to Toy</a>
<a class="nav nav-next" href=/docs/dialects/ title=Dialects>Next - Dialects <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/contributing/>How to Contribute</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Code Documentation</a><ul class=sub-menu><li><a href=/docs/dialects/>Dialects</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgdoc/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/linalg/>Linalg Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li></ul></li><li><a href=/docs/tutorials/toy/>Toy</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li class=active><a href=/docs/edsc/>Background: declarative builders API</a></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/developerguide/>Developer Guide</a></li><li><a href=/docs/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/diagnostics/>Introduction and Usage Guide to MLIR&#39;s Diagnostics Infrastructure</a></li><li><a href=/docs/interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/genericdagrewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/glossary/>MLIR Glossary</a></li><li><a href=/docs/passes/>MLIR Passes</a></li><li><a href=/docs/quantization/>MLIR Quantization</a></li><li><a href=/docs/rationale/>MLIR Rationale</a></li><li><a href=/docs/langref/>MLIR Specification</a></li><li><a href=/docs/mlirforgraphalgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/rationalesimplifiedpolyhedralform/>MLIR: The case for a &lt;em&gt;simplified&lt;/em&gt; polyhedral form</a></li><li><a href=/docs/canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/quickstartrewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/testingguide/>Testing Guide</a></li><li><a href=/docs/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>