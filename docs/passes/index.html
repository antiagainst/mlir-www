<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Passes - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=http://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=http://mlir.llvm.org/docs/passes/><link rel=stylesheet href=http://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=http://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=http://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=http://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Passes</h1><p>This document describes the available MLIR passes and their contracts.</p><p>[TOC]</p><h2 id=affine-control-lowering-lower-affine>Affine control lowering (<code>-lower-affine</code>)</h2><p>Convert operations related to affine control into a graph of blocks using
operations from the standard dialect.</p><p>Loop statements are converted to a subgraph of blocks (initialization, condition
checking, subgraph of body blocks) with loop induction variable being passed as
the block argument of the condition checking block. Conditional statements are
converted to a subgraph of blocks (chain of condition checking with
short-circuit logic, subgraphs of &lsquo;then&rsquo; and &lsquo;else&rsquo; body blocks). <code>affine.apply</code>
operations are converted into sequences of primitive arithmetic operations that
have the same effect, using operands of the <code>index</code> type. Consequently, named
maps and sets may be removed from the module.</p><p>For example, <code>%r = affine.apply (d0, d1)[s0] -&gt; (d0 + 2*d1 + s0)(%d0, %d1)[%s0]</code>
can be converted into:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>%d0 = &lt;...&gt;
%d1 = &lt;...&gt;
%s0 = &lt;...&gt;
%0 = constant 2 : index
%1 = muli %0, %d1
%2 = addi %d0, %1
%r = addi %2, %s0</code></pre></div><h3 id=input-invariant>Input invariant</h3><ul><li>no <code>Tensor</code> types;</li></ul><p>These restrictions may be lifted in the future.</p><h3 id=output-ir>Output IR</h3><p>Functions with <code>affine.for</code> and <code>affine.if</code> operations eliminated. These
functions may contain operations from the Standard dialect in addition to those
already present before the pass.</p><h3 id=invariants>Invariants</h3><ul><li>Functions without a body are not modified.</li><li>The semantics of the other functions is preserved.</li><li>Individual operations other than those mentioned above are not modified if
they do not depend on the loop iterator value or on the result of
<code>affine.apply</code>.</li></ul><h2 id=conversion-from-standard-to-llvm-ir-dialect-convert-std-to-llvm>Conversion from Standard to LLVM IR dialect (<code>-convert-std-to-llvm</code>)</h2><p>Convert standard operations into the LLVM IR dialect operations.</p><h3 id=input-invariant-1>Input invariant</h3><ul><li>operations including: arithmetic on integers and floats, constants, direct
calls, returns and branches;</li><li>no <code>tensor</code> types;</li><li>all <code>vector</code> are one-dimensional;</li><li>all blocks are reachable by following the successors of the first basic
block;</li></ul><p>If other operations are present and their results are required by the LLVM IR
dialect operations, the pass will fail. Any LLVM IR operations or types already
present in the IR will be kept as is.</p><h3 id=output-ir-1>Output IR</h3><p>Functions converted to LLVM IR. Function arguments types are converted
one-to-one. Function results are converted one-to-one and, in case more than 1
value is returned, packed into an LLVM IR struct type. Function calls and
returns are updated accordingly. Block argument types are updated to use LLVM IR
types.</p><h2 id=data-copy-dma-generation-affine-data-copy-generate>Data Copy DMA generation (<code>-affine-data-copy-generate</code>)</h2><p>Replaces all loads and stores on memref&rsquo;s living in &lsquo;slowMemorySpace&rsquo; by
introducing DMA operations (strided DMA if necessary) to transfer data to/from
<code>fastMemorySpace</code> and rewriting the original load&rsquo;s/store&rsquo;s to instead
load/store from the allocated fast memory buffers. Additional options specify
the identifier corresponding to the fast memory space and the amount of fast
memory space available. The pass traverses through the nesting structure,
recursing to inner levels if necessary to determine at what depth DMA transfers
need to be placed so that the allocated buffers fit within the memory capacity
provided. If this is not possible (for example, when the elemental type itself
is of size larger than the DMA capacity), an error with location information is
emitted. The DMA transfers are also hoisted up past all loops with respect to
which the transfers are invariant.</p><p>Input</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>func @loop_nest_tiled() -&gt; memref&lt;256x1024xf32&gt; {
  %0 = alloc() : memref&lt;256x1024xf32&gt;
  affine.for %i0 = 0 to 256 step 32 {
    affine.for %i1 = 0 to 1024 step 32 {
      affine.for %i2 = (d0) -&gt; (d0)(%i0) to (d0) -&gt; (d0 + 32)(%i0) {
        affine.for %i3 = (d0) -&gt; (d0)(%i1) to (d0) -&gt; (d0 + 32)(%i1) {
          %1 = affine.load %0[%i2, %i3] : memref&lt;256x1024xf32&gt;
        }
      }
    }
  }
  return %0 : memref&lt;256x1024xf32&gt;
}</code></pre></div><p>Output (with flags: -affine-data-copy-generate -affine-data-copy-generate-fast-mem-space=2)</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>module {
  func @loop_nest_tiled() -&gt; memref&lt;256x1024xf32&gt; {
    %c262144 = constant 262144 : index
    %c0 = constant 0 : index
    %0 = alloc() : memref&lt;256x1024xf32&gt;
    %1 = alloc() : memref&lt;256x1024xf32, 2&gt;
    %2 = alloc() : memref&lt;1xi32&gt;
    affine.dma_start %0[%c0, %c0], %1[%c0, %c0], %2[%c0], %c262144 : memref&lt;256x1024xf32&gt;, memref&lt;256x1024xf32, 2&gt;, memref&lt;1xi32&gt;
    affine.dma_wait %2[%c0], %c262144 : memref&lt;1xi32&gt;
    affine.for %arg0 = 0 to 256 step 32 {
      affine.for %arg1 = 0 to 1024 step 32 {
        affine.for %arg2 = #map1(%arg0) to #map2(%arg0) {
          affine.for %arg3 = #map1(%arg1) to #map2(%arg1) {
            %3 = affine.load %1[%arg2, %arg3] : memref&lt;256x1024xf32, 2&gt;
          }
        }
      }
    }
    dealloc %2 : memref&lt;1xi32&gt;
    dealloc %1 : memref&lt;256x1024xf32, 2&gt;
    return %0 : memref&lt;256x1024xf32&gt;
  }
}</code></pre></div><h2 id=loop-tiling-affine-loop-tile>Loop tiling (<code>-affine-loop-tile</code>)</h2><p>Performs tiling or blocking of loop nests. It currently works on perfect loop
nests.</p><h2 id=loop-unroll-affine-loop-unroll>Loop unroll (<code>-affine-loop-unroll</code>)</h2><p>This pass implements loop unrolling. It is able to unroll loops with arbitrary
bounds, and generate a cleanup loop when necessary.</p><h2 id=loop-unroll-and-jam-affine-loop-unroll-jam>Loop unroll and jam (<code>-affine-loop-unroll-jam</code>)</h2><p>This pass implements unroll and jam for loops. It works on both perfect or
imperfect loop nests.</p><h2 id=loop-fusion-affine-loop-fusion>Loop fusion (<code>-affine-loop-fusion</code>)</h2><p>Performs fusion of loop nests using a slicing-based approach. The fused loop
nests, when possible, are rewritten to access significantly smaller local
buffers instead of the original memref&rsquo;s, and the latter are often
either completely optimized away or contracted. This transformation leads to
enhanced locality and lower memory footprint through the elimination or
contraction of temporaries / intermediate memref&rsquo;s. These benefits are sometimes
achieved at the expense of redundant computation through a cost model that
evaluates available choices such as the depth at which a source slice should be
materialized in the designation slice.</p><h2 id=memref-bound-checking-memref-bound-check>Memref bound checking (<code>-memref-bound-check</code>)</h2><p>Checks all load&rsquo;s and store&rsquo;s on memref&rsquo;s for out of bound accesses, and reports
any out of bound accesses (both overrun and underrun) with location information.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>test/Transforms/memref-bound-check.mlir:19:13: error: &#39;load&#39; op memref out of upper bound access along dimension #2
      %x  = load %A[%idx0, %idx1] : memref&lt;9 x 9 x i32&gt;
            ^
test/Transforms/memref-bound-check.mlir:19:13: error: &#39;load&#39; op memref out of lower bound access along dimension #2
      %x  = load %A[%idx0, %idx1] : memref&lt;9 x 9 x i32&gt;
            ^</code></pre></div><h2 id=memref-dataflow-optimization-memref-dataflow-opt>Memref dataflow optimization (<code>-memref-dataflow-opt</code>)</h2><p>This pass performs store to load forwarding for memref&rsquo;s to eliminate memory
accesses and potentially the entire memref if all its accesses are forwarded.</p><p>Input</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>func @store_load_affine_apply() -&gt; memref&lt;10x10xf32&gt; {
  %cf7 = constant 7.0 : f32
  %m = alloc() : memref&lt;10x10xf32&gt;
  affine.for %i0 = 0 to 10 {
    affine.for %i1 = 0 to 10 {
      affine.store %cf7, %m[%i0, %i1] : memref&lt;10x10xf32&gt;
      %v0 = affine.load %m[%i0, %i1] : memref&lt;10x10xf32&gt;
      %v1 = addf %v0, %v0 : f32
    }
  }
  return %m : memref&lt;10x10xf32&gt;
}</code></pre></div><p>Output</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>module {
  func @store_load_affine_apply() -&gt; memref&lt;10x10xf32&gt; {
    %cst = constant 7.000000e+00 : f32
    %0 = alloc() : memref&lt;10x10xf32&gt;
    affine.for %arg0 = 0 to 10 {
      affine.for %arg1 = 0 to 10 {
        affine.store %cst, %0[%arg0, %arg1] : memref&lt;10x10xf32&gt;
        %1 = addf %cst, %cst : f32
      }
    }
    return %0 : memref&lt;10x10xf32&gt;
  }
}</code></pre></div><h2 id=memref-dependence-analysis-memref-dependence-check>Memref dependence analysis (<code>-memref-dependence-check</code>)</h2><p>This pass performs dependence analysis to determine dependences between pairs of
memory operations (load&rsquo;s and store&rsquo;s) on memref&rsquo;s. Dependence analysis exploits
polyhedral information available (affine maps, expressions, and affine.apply
operations) to precisely represent dependences using affine constraints, while
also computing dependence vectors from them, where each component of the
dependence vector provides a lower and an upper bound on the dependence distance
along the corresponding dimension.</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>test/Transforms/memref-dataflow-opt.mlir:232:7: note: dependence from 2 to 1 at depth 1 = ([1, 1], [-inf, +inf])
      store %cf9, %m[%idx] : memref&lt;10xf32&gt;</code></pre></div><h2 id=pipeline-data-transfer-affine-pipeline-data-transfer>Pipeline data transfer (<code>-affine-pipeline-data-transfer</code>)</h2><p>This pass performs a transformation to overlap non-blocking DMA operations in a
loop with computations through double buffering. This is achieved by advancing
dma_start operations with respect to other operations.</p><p>Input</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>func @pipelinedatatransfer() {
  %0 = alloc() : memref&lt;256xf32&gt;
  %1 = alloc() : memref&lt;32xf32, 1&gt;
  %2 = alloc() : memref&lt;1xf32&gt;
  %c0 = constant 0 : index
  %c128 = constant 128 : index
  affine.for %i0 = 0 to 8 {
    affine.dma_start %0[%i0], %1[%i0], %2[%c0], %c128 : memref&lt;256xf32&gt;, memref&lt;32xf32, 1&gt;, memref&lt;1xf32&gt;
    affine.dma_wait %2[%c0], %c128 : memref&lt;1xf32&gt;
    %3 = affine.load %1[%i0] : memref&lt;32xf32, 1&gt;
    %4 = &#34;compute&#34;(%3) : (f32) -&gt; f32
    affine.store %4, %1[%i0] : memref&lt;32xf32, 1&gt;
  }
  return
}</code></pre></div><p>Output</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>module {
  func @pipelinedatatransfer() {
    %c8 = constant 8 : index
    %c0 = constant 0 : index
    %0 = alloc() : memref&lt;256xf32&gt;
    %c0_0 = constant 0 : index
    %c128 = constant 128 : index
    %1 = alloc() : memref&lt;2x32xf32, 1&gt;
    %2 = alloc() : memref&lt;2x1xf32&gt;
    affine.dma_start %0[%c0], %1[%c0 mod 2, %c0], %2[%c0 mod 2, symbol(%c0_0)], %c128 : memref&lt;256xf32&gt;, memref&lt;2x32xf32, 1&gt;, memref&lt;2x1xf32&gt;
    affine.for %arg0 = 1 to 8 {
      affine.dma_start %0[%arg0], %1[%arg0 mod 2, %arg0], %2[%arg0 mod 2, symbol(%c0_0)], %c128 : memref&lt;256xf32&gt;, memref&lt;2x32xf32, 1&gt;, memref&lt;2x1xf32&gt;
      %8 = affine.apply #map3(%arg0)
      %9 = affine.apply #map4(%8)
      %10 = affine.apply #map4(%8)
      affine.dma_wait %2[%8 mod 2, symbol(%c0_0)], %c128 : memref&lt;2x1xf32&gt;
      %11 = affine.load %1[%8 mod 2, %8] : memref&lt;2x32xf32, 1&gt;
      %12 = &#34;compute&#34;(%11) : (f32) -&gt; f32
      affine.store %12, %1[%8 mod 2, %8] : memref&lt;2x32xf32, 1&gt;
    }
    %3 = affine.apply #map3(%c8)
    %4 = affine.apply #map4(%3)
    %5 = affine.apply #map4(%3)
    affine.dma_wait %2[%3 mod 2, symbol(%c0_0)], %c128 : memref&lt;2x1xf32&gt;
    %6 = affine.load %1[%3 mod 2, %3] : memref&lt;2x32xf32, 1&gt;
    %7 = &#34;compute&#34;(%6) : (f32) -&gt; f32
    affine.store %7, %1[%3 mod 2, %3] : memref&lt;2x32xf32, 1&gt;
    dealloc %2 : memref&lt;2x1xf32&gt;
    dealloc %1 : memref&lt;2x32xf32, 1&gt;
    return
  }
}</code></pre></div><div class=edit-meta>Last updated on 29 Nov 2019<br>Published on 29 Nov 2019<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/Passes.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/design/usageofconst/ title="Usage of 'Const' in MLIR, for core IR types"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Usage of &#39;Const&#39; in MLIR, for core IR types</a>
<a class="nav nav-next" href=/docs/tutorials/ title=Tutorials>Next - Tutorials <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=http://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Docs</a><ul class=sub-menu><li><a href=/docs/tutorials/>Tutorials</a><ul class=sub-menu><li><a href=/docs/tutorials/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/tutorials/interfaces/>Interfaces</a></li><li><a href=/docs/tutorials/traits/>Introduction to Operation Traits</a></li><li><a href=/docs/tutorials/quickstartrewrites/>Quickstart on Graph Rewrite</a></li><li><a href=/docs/tutorials/toy/>Toy Tutorial</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Intro</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li><a href=/docs/dialects/>Dialect</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgops/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li></ul></li><li><a href=/docs/design/>Design</a><ul class=sub-menu><li><a href=/docs/design/canonicalization/>Canonicalization</a></li><li><a href=/docs/design/rationalesimplifiedpolyhedralform/>Case for a Simplified Polyhedral Form</a></li><li><a href=/docs/design/rationale/>Design Rationale</a></li><li><a href=/docs/design/diagnostics/>Diagnostics Infrastructure</a></li><li><a href=/docs/design/edsc/>EDSC: Declarative Builders</a></li><li><a href=/docs/design/genericdagrewriter/>Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/design/mlirforgraphalgorithms/>Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/design/quantization/>Quantization</a></li><li><a href=/docs/design/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/design/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/design/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/langref/>Core Specification</a></li><li class=active><a href=/docs/passes/>Passes</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>