<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Design Rationale - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/design/rationale/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Design Rationale</h1><p>This document is intended to capture some of the alternatives considered and
open debates in the design of MLIR, along with the rationale for certain
decisions we made. This is not intended to be a &ldquo;finely groomed&rdquo; document - we
prefer the ability to dump in interesting tidbits without worrying too much
about their consistency or readability.</p><p>[TOC]</p><h2 id=abstract>Abstract</h2><p>MLIR is a compiler intermediate representation with similarities to traditional
three-address SSA representations (like
<a href=http://llvm.org/docs/LangRef.html>LLVM IR</a> or
<a href=https://github.com/apple/swift/blob/master/docs/SIL.rst>SIL</a>), but which
introduces notions from the polyhedral loop optimization works as first class
concepts. This hybrid design is optimized to represent, analyze, and transform
high level dataflow graphs as well as target-specific code generated for high
performance data parallel systems. Beyond its representational capabilities, its
single continuous design provides a framework to lower from dataflow graphs to
high performance target specific code.</p><p>MLIR stands for one of &ldquo;Multi-Level IR&rdquo; or &ldquo;Multi-dimensional Loop IR&rdquo; or
&ldquo;Machine Learning IR&rdquo; or &ldquo;Mid Level IR&rdquo;, we prefer the first. This document only
provides the rationale behind MLIR &ndash; its actual
<a href=LangRef.md>specification document</a> and other content is hosted elsewhere.</p><h2 id=introduction-and-motivation>Introduction and Motivation</h2><p>The Multi-Level Intermediate Representation (MLIR) is intended for easy
expression and optimization of computations involving deep loop nests and dense
matrices of high dimensionality. It is thus well-suited to deep learning
computations in particular. Yet it is general enough to also represent arbitrary
sequential computation. The representation allows high-level optimization and
parallelization for a wide range of parallel architectures including those with
deep memory hierarchies &mdash; general-purpose multicores, GPUs, and specialized
neural network accelerators.</p><p>MLIR uses ideas drawn from IRs of LLVM and Swift for lower level constructs
while combining them with ideas from the polyhedral abstraction to represent
loop nests, multidimensional data (tensors), and transformations on these
entities as first class concepts in the IR.</p><p>MLIR is a multi-level IR, i.e., it represents code at a domain-specific
representation such as HLO or TensorFlow graphs, all the way down to the machine
level. MLIR is able to represent arbitrary control flow and arbitrary data
accesses, and is general enough to represent nearly all sequential computation.
This is a key distinction from existing polyhedral representation
implementations (such as LLVM <a href=https://polly.llvm.org/>Polly</a>) that are able to
use the polyhedral abstraction in a way isolated from the LLVM IR and only for
affine loop nests, i.e., portions of the code where array accesses, loop bounds,
and conditionals are regular (involve linear functions of loop iterators and
constant symbols). The presence of statically unpredictable data accesses or
control flow does not preclude representation in MLIR, but only limits to a
certain extent the ability to reason about and apply transformations using the
polyhedral abstraction.</p><p>Maps, sets, and relations with affine constraints are the core structures
underlying a polyhedral representation of high-dimensional loop nests and
multidimensional arrays. These structures are represented as textual
expressions in a form close to their mathematical form. These structures are
used to capture loop nests, tensor data structures, and how they are reordered
and mapped for a target architecture. All structured or &ldquo;conforming&rdquo; loops are
captured as part of the polyhedral information, and so are tensor variables,
their layouts, and subscripted accesses to these tensors in memory.</p><p>The information captured in the IR allows a compact expression of all loop
transformations, data remappings, explicit copying necessary for explicitly
addressed memory in accelerators, mapping to pre-tuned expert written
primitives, and mapping to specialized vector instructions. Loop transformations
that can be easily implemented include the body of affine transformations: these
subsume all traditional loop transformations (unimodular and non-unimodular)
such as loop tiling, interchange, permutation, skewing, scaling, relative
shifting, reversal, fusion, and distribution/fission. Transformations on data
layout such as padding and transforming to blocked layouts are also represented
well via affine layout maps.</p><p>MLIR&rsquo;s design allows a progressive lowering to target-specific forms. Besides
high-level transformations for loop nests and data layouts that a typical
mid-level optimizer is expected to deal with, MLIR is also designed to perform
certain low-level scheduling and mapping decisions that a typical backend IR is
entrusted with: these include mapping to specialized vector instructions,
auto-vectorization, and software pipelining. The need to support these
transformations stems from the fact that neural network accelerators have
specialized units that deal with large chunks of data whose computation maps
back to chunks of more than one loop of the loop nests as viewed by a program at
a level closer to the original specification. Such specialized units or
instructions operate on multidimensional data chunks from a programmer&rsquo;s
viewpoint. It thus makes it hard or infeasible for a backend operating on a very
low-level IR close to assembly to lift and reconstruct loops and perform such a
mapping. This is in contrast to classic instruction selection and scheduling in
today&rsquo;s compilers that primarily only deals with the body of the innermost loop.
MLIR also facilitates automatic mapping to expert pre-tuned primitives or vendor
libraries operating on data at higher levels (or at the highest level) of the
memory hierarchy.</p><p>In summary, MLIR is convenient for and closed under the kind of transformations
needed to lower to general-purpose as well as specialized accelerators. It also
allows one to build modular and reusable target independent and target dependent
passes.</p><h2 id=design-decisions>Design Decisions</h2><p>This section sheds light on some of the design decisions &ndash; some of these are
indirectly implied by the specification document.</p><h3 id=loads-and-stores>Loads and stores</h3><p>The &lsquo;load&rsquo; and &lsquo;store&rsquo; instructions are specifically crafted to fully resolve to
an element of a memref. These instructions take as arguments n+1 indices for an
n-ranked tensor. This disallows the equivalent of pointer arithmetic or the
ability to index into the same memref in other ways (something which C arrays
allow for example). Furthermore, for the affine constructs, the compiler can
follow use-def chains (e.g. through
<a href=Dialects/Affine.md#affineapply-operation>affine.apply operations</a>) or through
the map attributes of <a href=Dialects/Affine.md#Operations>affine operations</a>) to
precisely analyze references at compile-time using polyhedral techniques. This
is possible because of the <a href=Dialects/Affine.md#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>.</p><p>A scalar of element-type (a primitive type or a vector type) that is stored in
memory is modeled as a 0-d memref. This is also necessary for scalars that are
live out of for loops and if conditionals in a function, for which we don&rsquo;t yet
have an SSA representation &ndash;
<a href=#mlfunction-extensions-for- title=escaping-scalars>an extension</a> to allow that is
described later in this doc.</p><h3 id=symbols-and-types>Symbols and types</h3><p>The current MLIR disallows use of symbols in types. For example, when a tensor
or memref dimension is statically unknown, it is denoted in the type as &lsquo;?&rsquo;. An
SSA symbol is then bound to it when a memref is created. The actual value of the
unknown dimension can be queried using the &ldquo;dim&rdquo; builtin as shown below.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">func foo(...) {
  %A = alloc &lt;8x?xf32, #lmap&gt; (%N)
  ...
  call bar(%A) : (memref&lt;8x?xf32, #lmap&gt;)
}

func bar(%A : memref&lt;8x?xf32, #lmap&gt;) {
  // Type of %A indicates that %A has dynamic shape with 8 rows
  // and unknown number of columns. The number of columns is queried
  // dynamically using dim instruction.
  %N = dim %A, 1 : memref&lt;8x?xf32, #lmap&gt;

  affine.for %i = 0 to 8 {
    affine.for %j = 0 to %N {
      // A[i,j] += 1
      %s1 = affine.load %A[%i, %j] : memref&lt;8x?xf32, #lmap&gt;
      %s2 = add %s1, 1
      affine.store %s2, %A[%i, %j] : memref&lt;8x?xf32, #lmap&gt;
    }
  }
  return
}</code></pre></div><p>An alternative design is to embed the reference to symbols directly in the
type - memref<8x%Nxf32>. We went for the current approach in MLIR because it
simplifies the design &mdash; types remain immutable when the values of symbols
change.</p><h3 id=block-arguments-vs-phi-nodes>Block Arguments vs PHI nodes</h3><p>MLIR Regions represent SSA using &ldquo;<a href=LangRef.md#blocks>block arguments</a>&rdquo; rather
than <a href=http://llvm.org/docs/LangRef.html#i-phi>PHI instructions</a> used in LLVM.
This choice is representationally identical (the same constructs can be
represented in either form) but block arguments have several advantages:</p><ol><li>LLVM PHI nodes always have to be kept at the top of a block, and
transformations frequently have to manually skip over them. This is defined
away with BB arguments.</li><li>LLVM has a separate function Argument node. This is defined away with BB
arguments, because the arguments to the entry block serve this purpose.</li><li>Blocks of PHI nodes in LLVM execute atomically, which is surprising and
super confusing to compiler engineers and it is easy to introduce bugs with
this (very related to the
&ldquo;<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.524.5461&amp;rep=rep1&amp;type=pdf">lost copy</a>&ldquo;
problem in SSA lowering literature.) With the BB argument representation,
this confusion is defined away.</li><li>The entry list of PHI nodes in LLVM are unordered, and some blocks have
thousands of predecessors (e.g. unwind blocks). This can cause long compile
time problems because transformations have to linearly scan this list. This
is defined away with BB argument representation.</li><li>LLVM has no way to represent values that are available only in one successor
but not the other, e.g. its invoke instruction cannot produce the exception
value JUST on the exception edge. Instead, the
<a href=http://llvm.org/docs/LangRef.html#landingpad-instruction>landingpad instruction</a>
is a hack used to represent this. MLIR doesn&rsquo;t make use of this capability,
but SIL uses it extensively, e.g. in the
<a href=https://github.com/apple/swift/blob/master/docs/SIL.rst#switch-enum>switch_enum instruction</a>.</li></ol><p>For more context, block arguments were previously used in the Swift
<a href=https://github.com/apple/swift/blob/master/docs/SIL.rst>SIL Intermediate Representation</a>,
and described in
<a href="https://www.youtube.com/watch?v=Ntj8ab-5cvE">a talk on YouTube</a>. The section of
interest
<a href="https://www.google.com/url?q=https://youtu.be/Ntj8ab-5cvE?t%3D596&amp;sa=D&amp;ust=1529450150971000&amp;usg=AFQjCNFQHEWL7m8q3eO-1DiKw9zqC2v24Q">starts here</a>.</p><h3 id=index-type-disallowed-in-vector-tensor-memref-types>Index type disallowed in vector/tensor/memref types</h3><p>Index types are not allowed as elements of <code>vector</code>, <code>tensor</code> or <code>memref</code> type.
Index types are intended to be used for platform-specific &ldquo;size&rdquo; values and may
appear in subscripts, sizes of aggregate types and affine expressions. They are
also tightly coupled with <code>affine.apply</code> and affine.load/store operations;
having <code>index</code> type is a necessary precondition of a value to be acceptable by
these operations. While it may be useful to have <code>memref&lt;?xindex&gt;</code> to express
indirect accesses, e.g. sparse matrix manipulations or lookup tables, it creates
problems MLIR is not ready to address yet. MLIR needs to internally store
constants of aggregate types and emit code operating on values of those types,
which are subject to target-specific size and alignment constraints. Since MLIR
does not have a target description mechanism at the moment, it cannot reliably
emit such code. Moreover, some platforms may not support vectors of type
equivalent to <code>index</code>.</p><p>Indirect access use cases can be alternatively supported by providing and
<code>index_cast</code> instruction that allows for conversion between <code>index</code> and
fixed-width integer types, at the SSA value level. It has an additional benefit
of supporting smaller integer types, e.g. <code>i8</code> or <code>i16</code>, for small indices
instead of (presumably larger) <code>index</code> type.</p><h3 id=bit-width-of-a-non-primitive-types-and-index-is-undefined>Bit width of a non-primitive types and <code>index</code> is undefined</h3><p>The bit width of a compound type is not defined by MLIR, it may be defined by a
specific lowering pass. In MLIR, bit width is a property of certain primitive
<em>type</em>, in particular integers and floats. It is equal to the number that
appears in the type definition, e.g. the bit width of <code>i32</code> is <code>32</code>, so is the
bit width of <code>f32</code>. The bit width is not <em>necessarily</em> related to the amount of
memory (in bytes) or the size of register (in bits) that is necessary to store
the value of the given type. These quantities are target and ABI-specific and
should be defined during the lowering process rather than imposed from above.
For example, <code>vector&lt;3xi57&gt;</code> is likely to be lowered to a vector of four 64-bit
integers, so that its storage requirement is <code>4 x 64 / 8 = 32</code> bytes, rather
than <code>(3 x 57) ceildiv 8 = 22</code> bytes as can be naively computed from the
bitwidth. Individual components of MLIR that allocate space for storing values
may use the bit size as the baseline and query the target description when it is
introduced.</p><p>The bit width is not defined for dialect-specific types at MLIR level. Dialects
are free to define their own quantities for type sizes.</p><h3 id=signless-types>Signless types</h3><p>Integers in the builtin MLIR type system have a bitwidth (note that the <code>index</code>
type has a symbolic width equal to the machine word size), but they do not have
an intrinsic sign. This means that the &ldquo;standard ops&rdquo; operation set has things
like <code>addi</code> and <code>muli</code> which do two&rsquo;s complement arithmetic, but some other
operations get a sign, e.g. <code>divis</code> vs <code>diviu</code>.</p><p>LLVM uses the <a href=http://llvm.org/docs/LangRef.html#integer-type>same design</a>,
which was introduced in a revamp rolled out
<a href=http://releases.llvm.org/2.0/docs/LangRef.html#t_derived>in the LLVM 2.0 integer type</a>.
Prior to that, from
<a href=http://releases.llvm.org/1.0/docs/LangRef.html#t_classifications>LLVM 1.0</a> to
<a href=http://releases.llvm.org/1.9/docs/LangRef.html#t_classifications>1.9</a>, LLVM
uses signed types like &ldquo;sbyte&rdquo; and &ldquo;ubyte&rdquo;. This shift was important and has
served LLVM well over the years. The reason this is important is that it is a
good thing for an intermediate representation to represent the same computation
with the same instruction. Signed types got in the way, because (e.g.) an &ldquo;add
of an sbyte&rdquo; does the same computation as an &ldquo;add of a ubyte&rdquo;, but the type
system made them look artificially different. This split also required casts
like &ldquo;cast from sbyte to ubyte&rdquo; which do nothing at the machine level. Removing
signs from the type system eliminated these problems, making the compiler
simpler.</p><p>More information about this split is available in an old
<a href="https://www.youtube.com/watch?v=VeRaLPupGks">talk on youtube</a> talking about
LLVM 2.0.</p><p>Note that this rationale only applies to the &ldquo;standard ops&rdquo; dialect in which we
can express an opinion about its design. Other dialects generally try to model
an external system, and should aim to reflect its design as closely as possible.</p><h3 id=splitting-floating-point-vs-integer-operations>Splitting floating point vs integer operations</h3><p>The MLIR &ldquo;standard&rdquo; operation set splits many integer and floating point
operations into different categories, for example <code>addf</code> vs <code>addi</code> and <code>cmpf</code> vs
<code>cmpi</code>
(<a href=http://llvm.org/docs/LangRef.html#binary-operations>following the design of LLVM</a>).
These instructions <em>are</em> polymorphic on the number of elements in the type
though, for example <code>addf</code> is used with scalar floats, vectors of floats, and
tensors of floats (LLVM does the same thing with its scalar/vector types).</p><p>This split is important because floating point and integer operations are quite
different in practice: for example, floating point values include NaN&rsquo;s, so
<a href=http://llvm.org/docs/LangRef.html#icmp-instruction>integer comparisons</a> and
<a href=http://llvm.org/docs/LangRef.html#fcmp-instruction>floating point comparisons</a>
should use different comparison opcodes. On the arithmetic side of things,
floating point operations support rounding modes, floating point contractions,
<a href=http://llvm.org/docs/LangRef.html#fadd-instruction>&ldquo;fast math&rdquo;</a>, and integers
may want to have two&rsquo;s complement overflow behavior or be undefined on
<a href=http://llvm.org/docs/LangRef.html#add-instruction>various forms of wrapping</a>
for performance.</p><p>We are a long way from this sort of thing being a priority to care about in
MLIR, but since we have experience and know the right way to do this, we&rsquo;d
rather design it in from the beginning.</p><p>Note that this rationale only applies to the &ldquo;standard ops&rdquo; dialect in which we
can express an opinion about its design. Other dialects generally try to model
an external system, and should aim to reflect its design as closely as possible.</p><h3 id=specifying-sign-in-integer-comparison-operations>Specifying sign in integer comparison operations</h3><p>Since integers are <a href=#signless-types>signless</a>, it is necessary to define the
sign for integer comparison operations. This sign indicates how to treat the
foremost bit of the integer: as sign bit or as most significant bit. For
example, comparing two <code>i4</code> values <code>0b1000</code> and <code>0b0010</code> yields different
results for unsigned (<code>8 &gt; 3</code>) and signed (<code>-8 &lt; 3</code>) interpretations. This
difference is only significant for <em>order</em> comparisons, but not for <em>equality</em>
comparisons. Indeed, for the latter all bits must have the same value
independently of the sign. Since both arguments have exactly the same bit width
and cannot be padded by this operation, it is impossible to compare two values
whose bit representations would differ while the values are interpreted as
equal.</p><h3 id=specifying-comparison-kind-as-attribute>Specifying comparison kind as attribute</h3><p>Unlike arithmetic, comparison operators share several common properties, e.g.
they cannot be considered associative. In practice, comparisons are sometimes
implemented by the same instruction or its variants so it makes sense to group
them together at the IR level.</p><p>An alternative would be introducing ten distinct operators for all currently
supported kinds of integer comparisons. These operators would have increased the
number of &ldquo;reserved&rdquo; names used by standard operations as well as the size of
the C++ API while their implementations would have been mostly identical.</p><p>The comparison kind is internally an integer attribute. However, for the sake of
readability by humans, custom assembly form accepts string literals that are
mapped to the underlying integer values: <code>cmpi &quot;eq&quot;, %lhs, %rhs</code> better implies
integer equality comparison than <code>cmpi 0, %lhs, %rhs</code> where it is unclear what
gets compared to what else. This syntactic sugar is possible thanks to parser
logic redefinitions for custom assembly form of non-builtin operations.
Supporting it in the full notation would have required changing how the main
parsing algorithm works and may have unexpected repercussions. While it had been
possible to store the predicate as string attribute, it would have rendered
impossible to implement switching logic based on the comparison kind and made
attribute validity checks (one out of ten possible kinds) more complex.</p><h3 id=select-operation-to-implement-min-max>&lsquo;select&rsquo; operation to implement min/max</h3><p>Although <code>min</code> and <code>max</code> operations are likely to occur as a result of
transforming affine loops in ML functions, we did not make them first-class
operations. Instead, we provide the <code>select</code> operation that can be combined with
<code>cmpi</code> to implement the minimum and maximum computation. Although they now
require two operations, they are likely to be emitted automatically during the
transformation inside MLIR. On the other hand, there are multiple benefits of
introducing <code>select</code>: standalone min/max would concern themselves with the
signedness of the comparison, already taken into account by <code>cmpi</code>; <code>select</code> can
support floats transparently if used after a float-comparison operation; the
lower-level targets provide <code>select</code>-like instructions making the translation
trivial.</p><p>This operation could have been implemented with additional control flow: <code>%r =
select %cond, %t, %f</code> is equivalent to</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>^bb0:
  cond_br %cond, ^bb1(%t), ^bb1(%f)
^bb1(%r):</code></pre></div><p>However, this control flow granularity is not available in the ML functions
where min/max, and thus <code>select</code>, are likely to appear. In addition, simpler
control flow may be beneficial for optimization in general.</p><h3 id=regions>Regions</h3><h4 id=attributes-of-type-block>Attributes of type &lsquo;Block&rsquo;</h4><p>We considered representing regions through <code>ArrayAttr</code>s containing a list of a
special type <code>IRBlockAttr</code>, which in turn would contain a list of operations.
All attributes in MLIR are unique’d within the context, which would make the IR
inside the regions immortal for no good reason.</p><h4 id=use-inlined-functions-as-regions>Use &ldquo;inlined&rdquo; functions as regions</h4><p>We considered attaching a &ldquo;force-inline&rdquo; attribute on a function and/or a
function <code>call</code> operation. Even the minimal region support (use cases in
affine.for and affine.if existing before the regions) requires access to the
values defined in the dominating block, which is not supported by functions.
Conceptually, function bodies are instances of regions rather than the inverse;
regions can also be device kernels, alternative sections, etc.</p><h4 id=dedicated-region-operation>Dedicated <code>region</code> operation</h4><p>This would mean we have a special kind of operation that is allowed to have
regions while other operations are not. Such distinction is similar to the
Stmt/Op difference we have had and chose to remove to make the IR simpler and
more flexible. It would also require analyses and passes to consider the
interplay between operations (e.g., an <code>affine.for</code> operation must be followed
by a region operation). Finally, a region operation can be introduced using the
current implementation, among other operations and without being special in any
sense.</p><h4 id=explicit-capture-of-the-values-used-in-a-region>Explicit capture of the values used in a region</h4><p>Being able to use values defined outside the region implies that use-def chains
may contain uses from different nested regions. Consequently, IR transformations
and analyses can pull the instruction defining the value across region
boundaries, for example in case of TableGen-defined canonicalization patterns.
This would not be the case if all used values had been passed as region
arguments. One of the motivations for introducing regions in the IR is precisely
to enable cross-region analyses and transformations that are simpler than
inter-procedural transformations. Having uses from different regions appear in
the same use-def chain, contrary to an additional data structure maintaining
correspondence between function call arguments as uses of the original
definitions and formal arguments as new definitions, enables such
simplification. Since individual operations now belong to blocks, which belong
to regions, it is always possible to check if the definition of the value
belongs to the same region as its particular use. The risk is that any IR
traversal will need to handle explicitly this situation and it is easy to forget
a check (or conversely it isn’t easy to design the right check in a tablegen
pattern for example): traversing use-def chains potentially crosses implicitly
semantic barriers, making it possible to unknowingly break region semantics.
This is expected to be caught in the verifier after the transformation.</p><p>At the same time, one may choose to pass certain or all values as region
arguments to explicitly break the use-def chains in the current proposal. This
can be combined with an attribute-imposed semantic requirement disallowing the
body of the region to refer to any value from outside it.</p><h3 id=quantized-integer-operations>Quantized integer operations</h3><p>We haven&rsquo;t designed integer quantized operations in MLIR, but experience from
TensorFlow suggests that it is better to put information about the quantization
range/scale into the type itself, rather than have a single type like &ldquo;qint8&rdquo;
and put these on attributes of the operation.</p><p>There are a few ways to do this with MLIR, including at least:</p><ul><li>We could do the same thing TensorFlow does - and we will <em>have</em> to support
that model to some extent for compatibility.</li><li>We can encode the fp range of quantized integers directly into the types
when they are constants. The best practice on this seems to be to encode the
zero point as well as a scale factor. This ensures that 0.0 is always
exactly representable, e.g. <code>qi8&lt;-1.42, 31.23x&gt;</code>.</li><li>We could theoretically encode dynamically determined ranges into the types
using something like <code>qi8&lt;?,?&gt;</code> with the bounds being determined through the
SSA dataflow graph dynamically - similar to how dynamic shapes are handled.</li></ul><p>We will definitely need to do #1 for compatibility, we probably want to do #2,
and we should investigate #3 over time. That said, our short term plan is to get
more implementation experience with the rest of the system first, then come back
to re-examine the representation for quantized arithmetic when we have that
experience. When we do, we should chat with benoitjacob@ and
<a href=https://arxiv.org/abs/1712.05877>read the paper</a>.</p><h3 id=dialect-type-extensions>Dialect type extensions</h3><p>This section describes the design decisions that shaped the dialect extensible
type system present in MLIR.</p><h4 id=reserving-dialect-type-kinds>Reserving dialect type kinds</h4><p>Dialects that wish to define type extensions must reserve a range of type kinds
within a &lsquo;.def&rsquo; file within the core IR library. This means that every dialect
wishing to define custom types must modify this file, but it guarantees that all
type casting checkings are performed in O(1) time.</p><h4 id=interactions-between-dialects>Interactions between dialects</h4><p>There are two different interactions between dialects that are important to
understand. When types of a dialect are:</p><ul><li><p>In operations of other dialects</p><ul><li>For standard/builtin operations, only standard/builtin types are
allowed. This restriction allows for operations to clearly understand
the invariants that they are working under.</li><li>Outside of standard/builtin operations, dialects are expected to verify
the allowable operation types per operation.</li></ul></li><li><p>In types of other dialects</p><ul><li>For standard/builtin types, these types are allowed to contain types
from other dialects. This simplifies the type system and removes the
need for dialects to redefine all of the standard aggregate types, e.g.
tensor, as well as the memref type. Dialects are expected to verify that
a specific type is valid within a standard type, e.g. if a type can be
an element of a tensor.</li><li>For dialect types, the dialect is expected to verify any type
invariants, e.g. if the standard tensor type can contain a specific type
of that dialect.</li></ul></li></ul><h4 id=separating-builtin-and-standard-types>Separating builtin and standard types</h4><p>Following the separation between the built-in and standard dialect, it makes
sense to separate built-in types and standard dialect types. Built-in types are
required for the validity of the IR itself, e.g. the function type (which
appears in function signatures and generic assembly forms of operations).
Integer, float, vector, memref and tensor types, while important, are not
necessary for IR validity.</p><h4 id=unregistered-types>Unregistered types</h4><p>MLIR supports unregistered operations in generic assembly form. MLIR also
supports a similar concept for types. When parsing, if the dialect for dialect
type has not been registered the type is modeled as an &lsquo;OpaqueType&rsquo;. This allows
for types to be round-tripped without needing to link in the dialect library
that defined them. No additional information about opaque types, outside of
parsing/printing, will be available.</p><h4 id=dialect-type-syntax>Dialect type syntax</h4><p>Dialect extended types are represented as string literals wrapped inside of the
dialect namespace. This means that the parser delegates to the dialect for
parsing specific type instances. This differs from the representation of dialect
defined operations, of which have an identifier name that the parser uses to
identify and parse them.</p><p>This representation was chosen for several reasons:</p><h5 id=dialects-must-provide-custom-type-parsers>Dialects must provide custom type parsers</h5><p>Dialect type parsing cannot plug into the existing parser infrastructure as
operations do with the OpAsmParser/Printer. Operations have a defined syntax
structure that is the same across all dialects. Types, on the other hand, may
have many different, and sometimes conflicting, parsing constraints that would
be difficult/unmaintainable to provide within a single interface.</p><p>This also has the added benefit of encouraging dialects to reuse existing
external type parsers. For example, an LLVM dialect may provide an MLIR LLVM
type that is simply a wrapper around LLVM types. The LLVM dialect would then use
the existing LLVM type parsing infrastructure.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">%s = &#34;foo&#34;() : () -&gt; !llvm&lt;&#34;i32*&#34;&gt;</code></pre></div><h5 id=types-do-not-always-have-canonical-names>Types do not always have canonical names</h5><p>Unlike operations, types generally do not have a formal canonical name. For
example, function types have no defined keyword and integer types are defined by
a regular expression to support arbitrary bitwidth. Dialects with existing type
systems, e.g. LLVM, are likely to provide wrappers around their existing type
systems. For these wrapper types there is no simple canonical name, it&rsquo;s logical
to think of these types as existing within the namespace of the dialect. If a
dialect wishes to assign a canonical name to a type, it can be done via
<a href=LangRef.md#type-aliases>type aliases</a>.</p><h3 id=tuple-types>Tuple types</h3><p>The MLIR type system provides first class support for defining
<a href=LangRef.md#tuple-type>tuple types</a>. This is due to the fact that <code>Tuple</code>
represents a universal concept that is likely to, and has already begun to,
present itself in many different dialects. Though this type is first class in
the type system, it merely serves to provide a common mechanism in which to
represent this concept in MLIR. As such, MLIR provides no standard operations
for interfacing with <code>tuple</code> types. It is up to dialect authors to provide
operations, e.g. extract_tuple_element, to interpret and manipulate them. When
possible, operations should prefer to use multiple results instead. These
provide a myriad of benefits, such as alleviating any need for tuple-extract
operations that merely get in the way of analysis and transformation.</p><h3 id=assembly-forms>Assembly forms</h3><p>MLIR decides to support both generic and custom assembly forms under the
following considerations:</p><p>MLIR is an open system; it is designed to support modular and pluggable
dialects. Depending on whether there exists a corresponding dialect and whether
the dialect is plugged in, operations may or may not be registered into MLIR
system. Yet we still need a way to investigate these operations. So the generic
assembly form is mandated by this aspect of MLIR system. It provides a default
textual form for operations.</p><p>On the other hand, an assembly form is for assisting developers to investigate
the IR. The generic form serves as a safe fallback but it can be too verbose for
certain ops. Therefore, MLIR gives each dialect the choice to define a custom
assembly form for each operation according to the operation&rsquo;s semantics and
specific needs. The custom assembly form can de-duplicate information from the
operation to derive a more concise form, thus better facilitating the
comprehension of the IR.</p><h2 id=examples>Examples</h2><p>This section describes a few very simple examples that help understand how MLIR
represents computation.</p><h3 id=non-affine-control-flow>Non-affine control flow</h3><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// A simple linear search in every row of a matrix
for (i = 0; i &lt; N; i++) {
  for (j = 0; j &lt; N; j++) {
    // dynamic control flow
    if (a[i][j] == key) {
      s[i] = j;
      break;
    }
  }
}</code></pre></div><p>The presence of dynamic control flow leads to an inner non-affine function
nested in an outer function that using affine loops.</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">func @search(%A: memref&lt;?x?xi32, %S: &lt;?xi32&gt;, %key : i32) {
  %ni = dim %A, 0 : memref&lt;?x?xi32&gt;
  // This loop can be parallelized
  affine.for %i = 0 to %ni {
    call @search_body (%A, %S, %key, %i) : (memref&lt;?x?xi32&gt;, memref&lt;?xi32&gt;, i32, i32)
  }
  return
}

func @search_body(%A: memref&lt;?x?xi32&gt;, %S: memref&lt;?xi32&gt;, %key: i32, %i : i32) {
  %nj = dim %A, 1 : memref&lt;?x?xi32&gt;
  br ^bb1(0)

^bb1(%j: i32)
  %p1 = cmpi &#34;lt&#34;, %j, %nj : i32
  cond_br %p1, ^bb2, ^bb5

^bb2:
  %v = affine.load %A[%i, %j] : memref&lt;?x?xi32&gt;
  %p2 = cmpi &#34;eq&#34;, %v, %key : i32
  cond_br %p2, ^bb3(%j), ^bb4

^bb3(%j: i32)
  affine.store %j, %S[%i] : memref&lt;?xi32&gt;
  br ^bb5

^bb4:
  %jinc = addi %j, 1 : i32
  br ^bb1(%jinc)

^bb5:
  return
}</code></pre></div><p>As per the <a href=LangRef.md>MLIR spec</a>, the restrictions on dimensions and symbol
identifiers to be used with the affine.apply operation only apply to accesses
inside <code>affine.for</code> and <code>affine.if</code> operations. However, an analysis of accesses
inside the called function (<code>@search_body</code>) is necessary to determine if the
<code>%i</code> loop could be parallelized: such function access analysis is calling
context sensitive.</p><h3 id=non-affine-loop-bounds>Non-affine loop bounds</h3><p>Loop bounds that are not affine lead to a nesting of functions as shown below.</p><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
  <span class=k>for</span> <span class=p>(</span><span class=n>j</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>j</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>j</span><span class=o>++</span><span class=p>)</span>
    <span class=c1>// Non-affine loop bound for k loop.
</span><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=n>k</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>k</span> <span class=o>&lt;</span> <span class=n>pow</span><span class=p>(</span><span class=mi>2</span><span class=p>,</span> <span class=n>j</span><span class=p>);</span> <span class=n>k</span><span class=o>++</span><span class=p>)</span>
       <span class=k>for</span> <span class=p>(</span><span class=n>l</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>l</span> <span class=o>&lt;</span> <span class=n>N</span><span class=p>;</span> <span class=n>l</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
        <span class=c1>// block loop body
</span><span class=c1></span>        <span class=p>...</span>
       <span class=p>}</span></code></pre></div><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">func @outer_nest(%n : index) {
  affine.for %i = 0 to %n {
    affine.for %j = 0 to %n {
      %pow = call @pow(2, %j) : (index, index) -&gt;  index
      call @inner_nest(%pow, %n) : ...
    }
  }
  return
}

func @inner_nest(%m : index, %n : index) {
  affine.for %k = 0 to %m {
    affine.for %l = 0 to %n {
      ...
    }
  }
  return
}</code></pre></div><h3 id=reference-2d-convolution>Reference 2D Convolution</h3><p>The following example illustrates a reference implementation of a 2D
convolution, which uses an integer set <code>#domain</code> to represent valid input data
in a dilated convolution.</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Dilation factors S0 and S1 can be constant folded if constant at compile time.
#domain = (d0, d1)[S0,S1,S2,S3]: (d0 % S0 == 0, d1 % S1 == 0, d0 &gt;= 0, d1 &gt;= 0,
                                   S3 - d0 - 1 &gt;= 0, S4 - d1 - 1 &gt;= 0)
// Identity map (shown here for illustration).
#map0 = (d0, d1, d2, d3, d4, d5, d6) -&gt; (d0, d1, d2, d3, d4, d5, d6)

// Affine map from output to input coordinate space.
// d0 = output_h, d1 = output_w, d2 = kernel_h, d3 = kernel_w
// S0 = h_stride, S1 = w_stride, S2 = h_kernel_dilation, S3 = w_kernel_dilation
// S4 = h_pad_low, S5 = w_pad_low
//     %out0 =  %0#1 * %h_stride + %0#4 * %h_kernel_dilation - %h_pad_low
//     %out1=  %0#2 * %w_stride + %0#5 * %w_kernel_dilation - %w_pad_low
#map1_0 = (d0, d1, d2, d3) [S0, S1, S2, S3, S4, S5] -&gt; (d0 * S0 + d2 * S2 - %S4)
#map1_1 = (d0, d1, d2, d3) [S0, S1, S2, S3, S4, S5] -&gt; (d1 * S1 + d3 * S3 - %S5)

// Semi-affine map to undilated input coordinate space.
// d0 = input_h, d1 = input_w, S0 = h_base_dilation, S1 = w_base_dilation.
#map2_0 = (d0, d1) [S0, S1] -&gt; (d0 / S0)
#map2_1 = (d0, d1) [S0, S1] -&gt; (d1 / S1)

// Conv2D shapes:
// input:   [batch, input_height, input_width, input_feature]
// kernel: [kernel_height, kernel_width, input_feature, output_feature]
// output: [batch, output_height, output_width, output_feature]
func @conv2d(%input: memref&lt;16x1024x1024x3xf32, #lm0, /*scratchpad=*/1&gt;,
             %kernel: memref&lt;5x5x3x32xf32, #lm0, /*scratchpad=*/1&gt;,
             %output: memref&lt;16x512x512x32xf32, #lm0, /*scratchpad=*/1&gt;) {
  affine.for %b = 0 to %batch {
    affine.for %oh = 0 to %output_height {
      affine.for %ow = 0 to %output_width {
        affine.for %of = 0 to %output_feature {
          affine.for %kh = 0 to %kernel_height {
            affine.for %kw = 0 to %kernel_width {
              affine.for %if = 0 to %input_feature {
                // Calculate input indices.
                %1_0 = affine.apply #map1_0 (%0#1, %0#2, %0#4, %0#5)
                  [%h_stride, %w_stride, %h_kernel_dilation, %w_kernel_dilation,
                   %h_pad_low, %w_pad_low]
                %1_1 = affine.apply #map1_1 (%0#1, %0#2, %0#4, %0#5)
                  [%h_stride, %w_stride, %h_kernel_dilation, %w_kernel_dilation,
                   %h_pad_low, %w_pad_low]

                // Check if access is not in padding.
                affine.if #domain(%1_0, %1_1)
                                       [%h_base_dilation, %w_kernel_dilation, %h_bound, %w_bound] {
                  %2_0 = affine.apply #map2 (%1_0, %1_1)
                  %2_1 = affine.apply #map2 (%1_0, %1_1)
                  // Compute: output[output_indices] += input[input_indices] * kernel[kernel_indices]
                  call @multiply_accumulate(%input, %kernel, %output, %b, %oh, %ow, %of, %kh, %kw, %if, %2_0, %2_1)
                }
              }
            }
          }
        }
      }
    }
  }
  return
}</code></pre></div><p>TODO (Add more examples showing the IR for a variety of interesting cases)</p><h2 id=design-alternatives-and-extensions>Design alternatives and extensions</h2><p>This is a list of some design alternatives and extensions that we discussed in
detail but did not include in the spec or postponed them for future
consideration on demand. We will revisit these discussions when we have more
implementation experience and learn more about the challenges and limitations of
our current design in practice.</p><h3 id=polyhedral-code-representation-alternatives-schedule-lists-vs-schedules-trees-vs-affine-loop-if-forms>Polyhedral code representation alternatives: schedule lists vs schedules trees vs affine loop/if forms</h3><p>The current MLIR uses a representation of polyhedral schedules using a tree of
if/for loops. We extensively debated the tradeoffs involved in the typical
unordered polyhedral instruction representation (where each instruction has
multidimensional schedule information), discussed the benefits of schedule tree
forms, and eventually decided to go with a syntactic tree of affine if/else
conditionals and affine for loops. Discussion of the tradeoff was captured in
this document:
<a href=RationaleSimplifiedPolyhedralForm.md>MLIR: The case for a simplified polyhedral form</a>.</p><p>At a high level, we have two alternatives here:</p><ol><li>Schedule tree representation instead of an affine loop AST form: The current
proposal uses an affine loop and conditional tree form, which is syntactic
and with no separation of domains as sets and schedules as multidimensional
affine functions. A schedule tree form however makes polyhedral domains and
schedules a first class concept in the IR allowing compact expression of
transformations through the schedule tree without changing the domains of
instructions. Such a representation also hides prologues, epilogues, partial
tiles, complex loop bounds and conditionals making loop nests free of
&ldquo;syntax&rdquo;. Cost models instead look at domains and schedules. In addition, if
necessary such a domain schedule representation can be normalized to
explicitly propagate the schedule into domains and model all the cleanup
code. An example and more detail on the schedule tree form is in the next
section.</li><li>Having two different forms of &ldquo;affine regions&rdquo;: an affine loop tree form
and a polyhedral schedule tree form. In the latter, ops could carry
attributes capturing domain, scheduling, and other polyhedral code
generation options with IntegerSet, AffineMap, and other attributes.</li></ol><h4 id=schedule-tree-representation-for-affine-regions>Schedule Tree Representation for Affine Regions</h4><p>This representation is based on a simplified form of the domain/schedule
representation used by the polyhedral compiler community. Domains represent what
has to be executed while schedules represent the order in which domain elements
are interleaved. We model domains as non-piece-wise convex integer sets, and
schedules as affine functions; however, the former can be disjunctive, and the
latter can be piece-wise affine relations. In the schedule tree representation,
domain and schedules for instructions are represented in a tree-like structure
which is called a schedule tree. Each non-leaf node of the tree is an abstract
polyhedral dimension corresponding to an abstract fused loop for each ML
instruction that appears in that branch. Each leaf node is an ML Instruction.</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// A tiled matmul code (128x128x128) represented in schedule tree form

// #map0 = (d0, d1, d2, d3, d4, d5) -&gt; (128*d0 + d3, 128*d1 + d4, 128*d2 + d5)
#intset_ij = (i, j) [M, N, K]  : i &gt;= 0, -i + N - 1 &gt;= 0, j &gt;= 0, -j + N-1 &gt;= 0
#intset_ijk = (i, j, k) [M, N, K] : i &gt;= 0, -i + N - 1 &gt;= 0, j &gt;= 0,
                                     -j +  M-1 &gt;= 0, k &gt;= 0, -k + N - 1 &gt;= 0)
func @matmul(%A, %B, %C, %M, %N, %K) : (...)  { // %M, N, K are symbols
  // t1, t2, t3, t4, t5, t6  are abstract polyhedral loops
  mldim %t1 : {S1,S2,S3,S4,S5}  floordiv (i, 128) {
    mldim %t2 : {S1,S2,S3,S4,S5}  floordiv (j, 128) {
      // (%i, %j) = affine.apply (d0, d1) -&gt; (128*d0, 128*d1) (%t1, %t2)
      call dma_mem_to_scratchpad(%C, %i, %j, %M, %N, %K)
          with @intset_ij(%i, %j) [%M, %N, %K]
      mldim %t3 :   {S2,S3,S4,S5} floordiv (k, 128) {
        // (%i, %j, %k) = affine.apply (d0, d1, d2)
        //                          -&gt; (128*d0, 128*d1, 128*d2)  (%t1, %t2, %t3)
        call dma_mem_to_scratchpad(%A, ...) with #inset_ijk (%i, %j, %k) [%M, %N, %K]
        // (%i, %j, %k) = affine.apply (d0, d1, d2)
        //                          -&gt; (128*d0, 128*d1, 128*d2)  (%t1, %t2, %t3)
        call dma_mem_to_scratchpad(%B, ...) with #inset_ijk (%i, %j, %k) [%M, %N, %K]
        mldim %t4 : {S4} i mod 128 {
          mldim %t5 : {S4} j mod 128 {
            mldim %t6 : {S4} k mod 128 {
              // (%i, %j, %k) = affine.apply #map0 (%t1, %t2, %t3, %t4, %t5, %t6)
              call matmul_body(A, B, C, %i, %j, %k, %M, %N, %K)
                  with #inset_ijk(%i, %j, %k) [%M, %N, %K]
            } // end mld4im t6
          } // end mldim t5
        } // end mldim t4
      } // end mldim t3
      // (%i, %j) = affine.apply (d0, d1) -&gt; (128*d0, 128*d1) (%t1, %t2)
      call $dma_scratchpad_to_mem_C ... with #intset(%i, %j) [%M, %N, %K]
    }  // end mldim t2
  } // end mldim t1
  return
}</code></pre></div><h3 id=affine-relations>Affine Relations</h3><p>The current MLIR spec includes affine maps and integer sets, but not affine
relations. Affine relations are a natural way to model read and write access
information, which can be very useful to capture the behavior of opaque external
library calls, high-performance vendor libraries, or user-provided / user-tuned
routines.</p><p>An affine relation is a relation between input and output dimension identifiers
while being symbolic on a list of symbolic identifiers and with affine
constraints on the identifiers.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=err>//</span> <span class=k>Affine relation definition at the top of file</span>
<span class=k>affine-rel-def </span><span class=err>::</span><span class=o>=</span> <span class=k>affine-rel-id </span><span class=err>`=`</span> <span class=k>affine-relation-inline</span>

<span class=k>affine-rel-id </span><span class=err>::=</span> <span class=err>`##`</span> <span class=k>prefixed-id</span>

<span class=k>affine-relation-inline </span><span class=err>::=</span>
       <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>input-dims </span><span class=err>`</span><span class=p>)</span><span class=err>`</span> <span class=p>(</span><span class=err>`</span><span class=p>[</span><span class=err>`</span> <span class=k>symbols </span><span class=err>`</span><span class=p>]</span><span class=err>`</span><span class=p>)</span><span class=err>?</span> <span class=err>`</span><span class=o>-</span><span class=err>&gt;`</span>
       <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>output-dims </span><span class=err>`</span><span class=p>)</span><span class=err>`</span> <span class=err>:</span>  <span class=k>affine-constraint-conjunction</span>

<span class=k>input-dims </span><span class=err>::=</span> <span class=k>bare-id-list</span>
<span class=k>output-dims </span><span class=err>::=</span> <span class=k>bare-id-list</span>
<span class=k>symbols </span><span class=err>::=</span> <span class=k>bare-id-list</span>

<span class=k>affine-rel </span><span class=err>::=</span> <span class=k>affine-rel-id </span><span class=p>|</span> <span class=k>affine-relation-inline</span>

<span class=err>//</span> <span class=k>Usage</span>
<span class=k>affine-rel-spec </span><span class=err>::=</span> <span class=k>affine-rel dim-and-symbol-use-list</span></code></pre></div><p>All identifiers appearing in input-dims, output-dims, and symbol-dims are
pairwise distinct. All affine-constraint non-terminals in the above syntax are
allowed to contain identifiers only from input-dims, output-dims, and
symbol-dims.</p><p>Affine relations are used to model read, write, may_read, and may_write sets of
functions in the IR. The output dimension identifiers correspond to the data
dimensions.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// read relation: two elements ( d0 &lt;= r0 &lt;= d0+1 )
##aff_rel9 = (d0) -&gt; (r0) : r0 - d0 &gt;= 0, d0 - r0 + 1 &gt;= 0

func @count (%A : memref&lt;128xf32&gt;, %pos : i32) -&gt; f32
  reads: {%A ##aff_rel9 (%pos)}
  writes: /* empty */
  may_reads: /* empty */
  may_writes: /* empty */ {
bb0 (%0, %1: memref&lt;128xf32&gt;, i64):
  %val = affine.load %A [%pos]
  %val = affine.load %A [%pos + 1]
  %p = mulf %val, %val : f32
  return %p : f32
}</code></pre></div><h3 id=regions-1>Regions</h3><h4 id=making-function-definition-an-operation>Making function definition an operation</h4><p>MLIR supports values of a Function type. Instead of having first-class IR
concept for functions, one could define an operation with a body region that
defines a function value. The particularity of functions is that their names are
globally visible and can be referred to before being defined, unlike SSA values
that must be defined first. Implementing a &ldquo;function definition&rdquo; operation would
require to relax some of the SSA constraints in a region, and also make the IR
Module a region as well. It would also affect the core infrastructure (e.g.,
function passes) only for the sake of concept unification.</p><h4 id=having-types-on-a-region>Having types on a region</h4><p>Instead of inspecting the types of arguments of the first block, one could give
the region itself a type. This type would be redundant with block argument
types, which must have values and create room for type mismatches. While
functions do have types that are partly redundant with the arguments of the
first block in the function, this is necessary to support function declarations
that do not have a body which we can refer to in order to obtain the argument
types. A region is always contained in an operation or a function that can be
queried to obtain the “type” of the region if necessary.</p><p>A type on a region can be justified if Regions were to be considered separately
from the enclosing entity (operation or function) and had their own semantics
that should be checked.</p><h4 id=attaching-attributes-to-regions>Attaching attributes to regions</h4><p>Regions could be annotated with dialect attributes to use attribute verification
hooks. An operation could take multiple regions as arguments, and each of them
may require different attributes. However, there are currently very few
practical cases where this would be necessary. Instead, one could simulate
per-region attributes with array attributes attached to the entity containing
the region (operation or function). This decreases the overall complexity of the
IR and enables more concise and op-specific forms, e.g., when all regions of an
op have the same attribute that can be only mentioned once. Since the semantics
of the region is entirely defined by the enclosing entity, it also makes sense
to have attributes attached to that entity rather than to the region itself.</p><p>This can be reconsidered in the future if we see a non-neglectable amount of use
cases.</p><h3 id=read-write-may-read-may-write-sets-for-external-functions>Read/Write/May_Read/May_Write sets for External Functions</h3><p>Having read, write, may_read, and may_write sets for external functions which
include opaque ones, high-performance vendor libraries such as CuDNN, CuB, MKL,
FFT libraries, user-provided/optimized functions, or data movement runtimes such
as DMA ones is a powerful feature. It allows the compiler to perform analysis,
composition/transformation in the presence of such calls and with loops around
such calls on sub-tensors. For user-provided or custom hand-tuned functions, the
read/write/may_read/may_write sets could be provided a-priori by a user as part
of the external function signature or they could be part of a database.</p><p>TODO: Design this, and update to use function attribute syntax.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">##rel9 ( ) [s0] -&gt; (r0, r1) : 0 &lt;= r0 &lt;= 1023, 0 &lt;= r1 &lt;= s0 - 1

func @cblas_reduce_ffi(%M: memref&lt;1024 x ? x f32, #layout_map0, /*mem=*/0&gt;)
  -&gt; f32 [
  reads: {%M, ##rel9() }
  writes: /* empty */
  may_reads: /* empty */
  may_writes: /* empty */
]

func @dma_mem_to_scratchpad(%a : memref&lt;1024 x f32, #layout_map0, /*mem=*/0&gt;,
    %b : memref&lt;1024 x f32, #layout_map0, 1&gt;, %c : memref&lt;1024 x f32,
    #layout_map0&gt;) [
  reads: {%M, ##rel9() }
  writes: /* empty */
  may_reads: /* empty */
  may_writes: /* empty */
 ]</code></pre></div><h3 id=memref-extensions>Memref Extensions</h3><ol><li>Arbitrary polyhedral shapes for tensors: e.g., triangular shapes in tensor
dimensions where there is symmetry: use integer set (affine constraints) to
model tensor data space (instead of just extents). Requires some changes to
the IR and the in-memory form.</li><li><p>Layout maps</p><ol><li>Allow piece-wise affine maps for layouts: allows clean modeling of
boundary cases for images/tensors through padding, wrapping, mirroring,
padding where padded values are the results of computation as opposed to
data, padding in the interior as opposed to just boundaries.</li><li>Allow many-to-one layout maps: Index and layout maps in the current
proposal are bijective. Extending them to many-to-one layout maps allows
cleaner(?) modeling of broadcast/reduce style computations while reusing
memory.</li></ol><p>Proposal 2(a) requires non-trivial changes to the IR and the in-memory
representation. 2(b) requires no change, but impacts how cost models look at
index and layout maps.</p></li></ol><h3 id=affine-if-and-affine-for-extensions-for-escaping-scalars><code>affine.if</code> and <code>affine.for</code> Extensions for &ldquo;Escaping Scalars&rdquo;</h3><p>We considered providing a representation for SSA values that are live out of
<code>if/else</code> conditional bodies and loop carried in <code>affine.for</code> loops. We
ultimately abandoned this approach due to its complexity. In the current design
of MLIR, scalar variables cannot escape for loops or if instructions. In
situations, where escaping is necessary, we use zero-dimensional tensors and
memrefs instead of scalars.</p><p><strong>TODO</strong>: This whole section is obsolete and should be updated to use block
arguments and a yield like terminator in for/if instructions.</p><p>The abandoned design of supporting escaping scalars is as follows:</p><h4 id=affine-for-instruction>affine.for Instruction</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=err>[&lt;</span><span class=k>out-var-list</span><span class=err>&gt;</span> <span class=o>=</span><span class=p>]</span>
<span class=k>for </span><span class=err>%&lt;</span><span class=k>index-variable-name</span><span class=err>&gt;</span> <span class=err>=</span> <span class=err>&lt;</span><span class=k>lower-bound</span><span class=err>&gt;</span> <span class=p>.</span><span class=err>..</span> <span class=err>&lt;</span><span class=k>upper-bound</span><span class=err>&gt;</span> <span class=k>step </span><span class=err>&lt;</span><span class=k>step</span><span class=err>&gt;</span>
   <span class=err>[</span><span class=k>with </span><span class=err>&lt;</span><span class=k>in-var-list</span><span class=err>&gt;]</span> <span class=err>{</span> <span class=err>&lt;</span><span class=k>loop-instruction-list</span><span class=err>&gt;</span> <span class=err>}</span></code></pre></div><p>out-var-list is a comma separated list of SSA values defined in the loop body
and used outside the loop body. in-var-list is a comma separated list of SSA
values used inside the loop body and their initializers. loop-instruction-list
is a list of instructions that may also include a yield instruction.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Return sum of elements in 1-dimensional mref A
func i32 @sum(%A : memref&lt;?xi32&gt;, %N : i32) -&gt; (i32) {
   %init = 0
   %result = affine.for %i = 0 to N with %tmp(%init) {
      %value = affine.load %A[%i]
      %sum = %value + %tmp
      yield %sum
   }
   return %result : i32
}</code></pre></div><h4 id=affine-if-else-instruction>affine.if/else Instruction</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=err>&lt;</span><span class=k>out-var-list</span><span class=err>&gt;</span> <span class=o>=</span> <span class=k>affine</span><span class=p>.</span><span class=k>if </span><span class=err>(&lt;</span><span class=k>cond-list</span><span class=err>&gt;)</span> <span class=err>{...}</span> <span class=err>[</span><span class=k>else </span><span class=err>{...}]</span></code></pre></div><p>Out-var-list is a list of SSA values defined by the if-instruction. The values
are arguments to the yield-instruction that occurs in both then and else clauses
when else clause is present. When if instruction contains only if clause, the
escaping value defined in the then clause should be merged with the value the
variable had before the if instruction. The design captured here does not handle
this situation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Compute sum of half of the array
func i32 @sum_half(%A : memref&lt;?xi32&gt;, %N : i32) -&gt; (i32) {
   %s0 = 0
   %s1 = affine.for %i = 1 ... N step 1 with %s2 (%s0) {
       %s3 = if (%i &gt;= %N / 2) {
          %v0 = affine.load %A[%i]
          %s4 = %s2 + %v0
          yield %s4
       }
       yield %s3
   }
   return %s1 : i32
}</code></pre></div><h3 id=multithreading-the-compiler>Multithreading the compiler</h3><p>People want compilers to go fast, and one simple way to do that is to
multi-thread them. There are multiple strategies for this, but a simple one is
to optimize and compile separate functions in parallel. LLVM&rsquo;s original pass
manager anticipated this demand, and the CallGraphSCCPass manager is even
designed to support this as well, but unfortunately, a few early design
decisions in LLVM prevent this from ever happening. Instead, things like ThinLTO
are forced to split programs into separate LLVM modules/context and optimize
those chunks independently.</p><p>The problem is that LLVM has several objects in its IR that are globally uniqued
and also mutable: notably constants like <code>i32 0</code>. In LLVM, these constants are
<code>Value*r</code>&rsquo;s, which allow them to be used as operands to instructions, and that
they also have SSA use lists. Because these things are uniqued, every <code>i32 0</code> in
any function shares a use list. This means that optimizing multiple functions in
parallel won&rsquo;t work (at least without some sort of synchronization on the use
lists, which would be unbearably inefficient).</p><p>MLIR now supports a multithreaded pass manager. We do this through several
design choices:</p><ol><li>MLIR makes use of extensive uniqued immutable data structures (affine
expressions, types, etc are all immutable, uniqued, and immortal).</li><li>Constants are defined in per-function pools, instead of being globally
uniqued.</li><li>Functions themselves are not SSA values either, so they don&rsquo;t have the same
problem as constants.</li><li>FunctionPasses are copied (through their copy ctor) into one instance per
thread, avoiding sharing of local state across threads.</li></ol><p>This allows MLIR function passes to support efficient multithreaded compilation
and code generation.</p><div class=edit-meta>Last updated on 29 Nov 2019<br>Published on 29 Nov 2019<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/design/Rationale.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/design/rationalesimplifiedpolyhedralform/ title="Case for a Simplified Polyhedral Form"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Case for a Simplified Polyhedral Form</a>
<a class="nav nav-next" href=/docs/design/diagnostics/ title="Diagnostics Infrastructure">Next - Diagnostics Infrastructure <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Docs</a><ul class=sub-menu><li><a href=/docs/tutorials/>Tutorials</a><ul class=sub-menu><li><a href=/docs/tutorials/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/tutorials/interfaces/>Interfaces</a></li><li><a href=/docs/tutorials/traits/>Introduction to Operation Traits</a></li><li><a href=/docs/tutorials/quickstartrewrites/>Quickstart on Graph Rewrite</a></li><li><a href=/docs/tutorials/toy/>Toy Tutorial</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Intro</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li><a href=/docs/dialects/>Dialect</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgdoc/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li></ul></li><li class=parent><a href=/docs/design/>Design</a><ul class=sub-menu><li><a href=/docs/design/canonicalization/>Canonicalization</a></li><li><a href=/docs/design/rationalesimplifiedpolyhedralform/>Case for a Simplified Polyhedral Form</a></li><li class=active><a href=/docs/design/rationale/>Design Rationale</a></li><li><a href=/docs/design/diagnostics/>Diagnostics Infrastructure</a></li><li><a href=/docs/design/edsc/>EDSC: Declarative Builders</a></li><li><a href=/docs/design/genericdagrewriter/>Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/design/mlirforgraphalgorithms/>Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/design/quantization/>Quantization</a></li><li><a href=/docs/design/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/design/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/design/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/langref/>Core Specification</a></li><li><a href=/docs/passes/>Passes</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>