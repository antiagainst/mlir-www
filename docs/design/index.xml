<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Design on MLIR: Multi-Level IR Compiler Framework</title><link>https://joker-eph.github.io/www-mlir/docs/design/</link><description>Recent content in Design on MLIR: Multi-Level IR Compiler Framework</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://joker-eph.github.io/www-mlir/docs/design/index.xml" rel="self" type="application/rss+xml"/><item><title>Operation Canonicalization in MLIR</title><link>https://joker-eph.github.io/www-mlir/docs/design/canonicalization/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/canonicalization/</guid><description>Canonicalization is an important part of compiler IR design: it makes it easier to implement reliable compiler transformations and to reason about what is better or worse in the code, and it forces interesting discussions about the goals of a particular level of IR. Dan Gohman wrote an article exploring these issues; it is worth reading if you&amp;rsquo;re not familiar with these concepts.
Most compilers have canonicalization passes, and sometimes they have many different ones (e.</description></item><item><title>Case for a Simplified Polyhedral Form</title><link>https://joker-eph.github.io/www-mlir/docs/design/rationalesimplifiedpolyhedralform/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/rationalesimplifiedpolyhedralform/</guid><description>MLIR embraces polyhedral compiler techniques for their many advantages representing and transforming dense numerical kernels, but it uses a form that differs significantly from other polyhedral frameworks.
Disclaimer / Warning
This document is a very early design proposal (which has since been accepted) that explored the tradeoffs of using this simplified form vs the traditional polyhedral schedule list form. At some point, this document could be dusted off and written as a proper academic paper, but until now, it is better to included it in this crafty form than not to.</description></item><item><title>Design Rationale</title><link>https://joker-eph.github.io/www-mlir/docs/design/rationale/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/rationale/</guid><description>This document is intended to capture some of the alternatives considered and open debates in the design of MLIR, along with the rationale for certain decisions we made. This is not intended to be a &amp;ldquo;finely groomed&amp;rdquo; document - we prefer the ability to dump in interesting tidbits without worrying too much about their consistency or readability.
[TOC]
Abstract MLIR is a compiler intermediate representation with similarities to traditional three-address SSA representations (like LLVM IR or SIL), but which introduces notions from the polyhedral loop optimization works as first class concepts.</description></item><item><title>Diagnostics Infrastructure</title><link>https://joker-eph.github.io/www-mlir/docs/design/diagnostics/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/diagnostics/</guid><description>[TOC]
This document presents an introduction to using and interfacing with MLIR&amp;rsquo;s diagnostics infrastructure.
See MLIR specification for more information about MLIR, the structure of the IR, operations, etc.
Source Locations Source location information is extremely important for any compiler, because it provides a baseline for debuggability and error-reporting. MLIR provides several different location types depending on the situational need.
CallSite Location callsite-location ::= &amp;#39;callsite&amp;#39; &amp;#39;(&amp;#39; location &amp;#39;at&amp;#39; location &amp;#39;)&amp;#39; An instance of this location allows for representing a directed stack of location usages.</description></item><item><title>EDSC: Declarative Builders</title><link>https://joker-eph.github.io/www-mlir/docs/design/edsc/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/edsc/</guid><description>Background: declarative builders API The main purpose of the declarative builders API is to provide an intuitive way of constructing MLIR programmatically. In the majority of cases, the IR we wish to construct exhibits structured control-flow. Declarative builders provide an API to make MLIR construction and manipulation very idiomatic, for the structured control-flow case, in C++.
ScopedContext mlir::edsc::ScopedContext provides an implicit thread-local context, supporting a simple declarative API with globally accessible builders.</description></item><item><title>Generic DAG Rewriter Infrastructure</title><link>https://joker-eph.github.io/www-mlir/docs/design/genericdagrewriter/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/genericdagrewriter/</guid><description>Introduction and Motivation The goal of a compiler IR is to represent code - at various levels of abstraction which pose different sets of tradeoffs in terms of representational capabilities and ease of transformation. However, the ability to represent code is not itself very useful - you also need to be able to implement those transformations.
There are many different sorts of compiler transformations, but this document focuses on a particularly important class of transformation that comes up repeatedly at scale, and is important for the immediate goals of MLIR: that of pattern matching on a set of operations and replacing with another set.</description></item><item><title>Incremental Application to Graph Algorithms in ML Frameworks</title><link>https://joker-eph.github.io/www-mlir/docs/design/mlirforgraphalgorithms/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/mlirforgraphalgorithms/</guid><description>The existing documentation about MLIR focuses on long term vision, how its pieces fit together, and the benefits of modular and composable infrastructure in the vast and distant future. While this viewpoint appeals to some, it causes concern for others who are more concerned about the &amp;ldquo;here and now&amp;rdquo; - why does it make sense to make a &amp;ldquo;revolutionary&amp;rdquo; change when any individual problem can be fixed in place?</description></item><item><title>Quantization</title><link>https://joker-eph.github.io/www-mlir/docs/design/quantization/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/quantization/</guid><description>This document outlines the design of the MLIR quantization system. While the term &amp;ldquo;quantization&amp;rdquo; is highly overloaded, in this case, it refers to a fairly narrow scope of techniques in use to enable conversion of floating-point computations to corresponding and plausible variants expressed in integer math for inference, as has historically been supported by low-bit depth inference engines such as TFLite, various accelerator hardware, and many DSPs.
Much of this is inspired by the approach taken in this paper with many extensions and adaptations folded in.</description></item><item><title>Table-driven Declarative Rewrite Rule (DRR)</title><link>https://joker-eph.github.io/www-mlir/docs/design/declarativerewrites/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/declarativerewrites/</guid><description>In addition to subclassing the mlir::RewritePattern C++ class, MLIR also supports defining rewrite rules in a declarative manner. Similar to Op Definition Specification (ODS), this is achieved via TableGen, which is a language to maintain records of domain-specific information. The rewrite rules are specified concisely in a TableGen record, which will be expanded into an equivalent mlir::RewritePattern subclass at compiler build time.
This manual explains in detail all of the available mechanisms for defining rewrite rules in such a declarative manner.</description></item><item><title>Table-driven Operation Definition Specification (ODS)</title><link>https://joker-eph.github.io/www-mlir/docs/design/opdefinitions/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/opdefinitions/</guid><description>In addition to specializing the mlir::Op C++ template, MLIR also supports defining operations in a table-driven manner. This is achieved via TableGen, which is both a generic language and its tooling to maintain records of domain-specific information. Facts regarding an operation are specified concisely into a TableGen record, which will be expanded into an equivalent mlir::Op C++ template specialization at compiler build time.
This manual explains in detail all the available mechanisms for defining operations in such a table-driven manner.</description></item><item><title>Usage of &#39;Const&#39; in MLIR, for core IR types</title><link>https://joker-eph.github.io/www-mlir/docs/design/usageofconst/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://joker-eph.github.io/www-mlir/docs/design/usageofconst/</guid><description>aka, where&amp;rsquo;d const go?
The MLIR data structures that represent the IR itself (Instruction, Block, etc) form a graph-based data structure, and the compiler analyses and passes frequently walk this graph (e.g. traversing from defs to users). The early design of MLIR adopted the const model of LLVM, which is familiar and well understood (even though the LLVM implementation is flawed in many ways).
The design team since decided to change to a different module, which eschews const entirely for the core IR types: you should never see a const method on Operation, should never see the type const Value *, and you shouldn&amp;rsquo;t feel bad about this.</description></item></channel></rss>