<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on MLIR</title><link>https://mlir.llvm.org/docs/</link><description>Recent content in Docs on MLIR</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 29 Nov 2019 15:26:15 +0000</lastBuildDate><atom:link href="https://mlir.llvm.org/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>Conversion to the LLVM Dialect</title><link>https://mlir.llvm.org/docs/conversiontollvmdialect/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/conversiontollvmdialect/</guid><description>Conversion from the Standard to the LLVM Dialect can be performed by the specialized dialect conversion pass by running
mlir-opt -convert-std-to-llvm &amp;lt;filename.mlir&amp;gt; It performs type and operation conversions for a subset of operations from standard dialect (operations on scalars and vectors, control flow operations) as described in this document. We use the terminology defined by the LLVM IR Dialect description throughout this document.
[TOC]
Type Conversion Scalar Types Scalar types are converted to their LLVM counterparts if they exist.</description></item><item><title>Core Specification</title><link>https://mlir.llvm.org/docs/langref/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/langref/</guid><description>MLIR (Multi-Level IR) is a compiler intermediate representation with similarities to traditional three-address SSA representations (like LLVM IR or SIL), but which introduces notions from polyhedral loop optimization as first-class concepts. This hybrid design is optimized to represent, analyze, and transform high level dataflow graphs as well as target-specific code generated for high performance data parallel systems. Beyond its representational capabilities, its single continuous design provides a framework to lower from dataflow graphs to high-performance target-specific code.</description></item><item><title>Passes</title><link>https://mlir.llvm.org/docs/passes/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/passes/</guid><description>This document describes the available MLIR passes and their contracts.
[TOC]
Affine control lowering (-lower-affine) Convert operations related to affine control into a graph of blocks using operations from the standard dialect.
Loop statements are converted to a subgraph of blocks (initialization, condition checking, subgraph of body blocks) with loop induction variable being passed as the block argument of the condition checking block. Conditional statements are converted to a subgraph of blocks (chain of condition checking with short-circuit logic, subgraphs of &amp;lsquo;then&amp;rsquo; and &amp;lsquo;else&amp;rsquo; body blocks).</description></item><item><title>Quickstart tutorial to defining custom dialect attributes and types</title><link>https://mlir.llvm.org/docs/definingattributesandtypes/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/definingattributesandtypes/</guid><description>This document is a quickstart to defining dialect specific extensions to the attribute and type system. The main part of the tutorial focuses on defining types, but the instructions are nearly identical for defining attributes.
See MLIR specification for more information about MLIR, the structure of the IR, operations, etc.
Types Types in MLIR (like attributes, locations, and many other things) are value-typed. This means that instances of Type should be passed around by-value, as opposed to by-pointer or by-reference.</description></item><item><title>Writing a Pass</title><link>https://mlir.llvm.org/docs/writingapass/</link><pubDate>Fri, 29 Nov 2019 15:26:15 +0000</pubDate><guid>https://mlir.llvm.org/docs/writingapass/</guid><description>[TOC]
Passes represent the basic infrastructure for transformation and optimization. This document provides a quickstart to the pass infrastructure in MLIR and how to use it.
See MLIR specification for more information about MLIR and its core aspects, such as the IR structure and operations.
See MLIR Rewrites for a quick start on graph rewriting in MLIR. If your transformation involves pattern matching operation DAGs, this is a great place to start.</description></item></channel></rss>