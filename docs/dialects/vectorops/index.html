<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Dialect &#39;vector&#39; definition - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=http://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=http://mlir.llvm.org/docs/dialects/vectorops/><link rel=stylesheet href=http://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=http://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=http://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=http://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Dialect &#39;vector&#39; definition</h1><p>[TOC]</p><h2 id=operation-definition>Operation definition</h2><h3 id=vector-broadcast-vector-broadcastop>vector.broadcast (vector::BroadcastOp)</h3><p>broadcast operation</p><h4 id=description>Description:</h4><p>Broadcasts the scalar or k-D vector value in the source operand
to a n-D result vector such that the broadcast makes sense, i.e.,
the source operand is duplicated to match the given rank and sizes
in the result vector. The legality rules are:
* the source operand must have the same element type as the result type
* a k-D vector <s_1 x .. x s_k x type>can be broadcast to
a n-D vector <t_1 x .. x t_n x type>if
* k &lt;= n, and
* the sizes in the trailing dimensions n-k &lt; i &lt;= n with j=i+k-n
match exactly as s_j = t_i or s_j = 1:</p><pre><code>       t_1 x   ..  t_n-k x t_n-k+1 x .. x t_i x .. x t_n
                           s_1     x .. x s_j x .. x s_k
           &lt;duplication&gt;         &lt;potential stretch&gt;
</code></pre><p>The source operand is duplicated over all the missing leading dimensions
and stretched over the trailing dimensions where the source has a non-equal
dimension of 1. These rules imply that any scalar broadcast (k=0) to any
shaped vector with the same element type is always legal.</p><p>Examples:</p><pre><code>  %0 = constant 0.0 : f32
  %1 = vector.broadcast %0 : f32 to vector&lt;16xf32&gt;
  %2 = vector.broadcast %1 : vector&lt;16xf32&gt; to vector&lt;4x16xf32&gt;
</code></pre><h4 id=operands>Operands:</h4><ol><li><code>source</code>: any type</li></ol><h4 id=attributes>Attributes:</h4><h4 id=results>Results:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h3 id=vector-constant-mask-vector-constantmaskop>vector.constant_mask (vector::ConstantMaskOp)</h3><p>creates a constant vector mask</p><h4 id=description-1>Description:</h4><p>Creates and returns a vector mask where elements of the result vector
are set to &lsquo;0&rsquo; or &lsquo;1&rsquo;, based on whether the element indices are contained
within a hyper-rectangular region specified by the &lsquo;mask_dim_sizes&rsquo;
array attribute argument. Each element of the &lsquo;mask_dim_sizes&rsquo; array,
specifies an exclusive upper bound [0, mask-dim-size-element-value)
for a unique dimension in the vector result. The conjunction of the ranges
define a hyper-rectangular region within which elements values are set to 1
(otherwise element values are set to 0).</p><p>Example: create a constant vector mask of size 4x3xi1 with elements in range
0 &lt;= row &lt;= 2 and 0 &lt;= col &lt;= 1 are set to 1 (others to 0).</p><p>%1 = vector.constant_mask [3, 2] : vector<4x3xi1></p><p>print %1
columns
0 1 2
|&mdash;&mdash;&mdash;&mdash;
0 | 1 1 0
rows 1 | 1 1 0
2 | 1 1 0
3 | 0 0 0</p><h4 id=operands-1>Operands:</h4><h4 id=attributes-1>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>mask_dim_sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-1>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of 1-bit integer values</li></ol><h3 id=vector-contract-vector-contractionop>vector.contract (vector::ContractionOp)</h3><p>vector contraction operation</p><h4 id=description-2>Description:</h4><p>Computes the sum of products of vector elements along contracting
dimension pairs from 2 vectors of rank M and N respectively, adds this
intermediate result to the accumulator argument of rank K, and returns a
vector result of rank K (where K = num_lhs_free_dims + num_rhs_free_dims +
num_batch_dims (see dimension type descriptions below)).</p><p>Optional vector mask arguments (produced by CreateMaskOp or ConstantMaskOp)
specify the dynamic dimension sizes of valid data within the lhs/rhs vector
arguments.</p><p>An iterator type attribute list must be specified, where each element of
the list represents an iterator with one of the following types:</p><p>*) &ldquo;reduction&rdquo;: reduction dimensions are present in the lhs and rhs
arguments but not in the output (or optional accumulator
argument). These are the dimensions along which the vector
contraction op computes the sum of products, and
contracting dimension pair dimension sizes must match
between lhs/rhs.
*) &ldquo;parallel&rdquo;: Batch dimensions are iterator type &ldquo;parallel&rdquo;, and
are non-contracting dimensions present in the lhs, rhs and
output. The lhs/rhs co-iterate along the batch dimensions,
which should be expressed in their indexing maps.</p><pre><code>           Free dimensions are iterator type &quot;parallel&quot;, and are
           non-contraction, non-batch dimensions accessed by either the
           lhs or rhs (but not both). The lhs and rhs free dimensions
           are unrelated to each other and do not co-iterate, which
           should be expressed in their indexing maps.
</code></pre><p>An indexing map attribute list must be specified with an entry for lhs, rhs
and acc arguments. An indexing map attribute specifies a mapping from each
iterator in the iterator type list, to each dimension of an N-D vector.</p><p>Examples:</p><p>// 2D vector contraction with one contracting dimension (matmul).
#contraction_accesses = [
(i, j, k) -&gt; (i, k),
(i, j, k) -&gt; (k, j),
(i, j, k) -&gt; (i, j)
]
#contraction_trait = {
indexing_maps = #contraction_accesses,
iterator_types = [parallel, parallel, reduction]
}</p><p>%3 = vector.contract #contraction_trait %0, %1, %2
: vector<4x3xf32>, vector<3x7xf32> into vector<4x7xf32></p><p>// 4D to 3D vector contraction with two contracting dimensions and
// one batch dimension.
#contraction_accesses = [
(b0, f0, f1, c0, c1) -&gt; (c0, b0, c1, f0),
(b0, f0, f1, c0, c1) -&gt; (b0, c1, c0, f1),
(b0, f0, f1, c0, c1) -&gt; (b0, f0, f1)
]
#contraction_trait = {
indexing_maps = #contraction_accesses,
iterator_types = [parallel, parallel, parallel reduction, reduction]
}</p><p>%4 = vector.contract #contraction_trait %0, %1, %2
: vector<7x8x16x15xf32>, vector<8x16x7x5xf32> into vector<8x15x5xf32></p><p>// 4D vector contraction with two contracting dimensions and optional
// vector mask arguments.
%lhs_mask = vector.constant_mask [7, 8, 16, 15] : vector<7x8x16x15xi1>
%rhs_mask = vector.constant_mask [8, 16, 7, 5] : vector<8x16x7x5xi1></p><p>%5 = vector.contract #contraction_trait %0, %1, %2, %lhs_mask, %rhs_mask
: vector<7x8x16x15xf32>, vector<8x16x7x5xf32> into vector<8x15x8x5xf32></p><h4 id=operands-2>Operands:</h4><ol><li><code>lhs</code>: vector of any type values</li><li><code>rhs</code>: vector of any type values</li><li><code>acc</code>: vector of any type values</li><li><code>masks</code>: vector of 1-bit integer values</li></ol><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>indexing_maps</code></td><td align=center><code>ArrayAttr</code></td><td>AffineMap array attribute attribute</td></tr><tr><td align=center><code>iterator_types</code></td><td align=center><code>ArrayAttr</code></td><td>array attribute attribute</td></tr></tbody></table><h4 id=results-2>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of any type values</li></ol><h3 id=vector-create-mask-vector-createmaskop>vector.create_mask (vector::CreateMaskOp)</h3><p>creates a vector mask</p><h4 id=description-3>Description:</h4><p>Creates and returns a vector mask where elements of the result vector
are set to &lsquo;0&rsquo; or &lsquo;1&rsquo;, based on whether the element indices are contained
within a hyper-rectangular region specified by the operands. Specifically,
each operand specifies a range [0, operand-value) for a unique dimension in
the vector result. The conjunction of the operand ranges define a
hyper-rectangular region within which elements values are set to 1
(otherwise element values are set to 0).</p><p>Example: create a vector mask of size 4x3xi1 where elements in range
0 &lt;= row &lt;= 2 and 0 &lt;= col &lt;= 1 are set to 1 (others to 0).</p><p>%1 = vector.create_mask %c3, %c2 : vector<4x3xi1></p><p>print %1
columns
0 1 2
|&mdash;&mdash;&mdash;&mdash;
0 | 1 1 0
rows 1 | 1 1 0
2 | 1 1 0
3 | 0 0 0</p><h4 id=operands-3>Operands:</h4><ol><li><code>operands</code>: index</li></ol><h4 id=attributes-3>Attributes:</h4><h4 id=results-3>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of 1-bit integer values</li></ol><h3 id=vector-extractelement-vector-extractelementop>vector.extractelement (vector::ExtractElementOp)</h3><p>extractelement operation</p><h4 id=description-4>Description:</h4><p>Takes an 1-D vector and a dynamic index position and extracts the
scalar at that position. Note that this instruction resembles
vector.extract, but is restricted to 1-D vectors and relaxed
to dynamic indices. It is meant to be closer to LLVM&rsquo;s version:
<a href=https://llvm.org/docs/LangRef.html#extractelement-instruction>https://llvm.org/docs/LangRef.html#extractelement-instruction</a></p><p>Example:</p><pre><code>  %c = constant 15 : i32
  %1 = vector.extractelement %0[%c : i32]: vector&lt;16xf32&gt;
</code></pre><h4 id=operands-4>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li><li><code>position</code>: index</li></ol><h4 id=attributes-4>Attributes:</h4><h4 id=results-4>Results:</h4><ol><li>&laquo;unnamed&raquo;: any type</li></ol><h3 id=vector-extract-vector-extractop>vector.extract (vector::ExtractOp)</h3><p>extract operation</p><h4 id=description-5>Description:</h4><p>Takes an n-D vector and a k-D position and extracts the (n-k)-D vector at
the proper position. Degenerates to an element type in the 0-D case.</p><p>Examples:</p><pre><code>  %1 = vector.extract %0[3]: vector&lt;4x8x16xf32&gt;
  %2 = vector.extract %0[3, 3, 3]: vector&lt;4x8x16xf32&gt;
</code></pre><h4 id=operands-5>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h4 id=attributes-5>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>position</code></td><td align=center><code>ArrayAttr</code></td><td>32-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-5>Results:</h4><ol><li>&laquo;unnamed&raquo;: any type</li></ol><h3 id=vector-extract-slices-vector-extractslicesop>vector.extract_slices (vector::ExtractSlicesOp)</h3><p>vector extract slices operation</p><h4 id=description-6>Description:</h4><p>Takes an N-d vector and returns a tuple of vector slices of &lsquo;vector&rsquo;,
based on &lsquo;sizes&rsquo; and &lsquo;strides&rsquo; parameters.</p><p>The arguments &lsquo;sizes&rsquo; and &lsquo;strides&rsquo; represent a specification for
generating the unrolling of &lsquo;vector&rsquo; shape, which has all slices of shape
&lsquo;sizes&rsquo; except for slices at dimension boundaries when &lsquo;vector&rsquo; dimension
sizes are not a multiple of &lsquo;sizes&rsquo;.</p><p>Each slice is returned at the tuple element index corresponding to the
linear index of the slice w.r.t the unrolling scheme represented by &lsquo;sizes&rsquo;.
Currently, only unit strides are supported.</p><p>Examples:</p><pre><code>  %0 = vector.transfer_read ...: vector&lt;4x2xf32&gt;

  %1 = vector.extract_slices %0, [2, 2], [1, 1]
    : vector&lt;4x2xf32&gt; into tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x2xf32&gt;&gt;

  // Example with partial slices at dimension boundaries.
  %2 = vector.transfer_read ...: vector&lt;4x3xf32&gt;

  %3 = vector.extract_slices %2, [2, 2], [1, 1]
    : vector&lt;4x3xf32&gt; into tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;,
                                 vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt;
</code></pre><h4 id=operands-6>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h4 id=attributes-6>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>strides</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-6>Results:</h4><ol><li>&laquo;unnamed&raquo;: tuple with any combination of vector of any type values values</li></ol><h3 id=vector-insertelement-vector-insertelementop>vector.insertelement (vector::InsertElementOp)</h3><p>insertelement operation</p><h4 id=description-7>Description:</h4><p>Takes a scalar source, an 1-D destination vector and a dynamic index
position and inserts the source into the destination at the proper
position. Note that this instruction resembles vector.insert, but
is restricted to 1-D vectors and relaxed to dynamic indices. It is
meant to be closer to LLVM&rsquo;s version:
<a href=https://llvm.org/docs/LangRef.html#insertelement-instruction>https://llvm.org/docs/LangRef.html#insertelement-instruction</a></p><p>Example:</p><pre><code>  %c = constant 15 : i32
  %f = constant 0.0f : f32
  %1 = vector.insertelement %f, %0[%c : i32]: vector&lt;16xf32&gt;
</code></pre><h4 id=operands-7>Operands:</h4><ol><li><code>source</code>: any type</li><li><code>dest</code>: vector of any type values</li><li><code>position</code>: index</li></ol><h4 id=attributes-7>Attributes:</h4><h4 id=results-7>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of any type values</li></ol><h3 id=vector-insert-vector-insertop>vector.insert (vector::InsertOp)</h3><p>insert operation</p><h4 id=description-8>Description:</h4><p>Takes an n-D source vector, an (n+k)-D destination vector and a k-D position
and inserts the n-D source into the (n+k)-D destination at the proper
position. Degenerates to a scalar source type when n = 0.</p><p>Examples:</p><pre><code>  %2 = vector.insert %0, %1[3 : i32]:
    vector&lt;8x16xf32&gt; into vector&lt;4x8x16xf32&gt;
  %5 = vector.insert %3, %4[3 : i32, 3 : i32, 3 : i32]:
    f32 into vector&lt;4x8x16xf32&gt;
</code></pre><h4 id=operands-8>Operands:</h4><ol><li><code>source</code>: any type</li><li><code>dest</code>: vector of any type values</li></ol><h4 id=attributes-8>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>position</code></td><td align=center><code>ArrayAttr</code></td><td>32-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-8>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of any type values</li></ol><h3 id=vector-insert-slices-vector-insertslicesop>vector.insert_slices (vector::InsertSlicesOp)</h3><p>vector insert slices operation</p><h4 id=description-9>Description:</h4><p>Takes a tuple of vector slices and inserts them into the vector result
according to the &lsquo;sizes&rsquo; and &lsquo;strides&rsquo; parameters.</p><p>The arguments &lsquo;sizes&rsquo; and &lsquo;strides&rsquo; represent a specification for
generating the unrolling of &lsquo;vector&rsquo; shape, which has all slices of shape
&lsquo;sizes&rsquo; except for slices at dimension boundaries when &lsquo;vector&rsquo; dimension
sizes are not a multiple of &lsquo;sizes&rsquo;.</p><p>Each slice in &lsquo;vectors&rsquo; is at the tuple element index corresponding to the
linear index of the slice w.r.t the unrolling scheme represented by &lsquo;sizes&rsquo;.
Currently, only unit strides are supported.</p><p>Examples:</p><pre><code>  %0 = vector.extract_slices %0, [2, 2], [1, 1]
    : vector&lt;4x2xf32&gt; into tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x2xf32&gt;&gt;

  %1 = vector.insert_slices %0, [2, 2], [1, 1]
    : tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x2xf32&gt;&gt; into vector&lt;4x2xf32&gt;

  // Example with partial slices at dimension boundaries.
  %3 = vector.extract_slices %2, [2, 2], [1, 1]
    : vector&lt;4x3xf32&gt; into tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;,
                                 vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt;

  %4 = vector.insert_slices %3, [2, 2], [1, 1]
    : tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;,
            vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt; into vector&lt;4x3xf32&gt;
</code></pre><h4 id=operands-9>Operands:</h4><ol><li><code>vectors</code>: tuple with any combination of vector of any type values values</li></ol><h4 id=attributes-9>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>strides</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-9>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of any type values</li></ol><h3 id=vector-insert-strided-slice-vector-insertstridedsliceop>vector.insert_strided_slice (vector::InsertStridedSliceOp)</h3><p>strided_slice operation</p><h4 id=description-10>Description:</h4><p>Takes a k-D source vector, an n-D destination vector (n &gt;= k), n-D <code>offsets</code>
integer array attribute, a k-D <code>strides</code> integer array attribute and inserts
the k-D source vector as a strided subvector at the proper offset into the
n-D destination vector.</p><p>At the moment strides must contain only 1s.</p><p>Returns an n-D vector that is a copy of the n-D destination vector in which
the last k-D dimensions contain the k-D source vector elements strided at
the proper location as specified by the offsets.</p><p>Examples:</p><pre><code>  %2 = vector.insert_strided_slice %0, %1
      {offsets : [0, 0, 2], strides : [1, 1]}:
    vector&lt;2x4xf32&gt; into vector&lt;16x4x8xf32&gt;
</code></pre><h4 id=operands-10>Operands:</h4><ol><li><code>source</code>: vector of any type values</li><li><code>dest</code>: vector of any type values</li></ol><h4 id=attributes-10>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>offsets</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>strides</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-10>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of any type values</li></ol><h3 id=vector-outerproduct-vector-outerproductop>vector.outerproduct (vector::OuterProductOp)</h3><p>vector outerproduct with optional fused add</p><h4 id=description-11>Description:</h4><p>Takes 2 1-D vectors and returns the 2-D vector containing the outer product.</p><p>An optional extra 2-D vector argument may be specified in which case the
operation returns the sum of the outer product and the extra vector. When
lowered to the LLVMIR dialect, this form emits <code>llvm.intr.fmuladd</code>, which
can lower to actual <code>fma</code> instructions in LLVM.</p><p>Examples</p><p>%2 = vector.outerproduct %0, %1: vector<4xf32>, vector<8xf32>
return %2: vector<4x8xf32></p><p>%3 = vector.outerproduct %0, %1, %2:
vector<4xf32>, vector<8xf32>, vector<4x8xf32>
return %3: vector<4x8xf32></p><h4 id=operands-11>Operands:</h4><ol><li><code>lhs</code>: vector of any type values</li><li><code>rhs</code>: vector of any type values</li><li><code>acc</code>: vector of any type values</li></ol><h4 id=attributes-11>Attributes:</h4><h4 id=results-11>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of any type values</li></ol><h3 id=vector-shuffle-vector-shuffleop>vector.shuffle (vector::ShuffleOp)</h3><p>shuffle operation</p><h4 id=description-12>Description:</h4><p>The shuffle operation constructs a permutation (or duplication) of elements
from two input vectors, returning a vector with the same element type as
the input and a length that is the same as the shuffle mask. The two input
vectors must have the same element type, rank, and trailing dimension sizes
and shuffles their values in the leading dimension (which may differ in size)
according to the given mask. The legality rules are:
* the two operands must have the same element type as the result
* the two operands and the result must have the same rank and trailing
dimension sizes, viz. given two k-D operands
v1 : <s_1 x s_2 x .. x s_k x type>and
v2 : <t_1 x t_2 x .. x t_k x type>we have s_i = t_i for all 1 &lt; i &lt;= k
* the mask length equals the leading dimension size of the result
* numbering the input vector indices left to right accross the operands, all
mask values must be within range, viz. given two k-D operands v1 and v2
above, all mask values are in the range [0,s_1+t_1)</p><p>Examples:</p><pre><code>%0 = vector.shuffle %a, %b[0:i32, 3:i32]
           : vector&lt;2xf32&gt;, vector&lt;2xf32&gt;       ; yields vector&lt;2xf32&gt;
%1 = vector.shuffle %c, %b[0:i32, 1:i32, 2:i32]
           : vector&lt;2x16xf32&gt;, vector&lt;1x16xf32&gt; ; yields vector&lt;3x16xf32&gt;
%2 = vector.shuffle %a, %b[3:i32, 2:i32, 1:i32 : 0:i32]
           : vector&lt;2xf32&gt;, vector&lt;2xf32&gt;       ; yields vector&lt;4xf32&gt;

</code></pre><h4 id=operands-12>Operands:</h4><ol><li><code>v1</code>: vector of any type values</li><li><code>v2</code>: vector of any type values</li></ol><h4 id=attributes-12>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>mask</code></td><td align=center><code>ArrayAttr</code></td><td>32-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-12>Results:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h3 id=vector-strided-slice-vector-stridedsliceop>vector.strided_slice (vector::StridedSliceOp)</h3><p>strided_slice operation</p><h4 id=description-13>Description:</h4><p>Takes an n-D vector, k-D <code>offsets</code> integer array attribute, a k-D <code>sizes</code>
integer array attribute, a k-D <code>strides</code> integer array attribute and
extracts the n-D subvector at the proper offset.</p><p>At the moment strides must contain only 1s.
// TODO(ntv) support non-1 strides.</p><p>Returns an n-D vector where the first k-D dimensions match the <code>sizes</code>
attribute. The returned subvector contains the elements starting at offset
<code>offsets</code> and ending at <code>offsets + sizes</code>.</p><p>Examples:</p><pre><code>  %1 = vector.strided_slice %0
      {offsets : [0, 2], sizes : [2, 4], strides : [1, 1]}:
    vector&lt;4x8x16xf32&gt; to vector&lt;2x4x16xf32&gt;
</code></pre><p>// TODO(ntv) Evolve to a range form syntax similar to:
%1 = vector.strided_slice %0[0:2:1][2:4:1]
vector<4x8x16xf32> to vector<2x4x16xf32></p><h4 id=operands-13>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h4 id=attributes-13>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>offsets</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>sizes</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr><tr><td align=center><code>strides</code></td><td align=center><code>ArrayAttr</code></td><td>64-bit integer array attribute attribute</td></tr></tbody></table><h4 id=results-13>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of any type values</li></ol><h3 id=vector-transfer-read-vector-transferreadop>vector.transfer_read (vector::TransferReadOp)</h3><p>Reads a supervector from memory into an SSA vector value.</p><h4 id=description-14>Description:</h4><p>The <code>vector.transfer_read</code> op performs a blocking read from a slice within
a scalar <a href=../LangRef.md#memref-type>MemRef</a> supplied as its first operand
into a <a href=../LangRef.md#vector-type>vector</a> of the same elemental type. The
slice is further defined by a full-rank index within the MemRef, supplied as
the operands <code>2 .. 1 + rank(memref)</code>. The permutation_map
<a href=../LangRef.md#attributes>attribute</a> is an
<a href=Affine.md#affine-maps>affine-map</a> which specifies the transposition on the
slice to match the vector shape. The size of the slice is specified by the
size of the vector, given as the return type. An <code>ssa-value</code> of the same
elemental type as the MemRef is provided as the last operand to specify
padding in the case of out-of-bounds accesses. This operation is called
&lsquo;read&rsquo; by opposition to &lsquo;load&rsquo; because the super-vector granularity is
generally not representable with a single hardware register.
A <code>vector.transfer_read</code> is thus a mid-level
abstraction that supports super-vectorization with non-effecting padding for
full-tile-only code.</p><p>More precisely, let&rsquo;s dive deeper into the permutation_map for the following
MLIR:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>vector.transfer_read %A[%expr1, %expr2, %expr3, %expr4]
  { permutation_map : (d0,d1,d2,d3) -&gt; (d2,0,d0) } :
  memref&lt;?x?x?x?xf32&gt;, vector&lt;3x4x5xf32&gt;</code></pre></div><p>This operation always reads a slice starting at <code>%A[%expr1, %expr2, %expr3,
%expr4]</code>. The size of the slice is 3 along d2 and 5 along d0, so the slice
is: <code>%A[%expr1 : %expr1 + 5, %expr2, %expr3:%expr3 + 3, %expr4]</code></p><p>That slice needs to be read into a <code>vector&lt;3x4x5xf32&gt;</code>. Since the
permutation map is not full rank, there must be a broadcast along vector
dimension <code>1</code>.</p><p>A notional lowering of vector.transfer_read could generate code resembling:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>// %expr1, %expr2, %expr3, %expr4 defined before this point
%tmp = alloc() : vector&lt;3x4x5xf32&gt;
%view_in_tmp = &#34;element_type_cast&#34;(%tmp) : memref&lt;1xvector&lt;3x4x5xf32&gt;&gt;
for %i = 0 to 3 {
  affine.for %j = 0 to 4 {
    affine.for %k = 0 to 5 {
      %a = load %A[%expr1 + %k, %expr2, %expr3 + %i, %expr4] :
        memref&lt;?x?x?x?xf32&gt;
      store %tmp[%i, %j, %k] : vector&lt;3x4x5xf32&gt;
}}}
%c0 = constant 0 : index
%vec = load %view_in_tmp[%c0] : vector&lt;3x4x5xf32&gt;</code></pre></div><p>On a GPU one could then map <code>i</code>, <code>j</code>, <code>k</code> to blocks and threads. Notice that
the temporary storage footprint is <code>3 * 5</code> values but <code>3 * 4 * 5</code> values are
actually transferred between <code>%A</code> and <code>%tmp</code>.</p><p>Alternatively, if a notional vector broadcast operation were available, the
lowered code would resemble:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>// %expr1, %expr2, %expr3, %expr4 defined before this point
%tmp = alloc() : vector&lt;3x4x5xf32&gt;
%view_in_tmp = &#34;element_type_cast&#34;(%tmp) : memref&lt;1xvector&lt;3x4x5xf32&gt;&gt;
for %i = 0 to 3 {
  affine.for %k = 0 to 5 {
    %a = load %A[%expr1 + %k, %expr2, %expr3 + %i, %expr4] :
      memref&lt;?x?x?x?xf32&gt;
    store %tmp[%i, 0, %k] : vector&lt;3x4x5xf32&gt;
}}
%c0 = constant 0 : index
%tmpvec = load %view_in_tmp[%c0] : vector&lt;3x4x5xf32&gt;
%vec = broadcast %tmpvec, 1 : vector&lt;3x4x5xf32&gt;</code></pre></div><p>where <code>broadcast</code> broadcasts from element 0 to all others along the
specified dimension. This time, the temporary storage footprint is <code>3 * 5</code>
values which is the same amount of data as the <code>3 * 5</code> values transferred.
An additional <code>1</code> broadcast is required. On a GPU this broadcast could be
implemented using a warp-shuffle if loop <code>j</code> were mapped to <code>threadIdx.x</code>.</p><p>Syntax</p><pre><code>operation ::= ssa-id `=` `vector.transfer_read` ssa-use-list
  `{` attribute-entry `} :` memref-type `,` vector-type
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>// Read the slice `%A[%i0, %i1:%i1+256, %i2:%i2+32]` into vector&lt;32x256xf32&gt;
// and pad with %f0 to handle the boundary case:
%f0 = constant 0.0f : f32
for %i0 = 0 to %0 {
  affine.for %i1 = 0 to %1 step 256 {
    affine.for %i2 = 0 to %2 step 32 {
      %v = vector.transfer_read %A[%i0, %i1, %i2], (%f0)
           {permutation_map: (d0, d1, d2) -&gt; (d2, d1)} :
           memref&lt;?x?x?xf32&gt;, vector&lt;32x256xf32&gt;
}}}

// Read the slice `%A[%i0, %i1]` (i.e. the element `%A[%i0, %i1]`) into
// vector&lt;128xf32&gt;. The underlying implementation will require a 1-D vector
// broadcast:
for %i0 = 0 to %0 {
  affine.for %i1 = 0 to %1 {
    %3 = vector.transfer_read %A[%i0, %i1]
         {permutation_map: (d0, d1) -&gt; (0)} :
         memref&lt;?x?xf32&gt;, vector&lt;128xf32&gt;
  }
}</code></pre></div><h4 id=operands-14>Operands:</h4><ol><li><code>memref</code>: memref of any type values</li><li><code>indices</code>: index</li><li><code>padding</code>: any type</li></ol><h4 id=attributes-14>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>permutation_map</code></td><td align=center><code>AffineMapAttr</code></td><td>AffineMap attribute attribute</td></tr></tbody></table><h4 id=results-14>Results:</h4><ol><li><code>vector</code>: vector of any type values</li></ol><h3 id=vector-transfer-write-vector-transferwriteop>vector.transfer_write (vector::TransferWriteOp)</h3><p>The vector.transfer_write op writes a supervector to memory.</p><h4 id=description-15>Description:</h4><p>The <code>vector.transfer_write</code> performs a blocking write from a
<a href=../LangRef.md#vector-type>vector</a>, supplied as its first operand, into a
slice within a scalar <a href=../LangRef.md#memref-type>MemRef</a> of the same
elemental type, supplied as its second operand. The slice is further defined
by a full-rank index within the MemRef, supplied as the operands
<code>3 .. 2 + rank(memref)</code>.
The permutation_map <a href=../LangRef.md#attributes>attribute</a> is an
<a href=Affine.md#affine-maps>affine-map</a> which specifies the transposition on the
slice to match the vector shape. The size of the slice is specified by the
size of the vector. This operation is called &lsquo;write&rsquo; by opposition to
&lsquo;store&rsquo; because the super-vector granularity is generally not representable
with a single hardware register. A <code>vector.transfer_write</code> is thus a
mid-level abstraction that supports super-vectorization with non-effecting
padding for full-tile-only code. It is the responsibility of
<code>vector.transfer_write</code>&rsquo;s implementation to ensure the memory writes are
valid. Different lowerings may be pertinent depending on the hardware
support.</p><p>Syntax:</p><pre><code>operation ::= `vector.transfer_write` ssa-use-list `{` attribute-entry `} :
  ` vector-type ', ' memref-type '
</code></pre><p>Examples:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>// write vector&lt;16x32x64xf32&gt; into the slice
//   `%A[%i0, %i1:%i1+32, %i2:%i2+64, %i3:%i3+16]`:
for %i0 = 0 to %0 {
  affine.for %i1 = 0 to %1 step 32 {
    affine.for %i2 = 0 to %2 step 64 {
      affine.for %i3 = 0 to %3 step 16 {
        %val = `ssa-value` : vector&lt;16x32x64xf32&gt;
        vector.transfer_write %val, %A[%i0, %i1, %i2, %i3]
          {permutation_map: (d0, d1, d2, d3) -&gt; (d3, d1, d2)} :
          vector&lt;16x32x64xf32&gt;, memref&lt;?x?x?x?xf32&gt;
}}}}</code></pre></div><h4 id=operands-15>Operands:</h4><ol><li><code>vector</code>: vector of any type values</li><li><code>memref</code>: memref of any type values</li><li><code>indices</code>: index</li></ol><h4 id=attributes-15>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>permutation_map</code></td><td align=center><code>AffineMapAttr</code></td><td>AffineMap attribute attribute</td></tr></tbody></table><h4 id=results-15>Results:</h4><h3 id=vector-tuple-get-vector-tuplegetop>vector.tuple_get (vector::TupleGetOp)</h3><p>vector tuple get operation</p><h4 id=description-16>Description:</h4><p>Returns the tuple element of &lsquo;vectors&rsquo; at &lsquo;index&rsquo;.</p><p>Note that this operation is used during the vector op unrolling
transformation and should be removed before lowering to lower-level
dialects.</p><p>Examples:</p><pre><code>  %4 = vector.tuple %0, %1, %2, %3
    : vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;, vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt;

  %5 = vector.tuple_get %4, 1
    : tuple&lt;vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;,
            vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;&gt;
</code></pre><h4 id=operands-16>Operands:</h4><ol><li><code>vectors</code>: tuple with any combination of vector of any type values values</li></ol><h4 id=attributes-16>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>index</code></td><td align=center><code>IntegerAttr</code></td><td>arbitrary integer attribute attribute</td></tr></tbody></table><h4 id=results-16>Results:</h4><ol><li>&laquo;unnamed&raquo;: vector of any type values</li></ol><h3 id=vector-tuple-vector-tupleop>vector.tuple (vector::TupleOp)</h3><p>make tuple of vectors operation</p><h4 id=description-17>Description:</h4><p>Returns a tuple of its operands &lsquo;vectors&rsquo;.</p><p>Note that this operation is used during the vector op unrolling
transformation and should be removed before lowering to lower-level
dialects.</p><p>Examples:</p><pre><code>  %0 = vector.transfer_read ... : vector&lt;2x2xf32&gt;
  %1 = vector.transfer_read ... : vector&lt;2x1xf32&gt;
  %2 = vector.transfer_read ... : vector&lt;2x2xf32&gt;
  %3 = vector.transfer_read ... : vector&lt;2x1xf32&gt;

  %4 = vector.tuple %0, %1, %2, %3
    : vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;, vector&lt;2x2xf32&gt;, vector&lt;2x1xf32&gt;

</code></pre><h4 id=operands-17>Operands:</h4><ol><li><code>vectors</code>: vector of any type values</li></ol><h4 id=attributes-17>Attributes:</h4><h4 id=results-17>Results:</h4><ol><li>&laquo;unnamed&raquo;: tuple with any combination of vector of any type values values</li></ol><h3 id=vector-type-cast-vector-typecastop>vector.type_cast (vector::TypeCastOp)</h3><p>type_cast op converts a scalar memref to a vector memref</p><h4 id=description-18>Description:</h4><p>Performs a conversion from a memref with scalar element to a memref with a
<em>single</em> vector element, copying the shape of the memref to the vector. This
is the minimal viable operation that is required to makeke
super-vectorization operational. It can be seen as a special case of the
<code>view</code> operation but scoped in the super-vectorization context.</p><p>Syntax:</p><pre><code>operation ::= `vector.type_cast` ssa-use : memref-type to memref-type
</code></pre><p>Example:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>%A  = alloc() : memref&lt;5x4x3xf32&gt;
%VA = vector.type_cast %A : memref&lt;5x4x3xf32&gt; to memref&lt;vector&lt;5x4x3xf32&gt;&gt;</code></pre></div><h4 id=operands-18>Operands:</h4><ol><li><code>memref</code>: statically shaped memref of any type values</li></ol><h4 id=attributes-18>Attributes:</h4><h4 id=results-18>Results:</h4><ol><li>&laquo;unnamed&raquo;: memref of any type values</li></ol><div class=edit-meta>Last updated on 1 Jan 1970<br>Published on 1 Jan 1970<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/Dialects/VectorOps.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/dialects/spirvops/ title="Dialect 'spv' definition"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Dialect &#39;spv&#39; definition</a>
<a class="nav nav-next" href=/docs/design/ title=Design>Next - Design <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=http://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Docs</a><ul class=sub-menu><li><a href=/docs/tutorials/>Tutorials</a><ul class=sub-menu><li><a href=/docs/tutorials/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/tutorials/interfaces/>Interfaces</a></li><li><a href=/docs/tutorials/traits/>Introduction to Operation Traits</a></li><li><a href=/docs/tutorials/quickstartrewrites/>Quickstart on Graph Rewrite</a></li><li><a href=/docs/tutorials/toy/>Toy Tutorial</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Intro</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li class=parent><a href=/docs/dialects/>Dialect</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgops/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li class=active><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li></ul></li><li><a href=/docs/design/>Design</a><ul class=sub-menu><li><a href=/docs/design/canonicalization/>Canonicalization</a></li><li><a href=/docs/design/rationalesimplifiedpolyhedralform/>Case for a Simplified Polyhedral Form</a></li><li><a href=/docs/design/rationale/>Design Rationale</a></li><li><a href=/docs/design/diagnostics/>Diagnostics Infrastructure</a></li><li><a href=/docs/design/edsc/>EDSC: Declarative Builders</a></li><li><a href=/docs/design/genericdagrewriter/>Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/design/mlirforgraphalgorithms/>Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/design/quantization/>Quantization</a></li><li><a href=/docs/design/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/design/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/design/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/langref/>Core Specification</a></li><li><a href=/docs/passes/>Passes</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>