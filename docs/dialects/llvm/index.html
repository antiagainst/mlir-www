<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>LLVM IR Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=http://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=http://mlir.llvm.org/docs/dialects/llvm/><link rel=stylesheet href=http://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=http://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=http://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=http://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>LLVM IR Dialect</h1><p>This dialect wraps the LLVM IR types and instructions into MLIR types and
operations. It provides several additional operations that are necessary to
cover for the differences in the IR structure (e.g., MLIR does not have <code>phi</code>
operations and LLVM IR does not have a <code>constant</code> operation).</p><p>In this document, we use &ldquo;LLVM IR&rdquo; to designate the
<a href=https://llvm.org/docs/LangRef.html>intermediate representation of LLVM</a> and
&ldquo;LLVM IR <em>dialect</em>&rdquo; to refer to the MLIR dialect reflecting LLVM instructions
and types.</p><p>[TOC]</p><h2 id=context-and-module-association>Context and Module Association</h2><p>The LLVM IR dialect object <em>contains</em> an LLVM Context and an LLVM Module that it
uses to define, print, parse and manage LLVM IR types. These objects can be
obtained from the dialect object using <code>.getLLVMContext()</code> and
<code>getLLVMModule()</code>. All LLVM IR objects that interact with the LLVM IR dialect
must exist in the dialect&rsquo;s context.</p><h2 id=types>Types</h2><p>The LLVM IR dialect defines a single MLIR type, <code>LLVM::LLVMType</code>, that can wrap
any existing LLVM IR type. Its syntax is as follows</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>type </span><span class=err>::</span><span class=o>=</span> <span class=err>`!</span><span class=k>llvm</span><span class=err>&lt;</span><span class=s2>&#34;` llvm-canonical-type `&#34;</span><span class=err>&gt;</span>
<span class=k>llvm-canonical-type </span><span class=err>::=</span> <span class=err>&lt;</span><span class=k>canonical textual representation defined by LLVM</span><span class=err>&gt;</span></code></pre></div><p>For example, one can use primitive types <code>!llvm.i32</code>, pointer types
<code>!llvm&lt;&quot;i8*&quot;&gt;</code>, vector types <code>!llvm&lt;&quot;&lt;4 x float&gt;&quot;&gt;</code> or structure types
<code>!llvm&lt;&quot;{i32, float}&quot;&gt;</code>. The parsing and printing of the canonical form is
delegated to the LLVM assembly parser and printer.</p><p>LLVM IR dialect types contain an <code>llvm::Type*</code> object that can be obtained by
calling <code>.getUnderlyingType()</code> and used in LLVM API calls directly. These
objects are allocated within the LLVM context associated with the LLVM IR
dialect and may be linked to the properties of the associated LLVM module.</p><p>LLVM IR dialect type can be constructed from any <code>llvm::Type*</code> that is
associated with the LLVM context of the dialect. In this document, we use the
term &ldquo;wrapped LLVM IR type&rdquo; to refer to the LLVM IR dialect type containing a
specific LLVM IR type.</p><h2 id=operations>Operations</h2><p>All operations in the LLVM IR dialect have a custom form in MLIR. The mnemonic
of an operation is that used in LLVM IR prefixed with &ldquo;<code>llvm.</code>&rdquo;.</p><h3 id=llvm-functions>LLVM functions</h3><p>MLIR functions are defined by an operation that is not built into the IR itself.
The LLVM IR dialect provides an <code>llvm.func</code> operation to define functions
compatible with LLVM IR. These functions have wrapped LLVM IR function type but
use MLIR syntax to express it. They are required to have exactly one result
type. LLVM function operation is intended to capture additional properties of
LLVM functions, such as linkage and calling convention, that may be modeled
differently by the built-in MLIR function.</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// The type of @bar is !llvm&lt;&#34;i64 (i64)&#34;&gt;
llvm.func @bar(%arg0: !llvm.i64) -&gt; !llvm.i64 {
  llvm.return %arg0 : !llvm.i64
}

// Type type of @foo is !llvm&lt;&#34;void (i64)&#34;&gt;
// !llvm.void type is omitted
llvm.func @foo(%arg0: !llvm.i64) {
  llvm.return
}</code></pre></div><h3 id=llvm-ir-operations>LLVM IR operations</h3><p>The following operations are currently supported. The semantics of these
operations corresponds to the semantics of the similarly-named LLVM IR
instructions.</p><h4 id=integer-binary-arithmetic-operations>Integer binary arithmetic operations</h4><p>Take two arguments of wrapped LLVM IR integer type, produce one value of the
same type.</p><ul><li><code>add</code></li><li><code>sub</code></li><li><code>mul</code></li><li><code>udiv</code></li><li><code>sdiv</code></li><li><code>urem</code></li><li><code>srem</code></li></ul><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Integer addition.
%0 = llvm.add %a, %b : !llvm.i32

// Unsigned integer division.
%1 = llvm.udiv %a, %b : !llvm.i32</code></pre></div><h4 id=floating-point-binary-arithmetic-operations>Floating point binary arithmetic operations</h4><p>Take two arguments of wrapped LLVM IR floating point type, produce one value of
the same type.</p><ul><li><code>fadd</code></li><li><code>fsub</code></li><li><code>fmul</code></li><li><code>fdiv</code></li><li><code>frem</code></li></ul><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Float addition.
%0 = llvm.fadd %a, %b : !llvm.float

// Float division.
%1 = llvm.fdiv %a, %b : !llvm.float</code></pre></div><h4 id=memory-related-operations>Memory-related operations</h4><ul><li><code>&lt;r&gt; = alloca &lt;size&gt; x &lt;type&gt;</code></li><li><code>&lt;r&gt; = getelementptr &lt;address&gt;[&lt;index&gt; (, &lt;index&gt;)+]</code></li><li><code>&lt;r&gt; = load &lt;address&gt;</code></li><li><code>store &lt;value&gt;, &lt;address&gt;</code></li></ul><p>In these operations, <code>&lt;size&gt;</code> must be a value of wrapped LLVM IR integer type,
<code>&lt;address&gt;</code> must be a value of wrapped LLVM IR pointer type, and <code>&lt;value&gt;</code> must
be a value of wrapped LLVM IR type that corresponds to the pointer type of
<code>&lt;address&gt;</code>.</p><p>The <code>index</code> operands are integer values whose semantics is identical to the
non-pointer arguments of LLVM IR&rsquo;s <code>getelementptr</code>.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Allocate an array of 4 floats on stack
%c4 = llvm.mlir.constant(4) : !llvm.i64
%0 = llvm.alloca %c4 x !llvm.float : (!llvm.i64) -&gt; !llvm&lt;&#34;float*&#34;&gt;

// Get the second element of the array (note 0-based indexing).
%c1 = llvm.mlir.constant(1) : !llvm.i64
%1 = llvm.getelementptr %0[%c1] : (!llvm&lt;&#34;float*&#34;&gt;, !llvm.i64)
                                   -&gt; !llvm&lt;&#34;float*&#34;&gt;

// Store a constant into this element.
%cf = llvm.mlir.constant(42.0 : f32) : !llvm.float
llvm.store %cf, %1 : !llvm&lt;&#34;float*&#34;&gt;

// Load the value from this element.
%3 = llvm.load %1 : !llvm&lt;&#34;float*&#34;&gt;</code></pre></div><h4 id=operations-on-values-of-aggregate-type>Operations on values of aggregate type.</h4><ul><li><code>&lt;value&gt; = extractvalue &lt;struct&gt;[&lt;index&gt; (, &lt;index&gt;)+]</code></li><li><code>&lt;struct&gt; = insertvalue &lt;value&gt;, &lt;struct&gt;[&lt;index&gt; (, &lt;index&gt;)+]</code></li></ul><p>In these operations, <code>&lt;struct&gt;</code> must be a value of wrapped LLVM IR structure
type and <code>&lt;value&gt;</code> must be a value that corresponds to one of the (nested)
structure element types.</p><p>Note the use of integer literals to designate subscripts, which is made possible
by <code>extractvalue</code> and <code>insertvalue</code> must have constant subscripts. Internally,
they are modeled as array attributes.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Get the value third element of the second element of a structure.
%0 = llvm.extractvalue %s[1, 2] : !llvm&lt;&#34;{i32, {i1, i8, i16}&#34;&gt;

// Insert the value to the third element of the second element of a structure.
// Note that this returns a new structure-typed value.
%1 = llvm.insertvalue %0, %s[1, 2] : !llvm&lt;&#34;{i32, {i1, i8, i16}&#34;&gt;</code></pre></div><h4 id=terminator-operations>Terminator operations.</h4><p>Branch operations:</p><ul><li><code>br [&lt;successor&gt;(&lt;operands&gt;)]</code></li><li><code>cond_br &lt;condition&gt; [&lt;true-successor&gt;(&lt;true-operands&gt;),</code>
<code>&lt;false-successor&gt;(&lt;false-operands&gt;)]</code></li></ul><p>In order to comply with MLIR design, branch operations in the LLVM IR dialect
pass arguments to basic blocks. Successors must be valid block MLIR identifiers
and operand lists for each of them must have the same types as the arguments of
the respective blocks. <code>&lt;condition&gt;</code> must be a wrapped LLVM IR <code>i1</code> type.</p><p>Since LLVM IR uses the name of the predecessor basic block to identify the
sources of a PHI node, it is invalid for two entries of the PHI node to indicate
different values coming from the same block. Therefore, <code>cond_br</code> in the LLVM IR
dialect disallows its successors to be the same block <em>if</em> this block has
arguments.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Branch without arguments.
^bb0:
  llvm.br ^bb0

// Branch and pass arguments.
^bb1(%arg: !llvm.i32):
  llvm.br ^bb1(%arg : !llvm.i32)

// Conditionally branch and pass arguments to one of the blocks.
llvm.cond_br %cond, ^bb0, %bb1(%arg : !llvm.i32)

// It&#39;s okay to use the same block without arguments, but probably useless.
llvm.cond_br %cond, ^bb0, ^bb0

// ERROR: Passing different arguments to the same block in a conditional branch.
llvm.cond_br %cond, ^bb1(%0 : !llvm.i32), ^bb1(%1 : !llvm.i32)</code></pre></div><p>Call operations:</p><ul><li><code>&lt;r&gt; = call(&lt;operands&gt;)</code></li><li><code>call(&lt;operands&gt;)</code></li></ul><p>In LLVM IR, functions may return either 0 or 1 value. LLVM IR dialect implements
this behavior by providing a variadic <code>call</code> operation for 0- and 1-result
functions. Even though MLIR supports multi-result functions, LLVM IR dialect
disallows them.</p><p>The <code>call</code> instruction supports both direct and indirect calls. Direct calls
start with a function name (<code>@</code>-prefixed) and indirect calls start with an SSA
value (<code>%</code>-prefixed). The direct callee, if present, is stored as a function
attribute <code>callee</code>. The trailing type of the instruction is always the MLIR
function type, which may be different from the indirect callee that has the
wrapped LLVM IR function type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Direct call without arguments and with one result.
%0 = llvm.call @foo() : () -&gt; (!llvm.float)

// Direct call with arguments and without a result.
llvm.call @bar(%0) : (!llvm.float) -&gt; ()

// Indirect call with an argument and without a result.
llvm.call %1(%0) : (!llvm.float) -&gt; ()</code></pre></div><h4 id=miscellaneous-operations>Miscellaneous operations.</h4><p>Integer comparisons: <code>icmp &quot;predicate&quot; &lt;lhs&gt;, &lt;rhs&gt;</code>. The following predicate
values are supported:</p><ul><li><code>eq</code> - equality comparison;</li><li><code>ne</code> - inequality comparison;</li><li><code>slt</code> - signed less-than comparison</li><li><code>sle</code> - signed less-than-or-equal comparison</li><li><code>sgt</code> - signed greater-than comparison</li><li><code>sge</code> - signed greater-than-or-equal comparison</li><li><code>ult</code> - unsigned less-than comparison</li><li><code>ule</code> - unsigned less-than-or-equal comparison</li><li><code>ugt</code> - unsigned greater-than comparison</li><li><code>uge</code> - unsigned greater-than-or-equal comparison</li></ul><p>Bitwise reinterpretation: <code>bitcast &lt;value&gt;</code>.</p><p>Selection: <code>select &lt;condition&gt;, &lt;lhs&gt;, &lt;rhs&gt;</code>.</p><h3 id=auxiliary-mlir-operations>Auxiliary MLIR operations</h3><p>These operations do not have LLVM IR counterparts but are necessary to map LLVM
IR into MLIR. They should be prefixed with <code>llvm.mlir</code>.</p><h4 id=llvm-mlir-addressof><code>llvm.mlir.addressof</code></h4><p>Creates an SSA value containing a pointer to a global variable or constant
defined by <code>llvm.mlir.global</code>. The global value can be defined after its first
referenced. If the global value is a constant, storing into it is not allowed.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">func @foo() {
  // Get the address of a global.
  %0 = llvm.mlir.addressof @const : !llvm&lt;&#34;i32*&#34;&gt;

  // Use it as a regular pointer.
  %1 = llvm.load %0 : !llvm&lt;&#34;i32*&#34;&gt;
}

// Define the global.
llvm.mlir.global @const(42 : i32) : !llvm.i32</code></pre></div><h4 id=llvm-mlir-constant><code>llvm.mlir.constant</code></h4><p>Unlike LLVM IR, MLIR does not have first-class constant values. Therefore, all
constants must be created as SSA values before being used in other operations.
<code>llvm.mlir.constant</code> creates such values for scalars and vectors. It has a
mandatory <code>value</code> attribute, which may be an integer, floating point attribute;
dense or sparse attribute containing integers or floats. The type of the
attribute is one the corresponding MLIR standard types. It may be omitted for
<code>i64</code> and <code>f64</code> types that are implied. The operation produces a new SSA value
of the specified LLVM IR dialect type. The type of that value <em>must</em> correspond
to the attribute type converted to LLVM IR.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Integer constant, internal i32 is mandatory
%0 = llvm.mlir.constant(42 : i32) : !llvm.i32

// It&#39;s okay to omit i64.
%1 = llvm.mlir.constant(42) : !llvm.i64

// Floating point constant.
%2 = llvm.mlir.constant(42.0 : f32) : !llvm.float

// Splat dense vector constant.
%3 = llvm.mlir.constant(dense&lt;1.0&gt; : vector&lt;4xf32&gt;) : !llvm&lt;&#34;&lt;4 x float&gt;&#34;&gt;</code></pre></div><h4 id=llvm-mlir-global><code>llvm.mlir.global</code></h4><p>Since MLIR allows for arbitrary operations to be present at the top level,
global variables are defined using the <code>llvm.mlir.global</code> operation. Both global
constants and variables can be defined, and the value may also be initialized in
both cases.</p><p>There are two forms of initialization syntax. Simple constants that can be
represented as MLIR attributes can be given in-line:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">llvm.mlir.global @variable(32.0 : f32) : !llvm.float</code></pre></div><p>This initialization and type syntax is similar to <code>llvm.mlir.constant</code> and may
use two types: one for MLIR attribute and another for the LLVM value. These
types must be compatible.</p><p>More complex constants that cannot be represented as MLIR attributes can be
given in an initializer region:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// This global is initialized with the equivalent of:
//   i32* getelementptr (i32* @g2, i32 2)
llvm.mlir.global constant @int_gep() : !llvm&lt;&#34;i32*&#34;&gt; {
  %0 = llvm.mlir.addressof @g2 : !llvm&lt;&#34;i32*&#34;&gt;
  %1 = llvm.mlir.constant(2 : i32) : !llvm.i32
  %2 = llvm.getelementptr %0[%1] : (!llvm&lt;&#34;i32*&#34;&gt;, !llvm.i32) -&gt; !llvm&lt;&#34;i32*&#34;&gt;
  // The initializer region must end with `llvm.return`.
  llvm.return %2 : !llvm&lt;&#34;i32*&#34;&gt;
}</code></pre></div><p>Only one of the initializer attribute or initializer region may be provided.</p><p><code>llvm.mlir.global</code> must appear at top-level of the enclosing module. It uses an
@-identifier for its value, which will be uniqued by the module with respect to
other @-identifiers in it.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Global values use @-identifiers.
llvm.mlir.global constant @cst(42 : i32) : !llvm.i32

// Non-constant values must also be initialized.
llvm.mlir.global @variable(32.0 : f32) : !llvm.float

// Strings are expected to be of wrapped LLVM i8 array type and do not
// automatically include the trailing zero.
llvm.mlir.global @string(&#34;abc&#34;) : !llvm&lt;&#34;[3 x i8]&#34;&gt;

// For strings globals, the trailing type may be omitted.
llvm.mlir.global constant @no_trailing_type(&#34;foo bar&#34;)

// A complex initializer is constructed with an initializer region.
llvm.mlir.global constant @int_gep() : !llvm&lt;&#34;i32*&#34;&gt; {
  %0 = llvm.mlir.addressof @g2 : !llvm&lt;&#34;i32*&#34;&gt;
  %1 = llvm.mlir.constant(2 : i32) : !llvm.i32
  %2 = llvm.getelementptr %0[%1] : (!llvm&lt;&#34;i32*&#34;&gt;, !llvm.i32) -&gt; !llvm&lt;&#34;i32*&#34;&gt;
  llvm.return %2 : !llvm&lt;&#34;i32*&#34;&gt;
}</code></pre></div><h4 id=llvm-mlir-null><code>llvm.mlir.null</code></h4><p>Unlike LLVM IR, MLIR does not have first-class null pointers. They must be
explicitly created as SSA values using <code>llvm.mlir.null</code>. This operation has
operands or attributes, and returns a null value of a wrapped LLVM IR pointer
type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Null pointer to i8 value.
%0 = llvm.mlir.null : !llvm&lt;&#34;i8*&#34;&gt;

// Null pointer to a function with signature void() value.
%1 = llvm.mlir.null : !llvm&lt;&#34;void()*&#34;&gt;</code></pre></div><h4 id=llvm-mlir-undef><code>llvm.mlir.undef</code></h4><p>Unlike LLVM IR, MLIR does not have first-class undefined values. Such values
must be created as SSA values using <code>llvm.mlir.undef</code>. This operation has no
operands or attributes. It creates an undefined value of the specified LLVM IR
dialect type wrapping an LLVM IR structure type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Create a structure with a 32-bit integer followed by a float.
%0 = llvm.mlir.undef : !llvm&lt;&#34;{i32, float}&#34;&gt;</code></pre></div><div class=edit-meta>Last updated on 29 Nov 2019<br>Published on 29 Nov 2019<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/Dialects/LLVM.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/dialects/gpu/ title="GPU Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - GPU Dialect</a>
<a class="nav nav-next" href=/docs/dialects/spir-v/ title="SPIR-V Dialect">Next - SPIR-V Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=http://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Docs</a><ul class=sub-menu><li><a href=/docs/tutorials/>Tutorials</a><ul class=sub-menu><li><a href=/docs/tutorials/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/tutorials/interfaces/>Interfaces</a></li><li><a href=/docs/tutorials/traits/>Introduction to Operation Traits</a></li><li><a href=/docs/tutorials/quickstartrewrites/>Quickstart on Graph Rewrite</a></li><li><a href=/docs/tutorials/toy/>Toy Tutorial</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Intro</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li class=parent><a href=/docs/dialects/>Dialect</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li class=active><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgops/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li></ul></li><li><a href=/docs/design/>Design</a><ul class=sub-menu><li><a href=/docs/design/canonicalization/>Canonicalization</a></li><li><a href=/docs/design/rationalesimplifiedpolyhedralform/>Case for a Simplified Polyhedral Form</a></li><li><a href=/docs/design/rationale/>Design Rationale</a></li><li><a href=/docs/design/diagnostics/>Diagnostics Infrastructure</a></li><li><a href=/docs/design/edsc/>EDSC: Declarative Builders</a></li><li><a href=/docs/design/genericdagrewriter/>Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/design/mlirforgraphalgorithms/>Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/design/quantization/>Quantization</a></li><li><a href=/docs/design/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/design/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/design/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/langref/>Core Specification</a></li><li><a href=/docs/passes/>Passes</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>