<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>SPIR-V Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/dialects/spir-v/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>SPIR-V Dialect</h1><p>This document defines the SPIR-V dialect in MLIR.</p><p><a href=https://www.khronos.org/registry/spir-v/>SPIR-V</a> is the Khronos Group’s binary intermediate language for
representing graphics shaders and compute kernels. It is adopted by multiple
Khronos Group’s APIs, including Vulkan and OpenCL.</p><h2 id=design-principles>Design Principles</h2><p>SPIR-V defines a stable binary format for hardware driver consumption.
Regularity is one of the design goals of SPIR-V. All concepts are represented
as SPIR-V instructions, including declaring extensions and capabilities,
defining types and constants, defining functions, attaching additional
properties to computation results, etc. This way favors driver consumption
but not necessarily compiler transformations.</p><p>The purpose of the SPIR-V dialect is to serve as the &ldquo;proxy&rdquo; of the binary
format and to facilitate transformations. Therefore, it should</p><ul><li>Stay as the same semantic level and try to be a mechanical 1:1 mapping;</li><li>But deviate representationally if possible with MLIR mechanisms.</li><li>Be straightforward to serialize into and deserialize from the SPIR-V binary
format.</li></ul><h2 id=conventions>Conventions</h2><p>The SPIR-V dialect has the following conventions:</p><ul><li>The prefix for all SPIR-V types and operations are <code>spv.</code>.</li><li>Ops that directly mirror instructions in the binary format have <code>CamelCase</code>
names that are the same as the instruction opnames (without the <code>Op</code>
prefix). For example, <code>spv.FMul</code> is a direct mirror of <code>OpFMul</code>. They will
be serialized into and deserialized from one instruction.</li><li>Ops with <code>snake_case</code> names are those that have different representation
from corresponding instructions (or concepts) in the binary format. These
ops are mostly for defining the SPIR-V structure. For example, <code>spv.module</code>
and <code>spv.constant</code>. They may correspond to zero or more instructions during
(de)serialization.</li><li>Ops with <code>_snake_case</code> names are those that have no corresponding
instructions (or concepts) in the binary format. They are introduced to
satisfy MLIR structural requirements. For example, <code>spv._module_end</code> and
<code>spv._merge</code>. They maps to no instructions during (de)serialization.</li></ul><h2 id=module>Module</h2><p>A SPIR-V module is defined via the <code>spv.module</code> op, which has one region that
contains one block. Model-level instructions, including function definitions,
are all placed inside the block. Functions are defined using the builtin <code>func</code>
op.</p><p>Compared to the binary format, we adjust how certain module-level SPIR-V
instructions are represented in the SPIR-V dialect. Notably,</p><ul><li>Requirements for capabilities, extensions, extended instruction sets,
addressing model, and memory model is conveyed using <code>spv.module</code>
attributes. This is considered better because these information are for the
execution environment. It&rsquo;s easier to probe them if on the module op
itself.</li><li>Annotations/decoration instructions are &ldquo;folded&rdquo; into the instructions they
decorate and represented as attributes on those ops. This eliminates
potential forward references of SSA values, improves IR readability, and
makes querying the annotations more direct.</li><li>Types are represented using MLIR standard types and SPIR-V dialect specific
types. There are no type declaration ops in the SPIR-V dialect.</li><li>Various normal constant instructions are represented by the same
<code>spv.constant</code> op. Those instructions are just for constants of different
types; using one op to represent them reduces IR verbosity and makes
transformations less tedious.</li><li>Normal constants are not placed in <code>spv.module</code>&rsquo;s region; they are localized
into functions. This is to make functions in the SPIR-V dialect to be
isolated and explicit capturing.</li><li>Global variables are defined with the <code>spv.globalVariable</code> op. They do not
generate SSA values. Instead they have symbols and should be referenced via
symbols. To use a global variables in a function block, <code>spv._address_of</code> is
needed to turn the symbol into a SSA value.</li><li>Specialization constants are defined with the <code>spv.specConstant</code> op. Similar
to global variables, they do not generate SSA values and have symbols for
reference, too. <code>spv._reference_of</code> is needed to turn the symbol into a SSA
value for use in a function block.</li></ul><h2 id=types>Types</h2><p>The SPIR-V dialect reuses standard integer, float, and vector types and defines
the following dialect-specific types:</p><pre><code>spirv-type ::= array-type
             | pointer-type
             | runtime-array-type
</code></pre><h3 id=array-type>Array type</h3><p>This corresponds to SPIR-V <a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeArray>array type</a>. Its syntax is</p><pre><code>element-type ::= integer-type
               | floating-point-type
               | vector-type
               | spirv-type

array-type ::= `!spv.array&lt;` integer-literal `x` element-type `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>!spv.array&lt;4 x i32&gt;
!spv.array&lt;16 x vector&lt;4 x f32&gt;&gt;</code></pre></div><h3 id=image-type>Image type</h3><p>This corresponds to SPIR-V <a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeImage>image type</a>. Its syntax is</p><pre><code>dim ::= `1D` | `2D` | `3D` | `Cube` | &lt;and other SPIR-V Dim specifiers...&gt;

depth-info ::= `NoDepth` | `IsDepth` | `DepthUnknown`

arrayed-info ::= `NonArrayed` | `Arrayed`

sampling-info ::= `SingleSampled` | `MultiSampled`

sampler-use-info ::= `SamplerUnknown` | `NeedSampler` | `NoSampler`

format ::= `Unknown` | `Rgba32f` | &lt;and other SPIR-V Image Formats...&gt;

image-type ::= `!spv.image&lt;` element-type `,` dim `,` depth-info `,`
                           arrayed-info `,` sampling-info `,`
                           sampler-use-info `,` format `&gt;`
</code></pre><p>For example,</p><pre><code>!spv.image&lt;f32, 1D, NoDepth, NonArrayed, SingleSampled, SamplerUnknown, Unknown&gt;
!spv.image&lt;f32, Cube, IsDepth, Arrayed, MultiSampled, NeedSampler, Rgba32f&gt;
</code></pre><h3 id=pointer-type>Pointer type</h3><p>This corresponds to SPIR-V <a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypePointer>pointer type</a>. Its syntax is</p><pre><code>storage-class ::= `UniformConstant`
                | `Uniform`
                | `Workgroup`
                | &lt;and other storage classes...&gt;

pointer-type ::= `!spv.ptr&lt;` element-type `,` storage-class `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>!spv.ptr&lt;i32, Function&gt;
!spv.ptr&lt;vector&lt;4 x f32&gt;, Uniform&gt;</code></pre></div><h3 id=runtime-array-type>Runtime array type</h3><p>This corresponds to SPIR-V <a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#OpTypeRuntimeArray>runtime array type</a>. Its syntax is</p><pre><code>runtime-array-type ::= `!spv.rtarray&lt;` element-type `&gt;`
</code></pre><p>For example,</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>!spv.rtarray&lt;i32&gt;
!spv.rtarray&lt;vector&lt;4 x f32&gt;&gt;</code></pre></div><h3 id=struct-type>Struct type</h3><p>This corresponds to SPIR-V <a href=https://www.khronos.org/registry/spir-v/specs/unified1/SPIRV.html#Structure>struct type</a>. Its syntax is</p><pre><code>struct-member-decoration ::= integer-literal? spirv-decoration*
struct-type ::= `!spv.struct&lt;` spirv-type (`[` struct-member-decoration `]`)?
                     (`, ` spirv-type (`[` struct-member-decoration `]`)?
</code></pre><p>For Example,</p><pre><code>!spv.struct&lt;f32&gt;
!spv.struct&lt;f32 [0]&gt;
!spv.struct&lt;f32, !spv.image&lt;f32, 1D, NoDepth, NonArrayed, SingleSampled, SamplerUnknown, Unknown&gt;&gt;
!spv.struct&lt;f32 [0], i32 [4]&gt;
</code></pre><h2 id=function>Function</h2><p>A SPIR-V function is defined using the builtin <code>func</code> op. <code>spv.module</code> verifies
that the functions inside it comply with SPIR-V requirements: at most one
result, no nested functions, and so on.</p><h2 id=operations>Operations</h2><p>Operation documentation is written in each op&rsquo;s Op Definition Spec using
TableGen. A markdown version of the doc can be generated using <code>mlir-tblgen
-gen-doc</code>.</p><h2 id=control-flow>Control Flow</h2><p>SPIR-V binary format uses merge instructions (<code>OpSelectionMerge</code> and
<code>OpLoopMerge</code>) to declare structured control flow. They explicitly declare a
header block before the control flow diverges and a merge block where control
flow subsequently converges. These blocks delimit constructs that must nest, and
can only be entered and exited in structured ways.</p><p>In the SPIR-V dialect, we use regions to mark the boundary of a structured
control flow construct. With this approach, it&rsquo;s easier to discover all blocks
belonging to a structured control flow construct. It is also more idiomatic to
MLIR system.</p><p>We introduce a <code>spv.selection</code> and <code>spv.loop</code> op for structured selections and
loops, respectively. The merge targets are the next ops following them. Inside
their regions, a special terminator, <code>spv._merge</code> is introduced for branching to
the merge target.</p><h3 id=selection>Selection</h3><p><code>spv.selection</code> defines a selection construct. It contains one region. The
region should contain at least two blocks: one selection header block and one
merge block.</p><ul><li>The selection header block should be the first block. It should contain the
<code>spv.BranchConditional</code> or <code>spv.Switch</code> op.</li><li><p>The merge block should be the last block. The merge block should only
contain a <code>spv._merge</code> op. Any block can branch to the merge block for early
exit.</p><pre><code>           +--------------+
           | header block |                 (may have multiple outgoing branches)
           +--------------+
                / | \
                 ...


+---------+   +---------+   +---------+
| case #0 |   | case #1 |   | case #2 |  ... (may have branches between each other)
+---------+   +---------+   +---------+


                 ...
                \ | /
                  v
           +-------------+
           | merge block |                  (may have multiple incoming branches)
           +-------------+
</code></pre></li></ul><p>For example, for the given function</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>loop</span><span class=p>(</span><span class=kt>bool</span> <span class=n>cond</span><span class=p>)</span> <span class=p>{</span>
  <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
  <span class=k>if</span> <span class=p>(</span><span class=n>cond</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>x</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>x</span> <span class=o>=</span> <span class=mi>2</span><span class=p>;</span>
  <span class=p>}</span>
  <span class=c1>// ...
</span><span class=c1></span><span class=p>}</span>
</code></pre></div><p>It will be represented as</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>func @selection(%cond: i1) -&gt; () {
  %zero = spv.constant 0: i32
  %one = spv.constant 1: i32
  %two = spv.constant 2: i32
  %x = spv.Variable init(%zero) : !spv.ptr&lt;i32, Function&gt;

  spv.selection {
    spv.BranchConditional %cond, ^then, ^else

  ^then:
    spv.Store &#34;Function&#34; %x, %one : i32
    spv.Branch ^merge

  ^else:
    spv.Store &#34;Function&#34; %x, %two : i32
    spv.Branch ^merge

  ^merge:
    spv._merge
  }

  // ...
}</code></pre></div><h3 id=loop>Loop</h3><p><code>spv.loop</code> defines a loop construct. It contains one region. The region should
contain at least four blocks: one entry block, one loop header block, one loop
continue block, one merge block.</p><ul><li>The entry block should be the first block and it should jump to the loop
header block, which is the second block.</li><li>The merge block should be the last block. The merge block should only
contain a <code>spv._merge</code> op. Any block except the entry block can branch to
the merge block for early exit.</li><li>The continue block should be the second to last block and it should have a
branch to the loop header block.</li><li><p>The loop continue block should be the only block, except the entry block,
branching to the loop header block.</p><pre><code>+-------------+
| entry block |           (one outgoing branch)
+-------------+
       |
       v
+-------------+           (two incoming branches)
| loop header | &lt;-----+   (may have one or two outgoing branches)
+-------------+       |
                      |
      ...             |
     \ | /            |
       v              |
+---------------+      |   (may have multiple incoming branches)
| loop continue | -----+   (may have one or two outgoing branches)
+---------------+

      ...
     \ | /
       v
+-------------+           (may have multiple incoming branches)
| merge block |
+-------------+
</code></pre></li></ul><p>The reason to have another entry block instead of directly using the loop header
block as the entry block is to satisfy region&rsquo;s requirement: entry block of
region may not have predecessors. We have a merge block so that branch ops can
reference it as successors. The loop continue block here corresponds to
&ldquo;continue construct&rdquo; using SPIR-V spec&rsquo;s term; it does not mean the &ldquo;continue
block&rdquo; as defined in the SPIR-V spec, which is &ldquo;a block containing a branch to
an OpLoopMerge instruction’s Continue Target.&rdquo;</p><p>For example, for the given function</p><div class=highlight><pre class=chroma><code class=language-c++ data-lang=c++><span class=kt>void</span> <span class=nf>loop</span><span class=p>(</span><span class=kt>int</span> <span class=n>count</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>count</span><span class=p>;</span> <span class=o>++</span><span class=n>i</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// ...
</span><span class=c1></span>  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>It will be represented as</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>func @loop(%count : i32) -&gt; () {
  %zero = spv.constant 0: i32
  %one = spv.constant 1: i32
  %var = spv.Variable init(%zero) : !spv.ptr&lt;i32, Function&gt;

  spv.loop {
    spv.Branch ^header

  ^header:
    %val0 = spv.Load &#34;Function&#34; %var : i32
    %cmp = spv.SLessThan %val0, %count : i32
    spv.BranchConditional %cmp, ^body, ^merge

  ^body:
    // ...
    spv.Branch ^continue

  ^continue:
    %val1 = spv.Load &#34;Function&#34; %var : i32
    %add = spv.IAdd %val1, %one : i32
    spv.Store &#34;Function&#34; %var, %add : i32
    spv.Branch ^header

  ^merge:
    spv._merge
  }
  return
}</code></pre></div><h3 id=block-argument-for-phi>Block argument for Phi</h3><p>There are no direct Phi operations in the SPIR-V dialect; SPIR-V <code>OpPhi</code>
instructions are modelled as block arguments in the SPIR-V dialect. (See the
<a href=https://github.com/tensorflow/mlir/blob/master/g3doc/Rationale.md#block-arguments-vs-phi-nodes>Rationale</a> doc for &ldquo;Block Arguments vs Phi nodes&rdquo;.) Each block
argument corresponds to one <code>OpPhi</code> instruction in the SPIR-V binary format. For
example, for the following SPIR-V function <code>foo</code>:</p><div class=highlight><pre class=chroma><code class=language-spirv data-lang=spirv>  %foo = OpFunction %void None ...
%entry = OpLabel
  %var = OpVariable %_ptr_Function_int Function
         OpSelectionMerge %merge None
         OpBranchConditional %true %true %false
 %true = OpLabel
         OpBranch %phi
%false = OpLabel
         OpBranch %phi
  %phi = OpLabel
  %val = OpPhi %int %int_1 %false %int_0 %true
         OpStore %var %val
         OpReturn
%merge = OpLabel
         OpReturn
         OpFunctionEnd</code></pre></div><p>It will be represented as:</p><div class=highlight><pre class=chroma><code class=language-mlir data-lang=mlir>func @foo() -&gt; () {
  %var = spv.Variable : !spv.ptr&lt;i32, Function&gt;

  spv.selection {
    %true = spv.constant true
    spv.BranchConditional %true, ^true, ^false

  ^true:
    %zero = spv.constant 0 : i32
    spv.Branch ^phi(%zero: i32)

  ^false:
    %one = spv.constant 1 : i32
    spv.Branch ^phi(%one: i32)

  ^phi(%arg: i32):
    spv.Store &#34;Function&#34; %var, %arg : i32
    spv.Return

  ^merge:
    spv._merge
  }
  spv.Return
}</code></pre></div><h2 id=serialization-and-deserialization>Serialization and deserialization</h2><p>The serialization library provides two entry points, <code>mlir::spirv::serialize()</code>
and <code>mlir::spirv::deserialize()</code>, for converting a MLIR SPIR-V module to binary
format and back.</p><p>The purpose of this library is to enable importing SPIR-V binary modules to run
transformations on them and exporting SPIR-V modules to be consumed by execution
environments. The focus is transformations, which inevitably means changes to
the binary module; so it is not designed to be a general tool for investigating
the SPIR-V binary module and does not guarantee roundtrip equivalence (at least
for now). For the latter, please use the assembler/disassembler in the
<a href=https://github.com/KhronosGroup/SPIRV-Tools>SPIRV-Tools</a> project.</p><p>A few transformations are performed in the process of serialization because of
the representational differences between SPIR-V dialect and binary format:</p><ul><li>Attributes on <code>spv.module</code> are emitted as their corresponding SPIR-V
instructions.</li><li><code>spv.constant</code>s are unified and placed in the SPIR-V binary module section
for types, constants, and global variables.</li><li><code>spv.selection</code>s and <code>spv.loop</code>s are emitted as basic blocks with <code>Op*Merge</code>
instructions in the header block as required by the binary format.</li></ul><p>Similarly, a few transformations are performed during deserialization:</p><ul><li>Instructions for execution environment requirements will be placed as
attributes on <code>spv.module</code>.</li><li><code>OpConstant*</code> instructions are materialized as <code>spv.constant</code> at each use
site.</li><li><code>OpPhi</code> instructions are converted to block arguments.</li><li>Structured control flow are placed inside <code>spv.selection</code> and <code>spv.loop</code>.</li></ul><div class=edit-meta>Last updated on 1 Jan 1970<br>Published on 1 Jan 1970<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/Dialects/SPIR-V.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/dialects/llvm/ title="LLVM IR Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - LLVM IR Dialect</a>
<a class="nav nav-next" href=/docs/dialects/standard/ title="Standard Dialect">Next - Standard Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/contributing/>How to Contribute</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>.</a><ul class=sub-menu><li class=parent><a href=/docs/dialects/>Dialects</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgdoc/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/linalg/>Linalg Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li class=active><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li></ul></li><li><a href=/docs/includes/>includes</a><ul class=sub-menu><li><a href=/docs/includes/img/>includes/img</a></li></ul></li><li><a href=/docs/tutorials/>Tutorials</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/>Tutorials/Toy</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li><a href=/docs/edsc/>Background: declarative builders API</a></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/developerguide/>Developer Guide</a></li><li><a href=/docs/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/diagnostics/>Introduction and Usage Guide to MLIR&#39;s Diagnostics Infrastructure</a></li><li><a href=/docs/interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/genericdagrewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/glossary/>MLIR Glossary</a></li><li><a href=/docs/passes/>MLIR Passes</a></li><li><a href=/docs/quantization/>MLIR Quantization</a></li><li><a href=/docs/rationale/>MLIR Rationale</a></li><li><a href=/docs/langref/>MLIR Specification</a></li><li><a href=/docs/mlirforgraphalgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/rationalesimplifiedpolyhedralform/>MLIR: The case for a &lt;em&gt;simplified&lt;/em&gt; polyhedral form</a></li><li><a href=/docs/canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/quickstartrewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/testingguide/>Testing Guide</a></li><li><a href=/docs/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>