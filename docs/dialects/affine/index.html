<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Affine - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=http://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=http://mlir.llvm.org/docs/dialects/affine/><link rel=stylesheet href=http://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=http://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=http://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=http://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Affine</h1><p>This dialect provides a powerful abstraction for affine operations and analyses.</p><p>[TOC]</p><h2 id=polyhedral-structures>Polyhedral Structures</h2><p>MLIR uses techniques from polyhedral compilation to make dependence analysis and
loop transformations efficient and reliable. This section introduces some of the
core concepts that are used throughout the document.</p><h3 id=dimensions-and-symbols>Dimensions and Symbols</h3><p>Dimensions and symbols are the two kinds of identifiers that can appear in the
polyhedral structures, and are always of <a href=../LangRef.md#index-type><code>index</code></a>
type. Dimensions are declared in parentheses and symbols are declared in square
brackets.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// A 2d to 3d affine mapping.
// d0/d1 are dimensions, s0 is a symbol
#affine_map2to3 = (d0, d1)[s0] -&gt; (d0, d1 + s0, d1 - s0)</code></pre></div><p>Dimensional identifiers correspond to the dimensions of the underlying structure
being represented (a map, set, or more concretely a loop nest or a tensor); for
example, a three-dimensional loop nest has three dimensional identifiers. Symbol
identifiers represent an unknown quantity that can be treated as constant for a
region of interest.</p><p>Dimensions and symbols are bound to SSA values by various operations in MLIR and
use the same parenthesized vs square bracket list to distinguish the two.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=err>//</span> <span class=k>Uses of SSA values that are passed to dimensional identifiers</span><span class=err>.</span>
<span class=k>dim-use-list </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>ssa-use-list</span><span class=ni>? `)`
</span><span class=ni>
</span><span class=ni>// Uses of SSA values that are used to bind symbols.
</span><span class=ni>symbol-use-list ::= `[` ssa-use-list?</span> <span class=err>`</span><span class=p>]</span><span class=err>`</span>

<span class=err>//</span> <span class=k>Most things that bind SSA values bind dimensions and symbols</span><span class=p>.</span>
<span class=k>dim-and-symbol-use-list </span><span class=err>::</span><span class=o>=</span> <span class=k>dim-use-list symbol-use-list</span><span class=err>?</span></code></pre></div><p>SSA values bound to dimensions and symbols must always have &lsquo;index&rsquo; type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">#affine_map2to3 = (d0, d1)[s0] -&gt; (d0, d1 + s0, d1 - s0)
// Binds %N to the s0 symbol in affine_map2to3.
%x = alloc()[%N] : memref&lt;40x50xf32, #affine_map2to3&gt;</code></pre></div><h3 id=restrictions-on-dimensions-and-symbols>Restrictions on Dimensions and Symbols</h3><p>The affine dialect imposes certain restrictions on dimension and symbolic
identifiers to enable powerful analysis and transformation. A symbolic
identifier can be bound to an SSA value that is either an argument to the
function, a value defined at the top level of that function (outside of all
loops and if operations), the result of a
<a href=Standard.md#constant-operation><code>constant</code> operation</a>, or the result of an
<a href=#affineapply-operation><code>affine.apply</code> operation</a> that recursively takes as
arguments any symbolic identifiers. Dimensions may be bound not only to anything
that a symbol is bound to, but also to induction variables of enclosing
<a href=#affinefor-operation><code>affine.for</code> operations</a>, and the result of an
<a href=#affineapply-operation><code>affine.apply</code> operation</a> (which recursively may use
other dimensions and symbols).</p><h3 id=affine-expressions>Affine Expressions</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>affine-expr </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>affine-expr </span><span class=err>`</span><span class=p>)</span><span class=err>`</span>
              <span class=p>|</span> <span class=k>affine-expr </span><span class=err>`+`</span> <span class=k>affine-expr</span>
              <span class=p>|</span> <span class=k>affine-expr </span><span class=err>`</span><span class=o>-</span><span class=err>`</span> <span class=k>affine-expr</span>
              <span class=p>|</span> <span class=err>`</span><span class=o>-</span><span class=err>`</span><span class=ni>? integer-literal `*` affine-expr
</span><span class=ni>              | affine-expr `ceildiv` integer-literal
</span><span class=ni>              | affine-expr `floordiv` integer-literal
</span><span class=ni>              | affine-expr `mod` integer-literal
</span><span class=ni>              | `-`affine-expr
</span><span class=ni>              | bare-id
</span><span class=ni>              | `-`?</span> <span class=k>integer-literal</span>

<span class=k>multi-dim-affine-expr </span><span class=err>::=</span> <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>affine-expr </span><span class=p>(</span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>affine-expr</span><span class=p>)</span><span class=err>*</span> <span class=err>`</span><span class=p>)</span><span class=err>`</span></code></pre></div><p><code>ceildiv</code> is the ceiling function which maps the result of the division of its
first argument by its second argument to the smallest integer greater than or
equal to that result. <code>floordiv</code> is a function which maps the result of the
division of its first argument by its second argument to the largest integer
less than or equal to that result. <code>mod</code> is the modulo operation: since its
second argument is always positive, its results are always positive in our
usage. The <code>integer-literal</code> operand for ceildiv, floordiv, and mod is always
expected to be positive. <code>bare-id</code> is an identifier which must have type
<a href=../LangRef.md#index-type>index</a>. The precedence of operations in an affine
expression are ordered from highest to lowest in the order: (1)
parenthesization, (2) negation, (3) modulo, multiplication, floordiv, and
ceildiv, and (4) addition and subtraction. All of these operators associate from
left to right.</p><p>A <em>multidimensional affine expression</em> is a comma separated list of
one-dimensional affine expressions, with the entire list enclosed in
parentheses.</p><p><strong>Context:</strong> An affine function, informally, is a linear function plus a
constant. More formally, a function f defined on a vector $$\vec{v} \in
\mathbb{Z}^n$$ is a multidimensional affine function of $$\vec{v}$$ if
$$f(\vec{v})$$ can be expressed in the form $$M \vec{v} + \vec{c}$$ where $$M$$
is a constant matrix from $$\mathbb{Z}^{m \times n}$$ and $$\vec{c}$$ is a
constant vector from $$\mathbb{Z}$$. $$m$$ is the dimensionality of such an
affine function. MLIR further extends the definition of an affine function to
allow &lsquo;floordiv&rsquo;, &lsquo;ceildiv&rsquo;, and &lsquo;mod&rsquo; with respect to positive integer
constants. Such extensions to affine functions have often been referred to as
quasi-affine functions by the polyhedral compiler community. MLIR uses the term
&lsquo;affine map&rsquo; to refer to these multidimensional quasi-affine functions. As
examples, $$(i+j+1, j)$$, $$(i \mod 2, j+i)$$, $$(j, i/4, i \mod 4)$$, $$(2i+1,
j)$$ are two-dimensional affine functions of $$(i, j)$$, but $$(i \cdot j,
i^2)$$, $$(i \mod j, i/j)$$ are not affine functions of $$(i, j)$$.</p><h3 id=affine-maps>Affine Maps</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>affine-map-inline</span>
   <span class=err>::</span><span class=o>=</span> <span class=k>dim-and-symbol-id-lists </span><span class=err>`</span><span class=o>-</span><span class=err>&gt;`</span> <span class=k>multi-dim-affine-expr</span></code></pre></div><p>The identifiers in the dimensions and symbols lists must be unique. These are
the only identifiers that may appear in &lsquo;multi-dim-affine-expr&rsquo;. Affine maps
with one or more symbols in its specification are known as &ldquo;symbolic affine
maps&rdquo;, and those with no symbols as &ldquo;non-symbolic affine maps&rdquo;.</p><p><strong>Context:</strong> Affine maps are mathematical functions that transform a list of
dimension indices and symbols into a list of results, with affine expressions
combining the indices and symbols. Affine maps distinguish between
<a href=#dimensions-and-symbols>indices and symbols</a> because indices are inputs to the
affine map when the map is called (through an operation such as
<a href=#affineapply-operation>affine.apply</a>), whereas symbols are bound when
the map is established (e.g. when a memref is formed, establishing a
memory <a href=../LangRef.md#layout-map>layout map</a>).</p><p>Affine maps are used for various core structures in MLIR. The restrictions we
impose on their form allows powerful analysis and transformation, while keeping
the representation closed with respect to several operations of interest.</p><h4 id=named-affine-mappings>Named affine mappings</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>affine-map-id </span><span class=err>::</span><span class=o>=</span> <span class=err>`#`</span> <span class=k>suffix-id</span>

<span class=err>//</span> <span class=k>Definitions of affine maps are at the top of the file</span><span class=p>.</span>
<span class=k>affine-map-def    </span><span class=err>::</span><span class=o>=</span> <span class=k>affine-map-id </span><span class=err>`=`</span> <span class=k>affine-map-inline</span>
<span class=k>module-header-def </span><span class=err>::=</span> <span class=k>affine-map-def</span>

<span class=err>//</span> <span class=k>Uses of affine maps may use the inline form or the named form</span><span class=p>.</span>
<span class=k>affine-map </span><span class=err>::</span><span class=o>=</span> <span class=k>affine-map-id </span><span class=p>|</span> <span class=k>affine-map-inline</span></code></pre></div><p>Affine mappings may be defined inline at the point of use, or may be hoisted to
the top of the file and given a name with an affine map definition, and used by
name.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Affine map out-of-line definition and usage example.
#affine_map42 = (d0, d1)[s0] -&gt; (d0, d0 + d1 + s0 floordiv 2)

// Use an affine mapping definition in an alloc operation, binding the
// SSA value %N to the symbol s0.
%a = alloc()[%N] : memref&lt;4x4xf32, #affine_map42&gt;

// Same thing with an inline affine mapping definition.
%b = alloc()[%N] : memref&lt;4x4xf32, (d0, d1)[s0] -&gt; (d0, d0 + d1 + s0 floordiv 2)&gt;</code></pre></div><h3 id=semi-affine-maps>Semi-affine maps</h3><p>Semi-affine maps are extensions of affine maps to allow multiplication,
<code>floordiv</code>, <code>ceildiv</code>, and <code>mod</code> with respect to symbolic identifiers.
Semi-affine maps are thus a strict superset of affine maps.</p><p>Syntax of semi-affine expressions:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>semi-affine-expr </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>semi-affine-expr </span><span class=err>`</span><span class=p>)</span><span class=err>`</span>
                   <span class=p>|</span> <span class=k>semi-affine-expr </span><span class=err>`+`</span> <span class=k>semi-affine-expr</span>
                   <span class=p>|</span> <span class=k>semi-affine-expr </span><span class=err>`</span><span class=o>-</span><span class=err>`</span> <span class=k>semi-affine-expr</span>
                   <span class=p>|</span> <span class=k>symbol-or-const </span><span class=err>`*`</span> <span class=k>semi-affine-expr</span>
                   <span class=p>|</span> <span class=k>semi-affine-expr </span><span class=err>`</span><span class=k>ceildiv</span><span class=err>`</span> <span class=k>symbol-or-const</span>
                   <span class=p>|</span> <span class=k>semi-affine-expr </span><span class=err>`</span><span class=k>floordiv</span><span class=err>`</span> <span class=k>symbol-or-const</span>
                   <span class=p>|</span> <span class=k>semi-affine-expr </span><span class=err>`</span><span class=k>mod</span><span class=err>`</span> <span class=k>symbol-or-const</span>
                   <span class=p>|</span> <span class=k>bare-id</span>
                   <span class=p>|</span> <span class=err>`</span><span class=o>-</span><span class=err>`</span><span class=ni>? integer-literal
</span><span class=ni>
</span><span class=ni>symbol-or-const ::= `-`?</span> <span class=k>integer-literal </span><span class=p>|</span> <span class=k>symbol-id</span>

<span class=k>multi-dim-semi-affine-expr </span><span class=err>::=</span> <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>semi-affine-expr </span><span class=p>(</span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>semi-affine-expr</span><span class=p>)</span><span class=err>*</span> <span class=err>`</span><span class=p>)</span><span class=err>`</span></code></pre></div><p>The precedence and associativity of operations in the syntax above is the same
as that for <a href=#affine-expressions>affine expressions</a>.</p><p>Syntax of semi-affine maps:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>semi-affine-map-inline</span>
   <span class=err>::</span><span class=o>=</span> <span class=k>dim-and-symbol-id-lists </span><span class=err>`</span><span class=o>-</span><span class=err>&gt;`</span> <span class=k>multi-dim-semi-affine-expr</span></code></pre></div><p>Semi-affine maps may be defined inline at the point of use, or may be hoisted to
the top of the file and given a name with a semi-affine map definition, and used
by name.</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>semi-affine-map-id </span><span class=err>::</span><span class=o>=</span> <span class=err>`#`</span> <span class=k>suffix-id</span>

<span class=err>//</span> <span class=k>Definitions of semi-affine maps are at the top of file</span><span class=p>.</span>
<span class=k>semi-affine-map-def </span><span class=err>::</span><span class=o>=</span> <span class=k>semi-affine-map-id </span><span class=err>`=`</span> <span class=k>semi-affine-map-inline</span>
<span class=k>module-header-def </span><span class=err>::=</span> <span class=k>semi-affine-map-def</span>

<span class=err>//</span> <span class=k>Uses of semi-affine maps may use the inline form or the named form</span><span class=p>.</span>
<span class=k>semi-affine-map </span><span class=err>::</span><span class=o>=</span> <span class=k>semi-affine-map-id </span><span class=p>|</span> <span class=k>semi-affine-map-inline</span></code></pre></div><h3 id=integer-sets>Integer Sets</h3><p>An integer set is a conjunction of affine constraints on a list of identifiers.
The identifiers associated with the integer set are separated out into two
classes: the set&rsquo;s dimension identifiers, and the set&rsquo;s symbolic identifiers.
The set is viewed as being parametric on its symbolic identifiers. In the
syntax, the list of set&rsquo;s dimension identifiers are enclosed in parentheses
while its symbols are enclosed in square brackets.</p><p>Syntax of affine constraints:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>affine-constraint </span><span class=err>::</span><span class=o>=</span> <span class=k>affine-expr </span><span class=err>`&gt;=`</span> <span class=err>`0`</span>
                    <span class=p>|</span> <span class=k>affine-expr </span><span class=err>`==`</span> <span class=err>`0`</span>
<span class=k>affine-constraint-conjunction </span><span class=err>::=</span> <span class=k>affine-constraint </span><span class=p>(</span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>affine-constraint</span><span class=p>)</span><span class=err>*</span></code></pre></div><p>Integer sets may be defined inline at the point of use, or may be hoisted to the
top of the file and given a name with an integer set definition, and used by
name.</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>integer-set-id </span><span class=err>::</span><span class=o>=</span> <span class=err>`#`</span> <span class=k>suffix-id</span>

<span class=k>integer-set-inline</span>
   <span class=err>::=</span> <span class=k>dim-and-symbol-id-lists </span><span class=err>`:`</span> <span class=s1>&#39;(&#39;</span> <span class=k>affine-constraint-conjunction</span><span class=err>?</span> <span class=s1>&#39;)&#39;</span>

<span class=err>//</span> <span class=k>Declarations of integer sets are at the top of the file</span><span class=p>.</span>
<span class=k>integer-set-decl </span><span class=err>::</span><span class=o>=</span> <span class=k>integer-set-id </span><span class=err>`=`</span> <span class=k>integer-set-inline</span>

<span class=err>//</span> <span class=k>Uses of integer sets may use the inline form or the named form</span><span class=p>.</span>
<span class=k>integer-set </span><span class=err>::</span><span class=o>=</span> <span class=k>integer-set-id </span><span class=p>|</span> <span class=k>integer-set-inline</span></code></pre></div><p>The dimensionality of an integer set is the number of identifiers appearing in
dimension list of the set. The affine-constraint non-terminals appearing in the
syntax above are only allowed to contain identifiers from dims and symbols. A
set with no constraints is a set that is unbounded along all of the set&rsquo;s
dimensions.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// A example two-dimensional integer set with two symbols.
#set42 = (d0, d1)[s0, s1]
   : (d0 &gt;= 0, -d0 + s0 - 1 &gt;= 0, d1 &gt;= 0, -d1 + s1 - 1 &gt;= 0)

// Inside a Region
affine.if #set42(%i, %j)[%M, %N] {
  ...
}</code></pre></div><p><code>d0</code> and <code>d1</code> correspond to dimensional identifiers of the set, while <code>s0</code> and
<code>s1</code> are symbol identifiers.</p><h2 id=operations>Operations</h2><h4 id=affine-apply-operation>&lsquo;affine.apply&rsquo; operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>affine</span><span class=p>.</span><span class=k>apply</span><span class=err>`</span> <span class=k>affine-map dim-and-symbol-use-list</span></code></pre></div><p>The <code>affine.apply</code> operation applies an
<a href=#affine-expressions>affine mapping</a> to a list of SSA values,
yielding a single SSA value. The number of dimension and symbol arguments to
affine.apply must be equal to the respective number of dimensional and symbolic
inputs to the affine mapping; the <code>affine.apply</code> operation always returns one
value. The input operands and result must all have &lsquo;index&rsquo; type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">#map10 = (d0, d1) -&gt; (d0 floordiv 8 + d1 floordiv 128)
...
%1 = affine.apply #map10 (%s, %t)

// Inline example.
%2 = affine.apply (i)[s0] -&gt; (i+s0) (%42)[%n]</code></pre></div><h4 id=affine-for-operation>&lsquo;affine.for&rsquo; operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation   </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>affine</span><span class=p>.</span><span class=k>for</span><span class=err>`</span> <span class=k>ssa-id </span><span class=err>`</span><span class=o>=</span><span class=err>`</span> <span class=k>lower-bound </span><span class=err>`</span><span class=k>to</span><span class=err>`</span> <span class=k>upper-bound</span>
                      <span class=p>(</span><span class=err>`</span><span class=k>step</span><span class=err>`</span> <span class=k>integer-literal</span><span class=p>)</span><span class=ni>? `{` op* `}`
</span><span class=ni>
</span><span class=ni>lower-bound ::= `max`?</span> <span class=k>affine-map dim-and-symbol-use-list </span><span class=p>|</span> <span class=k>shorthand-bound</span>
<span class=k>upper-bound </span><span class=err>::=</span> <span class=err>`</span><span class=k>min</span><span class=err>`</span><span class=ni>? affine-map dim-and-symbol-use-list | shorthand-bound
</span><span class=ni>shorthand-bound ::= ssa-id | `-`?</span> <span class=k>integer-literal</span></code></pre></div><p>The <code>affine.for</code> operation represents an affine loop nest. It has one region
containing its body. This region must contain one block that terminates with
<a href=#affineterminator-operation><code>affine.terminator</code></a>. <em>Note:</em> when <code>affine.for</code> is
printed in custom format, the terminator is omitted. The block has one argument
of <a href=../LangRef.md#index-type><code>index</code></a> type that represents the induction
variable of the loop.</p><p>The <code>affine.for</code> operation executes its body a number of times iterating from a
lower bound to an upper bound by a stride. The stride, represented by <code>step</code>, is
a positive constant integer which defaults to &ldquo;1&rdquo; if not present. The lower and
upper bounds specify a half-open range: the range includes the lower bound but
does not include the upper bound.</p><p>The lower and upper bounds of a <code>affine.for</code> operation are represented as an
application of an affine mapping to a list of SSA values passed to the map. The
<a href=#restrictions-on-dimensions-and-symbols>same restrictions</a> hold for these SSA
values as for all bindings of SSA values to dimensions and symbols.</p><p>The affine mappings for the bounds may return multiple results, in which case
the <code>max</code>/<code>min</code> keywords are required (for the lower/upper bound respectively),
and the bound is the maximum/minimum of the returned values. There is no
semantic ambiguity, but MLIR syntax requires the use of these keywords to make
things more obvious to human readers.</p><p>Many upper and lower bounds are simple, so MLIR accepts two custom form
syntaxes: the form that accepts a single &lsquo;ssa-id&rsquo; (e.g. <code>%N</code>) is shorthand for
applying that SSA value to a function that maps a single symbol to itself, e.g.,
<code>()[s]-&gt;(s)()[%N]</code>. The integer literal form (e.g. <code>-42</code>) is shorthand for a
nullary mapping function that returns the constant value (e.g. <code>()-&gt;(-42)()</code>).</p><p>Example showing reverse iteration of the inner loop:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">#map57 = (d0)[s0] -&gt; (s0 - d0 - 1)

func @simple_example(%A: memref&lt;?x?xf32&gt;, %B: memref&lt;?x?xf32&gt;) {
  %N = dim %A, 0 : memref&lt;?x?xf32&gt;
  affine.for %i = 0 to %N step 1 {
    affine.for %j = 0 to %N {   // implicitly steps by 1
      %0 = affine.apply #map57(%j)[%N]
      %tmp = call @F1(%A, %i, %0) : (memref&lt;?x?xf32&gt;, index, index)-&gt;(f32)
      call @F2(%tmp, %B, %i, %0) : (f32, memref&lt;?x?xf32&gt;, index, index)-&gt;()
    }
  }
  return
}</code></pre></div><h4 id=affine-if-operation>&lsquo;affine.if&rsquo; operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation    </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>affine</span><span class=p>.</span><span class=k>if</span><span class=err>`</span> <span class=k>if-op-cond </span><span class=err>`{`</span> <span class=k>op</span><span class=err>*</span> <span class=err>`}`</span> <span class=err>(`</span><span class=k>else</span><span class=err>`</span> <span class=err>`{`</span> <span class=k>op</span><span class=err>*</span> <span class=err>`}`)?</span>
<span class=k>if-op-cond </span><span class=err>::</span><span class=o>=</span> <span class=k>integer-set dim-and-symbol-use-list</span></code></pre></div><p>The <code>affine.if</code> operation restricts execution to a subset of the loop iteration
space defined by an integer set (a conjunction of affine constraints). A single
<code>affine.if</code> may end with an optional <code>else</code> clause.</p><p>The condition of the <code>affine.if</code> is represented by an
<a href=#integer-sets>integer set</a> (a conjunction of affine constraints),
and the SSA values bound to the dimensions and symbols in the integer set. The
<a href=#restrictions-on-dimensions-and-symbols>same restrictions</a> hold for these SSA
values as for all bindings of SSA values to dimensions and symbols.</p><p>The <code>affine.if</code> operation contains two regions for the &ldquo;then&rdquo; and &ldquo;else&rdquo;
clauses. The latter may be empty (i.e. contain no blocks), meaning the absence
of the else clause. When non-empty, both regions must contain exactly one block
terminating with <a href=#affineterminator-operation><code>affine.terminator</code></a>. <em>Note:</em>
when <code>affine.if</code> is printed in custom format, the terminator is omitted. These
blocks must not have any arguments.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">#set = (d0, d1)[s0]: (d0 - 10 &gt;= 0, s0 - d0 - 9 &gt;= 0,
                      d1 - 10 &gt;= 0, s0 - d1 - 9 &gt;= 0)
func @reduced_domain_example(%A, %X, %N) : (memref&lt;10xi32&gt;, i32, i32) {
  affine.for %i = 0 to %N {
     affine.for %j = 0 to %N {
       %0 = affine.apply #map42(%j)
       %tmp = call @S1(%X, %i, %0)
       affine.if #set(%i, %j)[%N] {
          %1 = affine.apply #map43(%i, %j)
          call @S2(%tmp, %A, %i, %1)
       }
    }
  }
  return
}</code></pre></div><h4 id=affine-load-operation>&lsquo;affine.load&rsquo; operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>affine</span><span class=p>.</span><span class=k>load</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`[`</span> <span class=k>multi-dim-affine-map-of-ssa-ids </span><span class=err>`]`</span> <span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>The <code>affine.load</code> op reads an element from a memref, where the index
for each memref dimension is an affine expression of loop induction
variables and symbols. The output of &lsquo;affine.load&rsquo; is a new value with the
same type as the elements of the memref. An affine expression of loop IVs
and symbols must be specified for each dimension of the memref. The keyword
&lsquo;symbol&rsquo; can be used to indicate SSA identifiers which are symbolic.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">  Example 1:

    %1 = affine.load %0[%i0 + 3, %i1 + 7] : memref&lt;100x100xf32&gt;

  Example 2: Uses &#39;symbol&#39; keyword for symbols &#39;%n&#39; and &#39;%m&#39;.

    %1 = affine.load %0[%i0 + symbol(%n), %i1 + symbol(%m)]
      : memref&lt;100x100xf32&gt;</code></pre></div><h4 id=affine-store-operation>&lsquo;affine.store&rsquo; operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>affine</span><span class=p>.</span><span class=k>store</span><span class=err>`</span> <span class=k>ssa-use</span><span class=err>,</span> <span class=k>ssa-use </span><span class=err>`[`</span> <span class=k>multi-dim-affine-map-of-ssa-ids </span><span class=err>`]`</span> <span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>The <code>affine.store</code> op writes an element to a memref, where the index
for each memref dimension is an affine expression of loop induction
variables and symbols. The &lsquo;affine.store&rsquo; op stores a new value which is the
same type as the elements of the memref. An affine expression of loop IVs
and symbols must be specified for each dimension of the memref. The keyword
&lsquo;symbol&rsquo; can be used to indicate SSA identifiers which are symbolic.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">    Example 1:

      affine.store %v0, %0[%i0 + 3, %i1 + 7] : memref&lt;100x100xf32&gt;

    Example 2: Uses &#39;symbol&#39; keyword for symbols &#39;%n&#39; and &#39;%m&#39;.

      affine.store %v0, %0[%i0 + symbol(%n), %i1 + symbol(%m)]
        : memref&lt;100x100xf32&gt;</code></pre></div><h4 id=affine-dma-start-operation>&lsquo;affine.dma_start&rsquo; operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>affine</span><span class=p>.</span><span class=k>dma_Start</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`[`</span> <span class=k>multi-dim-affine-map-of-ssa-ids </span><span class=err>`]`,</span> <span class=err>`[`</span> <span class=k>multi-dim-affine-map-of-ssa-ids </span><span class=err>`]`,</span> <span class=err>`[`</span> <span class=k>multi-dim-affine-map-of-ssa-ids </span><span class=err>`]`,</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>The <code>affine.dma_start</code> op starts a non-blocking DMA operation that transfers
data from a source memref to a destination memref. The source and destination
memref need not be of the same dimensionality, but need to have the same
elemental type. The operands include the source and destination memref&rsquo;s
each followed by its indices, size of the data transfer in terms of the
number of elements (of the elemental type of the memref), a tag memref with
its indices, and optionally at the end, a stride and a
number_of_elements_per_stride arguments. The tag location is used by an
AffineDmaWaitOp to check for completion. The indices of the source memref,
destination memref, and the tag memref have the same restrictions as any
affine.load/store. In particular, index for each memref dimension must be an
affine expression of loop induction variables and symbols.
The optional stride arguments should be of &lsquo;index&rsquo; type, and specify a
stride for the slower memory space (memory space with a lower memory space
id), transferring chunks of number_of_elements_per_stride every stride until
%num_elements are transferred. Either both or no stride arguments should be
specified. The value of &lsquo;num_elements&rsquo; must be a multiple of
&lsquo;number_of_elements_per_stride&rsquo;.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">For example, a DmaStartOp operation that transfers 256 elements of a memref
&#39;%src&#39; in memory space 0 at indices [%i + 3, %j] to memref &#39;%dst&#39; in memory
space 1 at indices [%k + 7, %l], would be specified as follows:

  %num_elements = constant 256
  %idx = constant 0 : index
  %tag = alloc() : memref&lt;1xi32, 4&gt;
  affine.dma_start %src[%i + 3, %j], %dst[%k + 7, %l], %tag[%idx],
    %num_elements :
      memref&lt;40x128xf32, 0&gt;, memref&lt;2x1024xf32, 1&gt;, memref&lt;1xi32, 2&gt;

  If %stride and %num_elt_per_stride are specified, the DMA is expected to
  transfer %num_elt_per_stride elements every %stride elements apart from
  memory space 0 until %num_elements are transferred.

  affine.dma_start %src[%i, %j], %dst[%k, %l], %tag[%idx], %num_elements,
    %stride, %num_elt_per_stride : ...</code></pre></div><h4 id=affine-dma-wait-operation>&lsquo;affine.dma_wait&rsquo; operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>affine</span><span class=p>.</span><span class=k>dma_Start</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`[`</span> <span class=k>multi-dim-affine-map-of-ssa-ids </span><span class=err>`]`,</span> <span class=err>`[`</span> <span class=k>multi-dim-affine-map-of-ssa-ids </span><span class=err>`]`,</span> <span class=err>`[`</span> <span class=k>multi-dim-affine-map-of-ssa-ids </span><span class=err>`]`,</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>The <code>affine.dma_start</code> op blocks until the completion of a DMA operation
associated with the tag element &lsquo;%tag[%index]&lsquo;. %tag is a memref, and %index
has to be an index with the same restrictions as any load/store index.
In particular, index for each memref dimension must be an affine expression of
loop induction variables and symbols. %num_elements is the number of elements
associated with the DMA operation. For example:</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">  affine.dma_start %src[%i, %j], %dst[%k, %l], %tag[%index], %num_elements :
    memref&lt;2048xf32, 0&gt;, memref&lt;256xf32, 1&gt;, memref&lt;1xi32, 2&gt;
  ...
  ...
  affine.dma_wait %tag[%index], %num_elements : memref&lt;1xi32, 2&gt;</code></pre></div><h4 id=affine-min-operation>&lsquo;affine.min&rsquo; operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>affine</span><span class=p>.</span><span class=k>min</span><span class=err>`</span> <span class=k>affine-map dim-and-symbol-use-list</span></code></pre></div><p>The <code>affine.min</code> operation applies an
<a href=#affine-expressions>affine mapping</a> to a list of SSA values, and returns the
minimum value of all result expressions. The number of dimension and symbol
arguments to affine.min must be equal to the respective number of dimensional
and symbolic inputs to the affine mapping; the <code>affine.min</code> operation always
returns one value. The input operands and result must all have &lsquo;index&rsquo; type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">%0 = affine.min (d0)[s0] -&gt; (1000, d0 + 512, s0) (%arg0)[%arg1]</code></pre></div><h4 id=affine-terminator-operation><code>affine.terminator</code> operation</h4><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=s2>&#34;affine.terminator&#34;</span><span class=p>()</span> <span class=err>:</span> <span class=p>()</span> <span class=o>-</span><span class=err>&gt;</span> <span class=p>()</span><span class=err>`</span></code></pre></div><p>Affine terminator is a special terminator operation for blocks inside affine
loops (<a href=#affinefor-operation><code>affine.for</code></a>) and branches
(<a href=#affineif-operation><code>affine.if</code></a>). It unconditionally transmits the control
flow to the successor of the operation enclosing the region.</p><p><em>Rationale</em>: bodies of affine operations are <a href=../LangRef.md#blocks>blocks</a> that
must have terminators. Loops and branches represent structured control flow and
should not accept arbitrary branches as terminators.</p><p>This operation does <em>not</em> have a custom syntax. However, affine control
operations omit the terminator in their custom syntax for brevity.</p><div class=edit-meta>Last updated on 29 Nov 2019<br>Published on 29 Nov 2019<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/Dialects/Affine.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/dialects/ title=Dialect><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Dialect</a>
<a class="nav nav-next" href=/docs/dialects/gpu/ title="GPU Dialect">Next - GPU Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=http://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Docs</a><ul class=sub-menu><li><a href=/docs/tutorials/>Tutorials</a><ul class=sub-menu><li><a href=/docs/tutorials/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/tutorials/interfaces/>Interfaces</a></li><li><a href=/docs/tutorials/traits/>Introduction to Operation Traits</a></li><li><a href=/docs/tutorials/quickstartrewrites/>Quickstart on Graph Rewrite</a></li><li><a href=/docs/tutorials/toy/>Toy Tutorial</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Intro</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li class=parent><a href=/docs/dialects/>Dialect</a><ul class=sub-menu><li class=active><a href=/docs/dialects/affine/>Affine</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgops/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li></ul></li><li><a href=/docs/design/>Design</a><ul class=sub-menu><li><a href=/docs/design/canonicalization/>Canonicalization</a></li><li><a href=/docs/design/rationalesimplifiedpolyhedralform/>Case for a Simplified Polyhedral Form</a></li><li><a href=/docs/design/rationale/>Design Rationale</a></li><li><a href=/docs/design/diagnostics/>Diagnostics Infrastructure</a></li><li><a href=/docs/design/edsc/>EDSC: Declarative Builders</a></li><li><a href=/docs/design/genericdagrewriter/>Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/design/mlirforgraphalgorithms/>Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/design/quantization/>Quantization</a></li><li><a href=/docs/design/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/design/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/design/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/langref/>Core Specification</a></li><li><a href=/docs/passes/>Passes</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>