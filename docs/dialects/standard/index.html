<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Standard Dialect - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/dialects/standard/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Standard Dialect</h1><p>This dialect provides documentation for operations within the Standard dialect.</p><p>Note: This dialect is a collection of operations for several different concepts,
and should be split into multiple more-focused dialects accordingly.</p><p>[TOC]</p><p>TODO: shape, which returns a 1D tensor, and can take an unknown rank tensor as
input.</p><p>TODO: rank, which returns an index.</p><h2 id=terminator-operations>Terminator operations</h2><p>Terminator operations are required at the end of each block. They may contain a
list of successors, i.e. other blocks to which the control flow will proceed.</p><h3 id=br-terminator-operation>&lsquo;br&rsquo; terminator operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>br</span><span class=err>`</span> <span class=k>successor</span>
<span class=k>successor </span><span class=err>::=</span> <span class=k>bb-id branch-use-list</span><span class=err>?</span>
<span class=k>branch-use-list </span><span class=err>::=</span> <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>ssa-use-list </span><span class=err>`:`</span> <span class=k>type-list-no-parens </span><span class=err>`</span><span class=p>)</span><span class=err>`</span></code></pre></div><p>The <code>br</code> terminator operation represents an unconditional jump to a target
block. The count and types of operands to the branch must align with the
arguments in the target block.</p><p>The MLIR branch operation is not allowed to target the entry block for a region.</p><h3 id=cond-br-terminator-operation>&lsquo;cond_br&rsquo; terminator operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>cond_br</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>successor </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>successor</span></code></pre></div><p>The <code>cond_br</code> terminator operation represents a conditional branch on a boolean
(1-bit integer) value. If the bit is set, then the first destination is jumped
to; if it is false, the second destination is chosen. The count and types of
operands must align with the arguments in the corresponding target blocks.</p><p>The MLIR conditional branch operation is not allowed to target the entry block
for a region. The two destinations of the conditional branch operation are
allowed to be the same.</p><p>The following example illustrates a function with a conditional branch operation
that targets the same block:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">func @select(i32, i32, i1) -&gt; i32 {
^bb0(%a : i32, %b :i32, %flag : i1) :
    // Both targets are the same, operands differ
    cond_br %flag, ^bb1(%a : i32), ^bb1(%b : i32)

^bb1(%x : i32) :
    return %x : i32
}</code></pre></div><h3 id=return-terminator-operation>&lsquo;return&rsquo; terminator operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>return</span><span class=err>`</span> <span class=p>(</span><span class=k>ssa-use-list </span><span class=err>`:`</span> <span class=k>type-list-no-parens</span><span class=p>)</span><span class=err>?</span></code></pre></div><p>The <code>return</code> terminator operation represents the completion of a function, and
produces the result values. The count and types of the operands must match the
result types of the enclosing function. It is legal for multiple blocks in a
single function to return.</p><h2 id=core-operations>Core Operations</h2><h3 id=call-operation>&lsquo;call&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span>
    <span class=p>(</span><span class=k>ssa-id </span><span class=err>`=`</span><span class=p>)</span><span class=ni>? `call` symbol-ref-id `(` ssa-use-list?</span> <span class=err>`</span><span class=p>)</span><span class=err>`</span> <span class=err>`:`</span> <span class=k>function-type</span></code></pre></div><p>The <code>call</code> operation represents a direct call to a function. The operands and
result types of the call must match the specified function type. The callee is
encoded as a function attribute named &ldquo;callee&rdquo;.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Calling the function my_add.
%31 = call @my_add(%0, %1) : (tensor&lt;16xf32&gt;, tensor&lt;16xf32&gt;) -&gt; tensor&lt;16xf32&gt;</code></pre></div><h3 id=call-indirect-operation>&lsquo;call_indirect&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>call_indirect</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>ssa-use-list</span><span class=err>?</span> <span class=err>`</span><span class=p>)</span><span class=err>`</span> <span class=err>`:`</span> <span class=k>function-type</span></code></pre></div><p>The <code>call_indirect</code> operation represents an indirect call to a value of function
type. Functions are first class types in MLIR, and may be passed as arguments
and merged together with block arguments. The operands and result types of the
call must match the specified function type.</p><p>Function values can be created with the
<a href=#constant-operation><code>constant</code> operation</a>.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">%31 = call_indirect %15(%0, %1)
        : (tensor&lt;16xf32&gt;, tensor&lt;16xf32&gt;) -&gt; tensor&lt;16xf32&gt;</code></pre></div><h3 id=dim-operation>&lsquo;dim&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>dim</span><span class=err>`</span> <span class=k>ssa-id </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>integer-literal </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>The <code>dim</code> operation takes a memref or tensor operand and a dimension index, and
returns an <a href=../LangRef.md#index-type><code>index</code></a> that is the size of that
dimension.</p><p>The <code>dim</code> operation is represented with a single integer attribute named
<code>index</code>, and the type specifies the type of the memref or tensor operand.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Always returns 4, can be constant folded:
%x = dim %A, 0 : tensor&lt;4 x ? x f32&gt;

// Returns the dynamic dimension of %A.
%y = dim %A, 1 : tensor&lt;4 x ? x f32&gt;

// Equivalent generic form:
%x = &#34;std.dim&#34;(%A) {index = 0 : i64} : (tensor&lt;4 x ? x f32&gt;) -&gt; index
%y = &#34;std.dim&#34;(%A) {index = 1 : i64} : (tensor&lt;4 x ? x f32&gt;) -&gt; index</code></pre></div><h2 id=memory-operations>Memory Operations</h2><h3 id=alloc-operation>&lsquo;alloc&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>alloc</span><span class=err>`</span> <span class=k>dim-and-symbol-use-list </span><span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>Allocates a new memref of specified type. Values required for dynamic dimension
sizes are passed as arguments in parentheses (in the same order in which they
appear in the shape signature of the memref) while the symbols required by the
layout map are passed in the square brackets in lexicographical order. If no
layout maps are specified in the memref, then an identity mapping is used.</p><p>The buffer referenced by a memref type is created by the <code>alloc</code> operation, and
destroyed by the <code>dealloc</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Allocating memref for a fully static shape.
%A = alloc() : memref&lt;1024x64xf32, #layout_map0, memspace0&gt;

// %M, %N, %x, %y are SSA values of integer type.  M and N are bound to the
// two unknown dimensions of the type and x/y are bound to symbols in
// #layout_map1.
%B = alloc(%M, %N)[%x, %y] : memref&lt;?x?xf32, #layout_map1, memspace1&gt;</code></pre></div><h3 id=alloc-static-operation>&lsquo;alloc_static&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span>
    <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>alloc_static</span><span class=err>`</span> <span class=err>`</span><span class=p>(</span><span class=err>`</span> <span class=k>integer-literal </span><span class=err>`</span><span class=p>)</span><span class=err>`</span> <span class=err>:</span>  <span class=k>memref-type</span></code></pre></div><p>Allocates a new memref of specified type with a fixed base pointer location in
memory. &lsquo;alloc_static&rsquo; does not support types that have dynamic shapes or that
require dynamic symbols in their layout function (use the
<a href=#alloc-operation><code>alloc</code> operation</a> in those cases).</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">%A = alloc_static(0x1232a00) : memref&lt;1024 x 64 x f32, #layout_map0, memspace0&gt;</code></pre></div><p>The <code>alloc_static</code> operation is used to represent code after buffer allocation
has been performed.</p><h3 id=dealloc-operation>&lsquo;dealloc&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>dealloc</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>Delineates the end of the lifetime of the memory corresponding to a memref
allocation. It is paired with an <a href=#alloc-operation><code>alloc</code></a> or
<a href=#alloc-static-operation><code>alloc_static</code></a> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">dealloc %A : memref&lt;128 x f32, #layout, memspace0&gt;</code></pre></div><h3 id=dma-start-operation>&lsquo;dma_start&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>dma_start</span><span class=err>`</span> <span class=k>ssa-use</span><span class=err>`</span><span class=p>[</span><span class=err>`</span><span class=k>ssa-use-list</span><span class=err>`</span><span class=p>]</span><span class=err>`</span> <span class=err>`</span><span class=p>,</span><span class=err>`</span>
               <span class=k>ssa-use</span><span class=err>`</span><span class=p>[</span><span class=err>`</span><span class=k>ssa-use-list</span><span class=err>`</span><span class=p>]</span><span class=err>`</span> <span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span>
               <span class=k>ssa-use</span><span class=err>`</span><span class=p>[</span><span class=err>`</span><span class=k>ssa-use-list</span><span class=err>`</span><span class=p>]</span><span class=err>`</span> <span class=p>(</span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use</span><span class=p>)</span><span class=err>?</span>
              <span class=err>`:`</span> <span class=k>memref-type </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>memref-type </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>memref-type</span></code></pre></div><p>Starts a non-blocking DMA operation that transfers data from a source memref to
a destination memref. The operands include the source and destination memref&rsquo;s
each followed by its indices, size of the data transfer in terms of the number
of elements (of the elemental type of the memref), a tag memref with its
indices, and optionally two additional arguments corresponding to the stride (in
terms of number of elements) and the number of elements to transfer per stride.
The tag location is used by a dma_wait operation to check for completion. The
indices of the source memref, destination memref, and the tag memref have the
same restrictions as any load/store operation in a affine context (whenever DMA
operations appear in an affine context). See
<a href=Affine.md#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in affine contexts. This allows powerful static analysis and transformations in
the presence of such DMAs including rescheduling, pipelining / overlap with
computation, and checking for matching start/end operations. The source and
destination memref need not be of the same dimensionality, but need to have the
same elemental type.</p><p>For example, a <code>dma_start</code> operation that transfers 32 vector elements from a
memref <code>%src</code> at location <code>[%i, %j]</code> to memref <code>%dst</code> at <code>[%k, %l]</code> would be
specified as shown below.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">%size = constant 32 : index
%tag = alloc() : memref&lt;1 x i32, (d0) -&gt; (d0), 4&gt;
%idx = constant 0 : index
dma_start %src[%i, %j], %dst[%k, %l], %size, %tag[%idx] :
     memref&lt;40 x 8 x vector&lt;16xf32&gt;, (d0, d1) -&gt; (d0, d1), 0&gt;,
     memref&lt;2 x 4 x vector&lt;16xf32&gt;, (d0, d1) -&gt; (d0, d1), 2&gt;,
     memref&lt;1 x i32&gt;, (d0) -&gt; (d0), 4&gt;</code></pre></div><h3 id=dma-wait-operation>&lsquo;dma_wait&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= `dma_wait` ssa-use`[`ssa-use-list`]` `,` ssa-use `:` memref-type
</code></pre><p>Blocks until the completion of a DMA operation associated with the tag element
specified with a tag memref and its indices. The operands include the tag memref
followed by its indices and the number of elements associated with the DMA being
waited on. The indices of the tag memref have the same restrictions as
load/store indices.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">dma_wait %tag[%idx], %size : memref&lt;1 x i32, (d0) -&gt; (d0), 4&gt;</code></pre></div><h3 id=extract-element-operation>&lsquo;extract_element&rsquo; operation</h3><p>Syntax:</p><pre><code>operation ::= ssa-id `=` `extract_element` ssa-use `[` ssa-use-list `]` `:` type
</code></pre><p>The <code>extract_element</code> op reads a tensor or vector and returns one element from
it specified by an index list. The output of the &lsquo;extract_element&rsquo; is a new
value with the same type as the elements of the tensor or vector. The arity of
indices matches the rank of the accessed value (i.e., if a tensor is of rank 3,
then 3 indices are required for the extract. The indices should all be of
<code>index</code> type.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">%3 = extract_element %v[%1, %2] : vector&lt;4x4xi32&gt;
%4 = extract_element %t[%1, %2] : tensor&lt;4x4xi32&gt;
%5 = extract_element %ut[%1, %2] : tensor&lt;*xi32&gt;</code></pre></div><h3 id=load-operation>&lsquo;load&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>load</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>[</span><span class=err>`</span> <span class=k>ssa-use-list </span><span class=err>`</span><span class=p>]</span><span class=err>`</span> <span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>The <code>load</code> op reads an element from a memref specified by an index list. The
output of load is a new value with the same type as the elements of the memref.
The arity of indices is the rank of the memref (i.e., if the memref loaded from
is of rank 3, then 3 indices are required for the load following the memref
identifier).</p><p>In an <code>affine.if</code> or <code>affine.for</code> body, the indices of a load are restricted to
SSA values bound to surrounding loop induction variables,
<a href=../LangRef.md#dimensions-and-symbols>symbols</a>, results of a
<a href=#constant-operation><code>constant</code> operation</a>, or the result of an <code>affine.apply</code>
operation that can in turn take as arguments all of the aforementioned SSA
values or the recursively result of such an <code>affine.apply</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">%1 = affine.apply (d0, d1) -&gt; (3*d0) (%i, %j)
%2 = affine.apply (d0, d1) -&gt; (d1+1) (%i, %j)
%12 = load %A[%1, %2] : memref&lt;8x?xi32, #layout, memspace0&gt;

// Example of an indirect load (treated as non-affine)
%3 = affine.apply (d0) -&gt; (2*d0 + 1)(%12)
%13 = load %A[%3, %2] : memref&lt;4x?xi32, #layout, memspace0&gt;</code></pre></div><p><strong>Context:</strong> The <code>load</code> and <code>store</code> operations are specifically crafted to fully
resolve a reference to an element of a memref, and (in affine <code>affine.if</code> and
<code>affine.for</code> operations) the compiler can follow use-def chains (e.g. through
<a href=Affine.md#affineapply-operation><code>affine.apply</code></a> operations) to precisely
analyze references at compile-time using polyhedral techniques. This is possible
because of the
<a href=Affine.md#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in these contexts.</p><h3 id=splat-operation>&lsquo;splat&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>splat</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=p>(</span> <span class=k>vector-type </span><span class=p>|</span> <span class=k>tensor-type </span><span class=p>)</span></code></pre></div><p>Broadcast the operand to all elements of the result vector or tensor. The
operand has to be of either integer or float type. When the result is a tensor,
it has to be statically shaped.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">  %s = load %A[%i] : memref&lt;128xf32&gt;
  %v = splat %s : vector&lt;4xf32&gt;
  %t = splat %s : tensor&lt;8x16xi32&gt;</code></pre></div><p>TODO: This operation is easy to extend to broadcast to dynamically shaped
tensors in the same way dynamically shaped memrefs are handled. <code>mlir {.mlir} //
Broadcasts %s to a 2-d dynamically shaped tensor, with %m, %n binding // to the
sizes of the two dynamic dimensions. %m = &quot;foo&quot;() : () -&gt; (index) %n = &quot;bar&quot;() :
() -&gt; (index) %t = splat %s [%m, %n] : tensor&lt;?x?xi32&gt;</code></p><h3 id=store-operation>&lsquo;store&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>store</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>[</span><span class=err>`</span> <span class=k>ssa-use-list </span><span class=err>`</span><span class=p>]</span><span class=err>`</span> <span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>Store value to memref location given by indices. The value stored should have
the same type as the elemental type of the memref. The number of arguments
provided within brackets need to match the rank of the memref.</p><p>In an affine context, the indices of a store are restricted to SSA values bound
to surrounding loop induction variables,
<a href=Affine.md#restrictions-on-dimensions-and-symbols>symbols</a>, results of a
<a href=#constant-operation><code>constant</code> operation</a>, or the result of an
<a href=Affine.md#affineapply-operation><code>affine.apply</code></a> operation that can in turn
take as arguments all of the aforementioned SSA values or the recursively result
of such an <code>affine.apply</code> operation.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">store %100, %A[%1, 1023] : memref&lt;4x?xf32, #layout, memspace0&gt;</code></pre></div><p><strong>Context:</strong> The <code>load</code> and <code>store</code> operations are specifically crafted to fully
resolve a reference to an element of a memref, and (in polyhedral <code>affine.if</code>
and <code>affine.for</code> operations) the compiler can follow use-def chains (e.g.
through <a href=Affine.md#affineapply-operation><code>affine.apply</code></a> operations) to
precisely analyze references at compile-time using polyhedral techniques. This
is possible because of the
<a href=Affine.md#restrictions-on-dimensions-and-symbols>restrictions on dimensions and symbols</a>
in these contexts.</p><h3 id=tensor-load-operation>&lsquo;tensor_load&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>tensor_load</span><span class=err>`</span> <span class=k>ssa-use-and-type</span></code></pre></div><p>Create a tensor from a memref, making an independent copy of the element data.
The result value is a tensor whose shape and element type match the memref
operand.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Produces a value of tensor&lt;4x?xf32&gt; type.
%12 = tensor_load %10 : memref&lt;4x?xf32, #layout, memspace0&gt;</code></pre></div><h3 id=tensor-store-operation>&lsquo;tensor_store&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=err>`</span><span class=k>tensor_store</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>memref-type</span></code></pre></div><p>Stores the contents of a tensor into a memref. The first operand is a value of
tensor type, the second operand is a value of memref type. The shapes and
element types of these must match, and are specified by the memref type.</p><p>Example:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">%9 = dim %8, 1 : tensor&lt;4x?xf32&gt;
%10 = alloc(%9) : memref&lt;4x?xf32, #layout, memspace0&gt;
tensor_store %8, %10 : memref&lt;4x?xf32, #layout, memspace0&gt;</code></pre></div><h2 id=unary-operations>Unary Operations</h2><h3 id=exp-operation>&lsquo;exp&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>exp</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar natural exponential.
%a = exp %b : f64

// SIMD vector element-wise natural exponential.
%f = exp %g : vector&lt;4xf32&gt;

// Tensor element-wise natural exponential.
%x = exp %y : tensor&lt;4x?xf8&gt;</code></pre></div><p>The <code>exp</code> operation takes one operand and returns one result of the same type.
This type may be a float scalar type, a vector whose element type is float, or a
tensor of floats. It has no standard attributes.</p><h2 id=arithmetic-operations>Arithmetic Operations</h2><p>Basic arithmetic in MLIR is specified by standard operations described in this
section.</p><h3 id=addi-operation>&lsquo;addi&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>addi</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar addition.
%a = addi %b, %c : i64

// SIMD vector element-wise addition, e.g. for Intel SSE.
%f = addi %g, %h : vector&lt;4xi32&gt;

// Tensor element-wise addition.
%x = addi %y, %z : tensor&lt;4x?xi8&gt;</code></pre></div><p>The <code>addi</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be an integer scalar type, a vector
whose element type is integer, or a tensor of integers. It has no standard
attributes.</p><h3 id=addf-operation>&lsquo;addf&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>addf</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar addition.
%a = addf %b, %c : f64

// SIMD vector addition, e.g. for Intel SSE.
%f = addf %g, %h : vector&lt;4xf32&gt;

// Tensor addition.
%x = addf %y, %z : tensor&lt;4x?xbf16&gt;</code></pre></div><p>The <code>addf</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be a floating point scalar type, a
vector whose element type is a floating point type, or a floating point tensor.</p><p>It has no standard attributes.</p><p>TODO: In the distant future, this will accept optional attributes for fast math,
contraction, rounding mode, and other controls.</p><h3 id=and-operation>&lsquo;and&rsquo; operation</h3><p>Bitwise integer and.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>and</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar integer bitwise and.
%a = and %b, %c : i64

// SIMD vector element-wise bitwise integer and.
%f = and %g, %h : vector&lt;4xi32&gt;

// Tensor element-wise bitwise integer and.
%x = and %y, %z : tensor&lt;4x?xi8&gt;</code></pre></div><p>The <code>and</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be an integer scalar type, a vector
whose element type is integer, or a tensor of integers. It has no standard
attributes.</p><h3 id=cmpi-operation>&lsquo;cmpi&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>cmpi</span><span class=err>`</span> <span class=k>string-literal </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-id </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-id </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Custom form of scalar &#34;signed less than&#34; comparison.
%x = cmpi &#34;slt&#34;, %lhs, %rhs : i32

// Generic form of the same operation.
%x = &#34;std.cmpi&#34;(%lhs, %rhs) {predicate = 2 : i64} : (i32, i32) -&gt; i1

// Custom form of vector equality comparison.
%x = cmpi &#34;eq&#34;, %lhs, %rhs : vector&lt;4xi64&gt;

// Generic form of the same operation.
%x = &#34;std.cmpi&#34;(%lhs, %rhs) {predicate = 0 : i64}
    : (vector&lt;4xi64&gt;, vector&lt;4xi64&gt;) -&gt; vector&lt;4xi1&gt;</code></pre></div><p>The <code>cmpi</code> operation is a generic comparison for integer-like types. Its two
arguments can be integers, vectors or tensors thereof as long as their types
match. The operation produces an i1 for the former case, a vector or a tensor of
i1 with the same shape as inputs in the other cases.</p><p>Its first argument is an attribute that defines which type of comparison is
performed. The following comparisons are supported:</p><ul><li>equal (mnemonic: <code>&quot;eq&quot;</code>; integer value: <code>0</code>)</li><li>not equal (mnemonic: <code>&quot;ne&quot;</code>; integer value: <code>1</code>)</li><li>signed less than (mnemonic: <code>&quot;slt&quot;</code>; integer value: <code>2</code>)</li><li>signed less than or equal (mnemonic: <code>&quot;sle&quot;</code>; integer value: <code>3</code>)</li><li>signed greater than (mnemonic: <code>&quot;sgt&quot;</code>; integer value: <code>4</code>)</li><li>signed greater than or equal (mnemonic: <code>&quot;sge&quot;</code>; integer value: <code>5</code>)</li><li>unsigned less than (mnemonic: <code>&quot;ult&quot;</code>; integer value: <code>6</code>)</li><li>unsigned less than or equal (mnemonic: <code>&quot;ule&quot;</code>; integer value: <code>7</code>)</li><li>unsigned greater than (mnemonic: <code>&quot;ugt&quot;</code>; integer value: <code>8</code>)</li><li>unsigned greater than or equal (mnemonic: <code>&quot;uge&quot;</code>; integer value: <code>9</code>)</li></ul><p>The result is <code>1</code> if the comparison is true and <code>0</code> otherwise. For vector or
tensor operands, the comparison is performed elementwise and the element of the
result indicates whether the comparison is true for the operand elements with
the same indices as those of the result.</p><p>Note: while the custom assembly form uses strings, the actual underlying
attribute has integer type (or rather enum class in C++ code) as seen from the
generic assembly form. String literals are used to improve readability of the IR
by humans.</p><p>This operation only applies to integer-like operands, but not floats. The main
reason being that comparison operations have diverging sets of attributes:
integers require sign specification while floats require various floating
point-related particularities, e.g., <code>-ffast-math</code> behavior, IEEE754 compliance,
etc
(<a href=../Rationale.md#splitting-floating-point-vs-integer-operations>rationale</a>).
The type of comparison is specified as attribute to avoid introducing ten
similar operations, taking into account that they are often implemented using
the same operation downstream
(<a href=../Rationale.md#specifying-comparison-kind-as-attribute>rationale</a>). The
separation between signed and unsigned order comparisons is necessary because of
integers being signless. The comparison operation must know how to interpret
values with the foremost bit being set: negatives in two&rsquo;s complement or large
positives
(<a href=../Rationale.md#specifying-sign-in-integer-comparison-operations>rationale</a>).</p><h3 id=constant-operation>&lsquo;constant&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>constant</span><span class=err>`</span> <span class=k>attribute-value </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>The <code>constant</code> operation produces an SSA value equal to some constant specified
by an attribute. This is the way that MLIR uses to form simple integer and
floating point constants, as well as more exotic things like references to
functions and (TODO!) tensor/vector constants.</p><p>The <code>constant</code> operation is represented with a single attribute named &ldquo;value&rdquo;.
The type specifies the result type of the operation.</p><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Integer constant
%1 = constant 42 : i32

// Reference to function @myfn.
%3 = constant @myfn : (tensor&lt;16xf32&gt;, f32) -&gt; tensor&lt;16xf32&gt;

// Equivalent generic forms
%1 = &#34;std.constant&#34;() {value = 42 : i32} : () -&gt; i32
%3 = &#34;std.constant&#34;() {value = @myfn}
   : () -&gt; ((tensor&lt;16xf32&gt;, f32) -&gt; tensor&lt;16xf32&gt;)</code></pre></div><p>MLIR does not allow direct references to functions in SSA operands because the
compiler is multithreaded, and disallowing SSA values to directly reference a
function simplifies this
(<a href=../Rationale.md#multithreading-the-compiler>rationale</a>).</p><h3 id=divis-operation>&lsquo;divis&rsquo; operation</h3><p>Signed integer division. Rounds towards zero. Treats the leading bit as sign,
i.e. <code>6 / -2 = -3</code>.</p><p>Note: the semantics of division by zero or signed division overflow (minimum
value divided by -1) is TBD; do NOT assume any specific behavior.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>divis</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar signed integer division.
%a = divis %b, %c : i64

// SIMD vector element-wise division.
%f = divis %g, %h : vector&lt;4xi32&gt;

// Tensor element-wise integer division.
%x = divis %y, %z : tensor&lt;4x?xi8&gt;</code></pre></div><p>The <code>divis</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><h3 id=diviu-operation>&lsquo;diviu&rsquo; operation</h3><p>Unsigned integer division. Rounds towards zero. Treats the leading bit as the
most significant, i.e. for <code>i16</code> given two&rsquo;s complement representation, <code>6 /
-2 = 6 / (2^16 - 2) = 0</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>diviu</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar unsigned integer division.
%a = diviu %b, %c : i64

// SIMD vector element-wise division.
%f = diviu %g, %h : vector&lt;4xi32&gt;

// Tensor element-wise integer division.
%x = diviu %y, %z : tensor&lt;4x?xi8&gt;</code></pre></div><p>The <code>diviu</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><h3 id=memref-cast-operation>&lsquo;memref_cast&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>memref_cast</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type </span><span class=err>`</span><span class=k>to</span><span class=err>`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Discard static dimension information.
%3 = memref_cast %2 : memref&lt;4x?xf32&gt; to memref&lt;?x?xf32&gt;

// Convert to a type with more known dimensions.
%4 = memref_cast %3 : memref&lt;?x?xf32&gt; to memref&lt;4x?xf32&gt;</code></pre></div><p>Convert a memref from one type to an equivalent type without changing any data
elements. The source and destination types must both be memref types with the
same element type, same mappings, same address space, and same rank. The
operation is invalid if converting to a mismatching constant dimension.</p><h3 id=mulf-operation>&lsquo;mulf&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>mulf</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar multiplication.
%a = mulf %b, %c : f64

// SIMD pointwise vector multiplication, e.g. for Intel SSE.
%f = mulf %g, %h : vector&lt;4xf32&gt;

// Tensor pointwise multiplication.
%x = mulf %y, %z : tensor&lt;4x?xbf16&gt;</code></pre></div><p>The <code>mulf</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be a floating point scalar type, a
vector whose element type is a floating point type, or a floating point tensor.</p><p>It has no standard attributes.</p><p>TODO: In the distant future, this will accept optional attributes for fast math,
contraction, rounding mode, and other controls.</p><h3 id=or-operation>&lsquo;or&rsquo; operation</h3><p>Bitwise integer or.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>or</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar integer bitwise or.
%a = or %b, %c : i64

// SIMD vector element-wise bitwise integer or.
%f = or %g, %h : vector&lt;4xi32&gt;

// Tensor element-wise bitwise integer or.
%x = or %y, %z : tensor&lt;4x?xi8&gt;</code></pre></div><p>The <code>or</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be an integer scalar type, a vector
whose element type is integer, or a tensor of integers. It has no standard
attributes.</p><h3 id=remis-operation>&lsquo;remis&rsquo; operation</h3><p>Signed integer division remainder. Treats the leading bit as sign, i.e. <code>6 %
-2 = 0</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>remis</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar signed integer division remainder.
%a = remis %b, %c : i64

// SIMD vector element-wise division remainder.
%f = remis %g, %h : vector&lt;4xi32&gt;

// Tensor element-wise integer division remainder.
%x = remis %y, %z : tensor&lt;4x?xi8&gt;</code></pre></div><p>The <code>remis</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><h3 id=remiu-operation>&lsquo;remiu&rsquo; operation</h3><p>Unsigned integer division remainder. Treats the leading bit as the most
significant, i.e. for <code>i16</code>, <code>6 % -2 = 6 % (2^16 - 2) = 6</code>.</p><p>Note: the semantics of division by zero is TBD; do NOT assume any specific
behavior.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>remiu</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar unsigned integer division remainder.
%a = remiu %b, %c : i64

// SIMD vector element-wise division remainder.
%f = remiu %g, %h : vector&lt;4xi32&gt;

// Tensor element-wise integer division remainder.
%x = remiu %y, %z : tensor&lt;4x?xi8&gt;</code></pre></div><p>The <code>remiu</code> operation takes two operands and returns one result, each of these
is required to be the same type. This type may be an integer scalar type, a
vector whose element type is integer, or a tensor of integers. It has no
standard attributes.</p><h3 id=select-operation>&lsquo;select&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>select</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`</span><span class=p>,</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Custom form of scalar selection.
%x = select %cond, %true, %false : i32

// Generic form of the same operation.
%x = &#34;std.select&#34;(%cond, %true, %false) : (i1, i32, i32) -&gt; i32

// Vector selection is element-wise
%vx = &#34;std.select&#34;(%vcond, %vtrue, %vfalse)
    : (vector&lt;42xi1&gt;, vector&lt;42xf32&gt;, vector&lt;42xf32&gt;) -&gt; vector&lt;42xf32&gt;</code></pre></div><p>The <code>select</code> operation chooses one value based on a binary condition supplied as
its first operand. If the value of the first operand is <code>1</code>, the second operand
is chosen, otherwise the third operand is chosen. The second and the third
operand must have the same type.</p><p>The operation applies to vectors and tensors elementwise given the <em>shape</em> of
all operands is identical. The choice is made for each element individually
based on the value at the same position as the element in the condition operand.</p><p>The <code>select</code> operation combined with <a href=#cmpi-operation><code>cmpi</code></a> can be used to
implement <code>min</code> and <code>max</code> with signed or unsigned comparison semantics.</p><h3 id=tensor-cast-operation>&lsquo;tensor_cast&rsquo; operation</h3><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>tensor_cast</span><span class=err>`</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type </span><span class=err>`</span><span class=k>to</span><span class=err>`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Convert from unknown rank to rank 2 with unknown dimension sizes.
%2 = &#34;std.tensor_cast&#34;(%1) : (tensor&lt;*xf32&gt;) -&gt; tensor&lt;?x?xf32&gt;
%2 = tensor_cast %1 : tensor&lt;*xf32&gt; to tensor&lt;?x?xf32&gt;

// Convert to a type with more known dimensions.
%3 = &#34;std.tensor_cast&#34;(%2) : (tensor&lt;?x?xf32&gt;) -&gt; tensor&lt;4x?xf32&gt;

// Discard static dimension and rank information.
%4 = &#34;std.tensor_cast&#34;(%3) : (tensor&lt;4x?xf32&gt;) -&gt; tensor&lt;?x?xf32&gt;
%5 = &#34;std.tensor_cast&#34;(%4) : (tensor&lt;?x?xf32&gt;) -&gt; tensor&lt;*xf32&gt;</code></pre></div><p>Convert a tensor from one type to an equivalent type without changing any data
elements. The source and destination types must both be tensor types with the
same element type. If both are ranked, then the rank should be the same and
static dimensions should match. The operation is invalid if converting to a
mismatching constant dimension.</p><h3 id=xor-operation>&lsquo;xor&rsquo; operation</h3><p>Bitwise integer xor.</p><p>Syntax:</p><div class=highlight><pre class=chroma><code class=language-.ebnf data-lang=.ebnf><span class=k>operation </span><span class=err>::</span><span class=o>=</span> <span class=k>ssa-id </span><span class=err>`=`</span> <span class=err>`</span><span class=k>xor</span><span class=err>`</span> <span class=k>ssa-use</span><span class=p>,</span> <span class=k>ssa-use </span><span class=err>`:`</span> <span class=k>type</span></code></pre></div><p>Examples:</p><div class=highlight><pre class=chroma><code class="language-mlir {.mlir}" data-lang="mlir {.mlir}">// Scalar integer bitwise xor.
%a = xor %b, %c : i64

// SIMD vector element-wise bitwise integer xor.
%f = xor %g, %h : vector&lt;4xi32&gt;

// Tensor element-wise bitwise integer xor.
%x = xor %y, %z : tensor&lt;4x?xi8&gt;</code></pre></div><p>The <code>xor</code> operation takes two operands and returns one result, each of these is
required to be the same type. This type may be an integer scalar type, a vector
whose element type is integer, or a tensor of integers. It has no standard
attributes.</p><div class=edit-meta>Last updated on 29 Nov 2019<br>Published on 29 Nov 2019<br><a href=https://github.com/llvm/mlir-www//edit/master/content/docs/Dialects/Standard.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/dialects/spir-v/ title="SPIR-V Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - SPIR-V Dialect</a>
<a class="nav nav-next" href=/docs/dialects/vector/ title="Vector Dialect">Next - Vector Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=open-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/getting_started/>Getting Started</a><ul class=sub-menu><li><a href=/getting_started/faq/>FAQ</a></li><li><a href=/getting_started/developerguide/>Developer Guide</a></li><li><a href=/getting_started/glossary/>Glossary</a></li><li><a href=/getting_started/testingguide/>Testing Guide</a></li></ul></li><li class=parent><a href=/docs/>Docs</a><ul class=sub-menu><li><a href=/docs/tutorials/>Tutorials</a><ul class=sub-menu><li><a href=/docs/tutorials/dialectconversion/>Dialect Conversion</a></li><li><a href=/docs/tutorials/interfaces/>Interfaces</a></li><li><a href=/docs/tutorials/traits/>Introduction to Operation Traits</a></li><li><a href=/docs/tutorials/quickstartrewrites/>Quickstart on Graph Rewrite</a></li><li><a href=/docs/tutorials/toy/>Toy Tutorial</a><ul class=sub-menu><li><a href=/docs/tutorials/toy/ch-1/>Chapter 1: Intro</a></li><li><a href=/docs/tutorials/toy/ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/tutorials/toy/ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/tutorials/toy/ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/tutorials/toy/ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/tutorials/toy/ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/tutorials/toy/ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li></ul></li><li class=parent><a href=/docs/dialects/>Dialect</a><ul class=sub-menu><li><a href=/docs/dialects/affine/>Affine</a></li><li><a href=/docs/dialects/gpu/>GPU Dialect</a></li><li><a href=/docs/dialects/llvm/>LLVM IR Dialect</a></li><li><a href=/docs/dialects/spir-v/>SPIR-V Dialect</a></li><li class=active><a href=/docs/dialects/standard/>Standard Dialect</a></li><li><a href=/docs/dialects/vector/>Vector Dialect</a></li><li><a href=/docs/dialects/affineops/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/dialects/fxpmathops/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/dialects/gpuops/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/dialects/linalgops/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/dialects/loopops/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/dialects/nvvmops/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/dialects/quantops/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/dialects/rocdlops/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/dialects/spirvops/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/dialects/vectorops/>Dialect &#39;vector&#39; definition</a></li></ul></li><li><a href=/docs/design/>Design</a><ul class=sub-menu><li><a href=/docs/design/canonicalization/>Canonicalization</a></li><li><a href=/docs/design/rationalesimplifiedpolyhedralform/>Case for a Simplified Polyhedral Form</a></li><li><a href=/docs/design/rationale/>Design Rationale</a></li><li><a href=/docs/design/diagnostics/>Diagnostics Infrastructure</a></li><li><a href=/docs/design/edsc/>EDSC: Declarative Builders</a></li><li><a href=/docs/design/genericdagrewriter/>Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/design/mlirforgraphalgorithms/>Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/design/quantization/>Quantization</a></li><li><a href=/docs/design/declarativerewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/design/opdefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/design/usageofconst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li></ul></li><li><a href=/docs/conversiontollvmdialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/langref/>Core Specification</a></li><li><a href=/docs/passes/>Passes</a></li><li><a href=/docs/definingattributesandtypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/writingapass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>