<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Dialect &#39;affine&#39; definition - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.59.1"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/AffineOps/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source</a></li></ul></nav></div><div class=content-container><main><h1>Dialect &#39;affine&#39; definition</h1><p>[TOC]</p><h2 id=operation-definition>Operation definition</h2><h3 id=affine-for-affineforop>affine.for (AffineForOp)</h3><p>for operation</p><h4 id=description>Description:</h4><p>The &ldquo;affine.for&rdquo; operation represents an affine loop nest, defining an SSA
value for its induction variable. It has one region capturing the loop body.
The induction variable is represented as a argument of this region. This SSA
value always has type index, which is the size of the machine word. The
stride, represented by step, is a positive constant integer which defaults
to &ldquo;1&rdquo; if not present. The lower and upper bounds specify a half-open range:
the range includes the lower bound but does not include the upper bound.</p><p>The body region must contain exactly one block that terminates with
&ldquo;affine.terminator&rdquo;. Calling AffineForOp::build will create such region
and insert the terminator, so will the parsing even in cases if it is absent
from the custom format.</p><p>The lower and upper bounds of a for operation are represented as an
application of an affine mapping to a list of SSA values passed to the map.
The same restrictions hold for these SSA values as for all bindings of SSA
values to dimensions and symbols. The affine mappings for the bounds may
return multiple results, in which case the max/min keywords are required
(for the lower/upper bound respectively), and the bound is the
maximum/minimum of the returned values.</p><p>Example:</p><p>affine.for %i = 1 to 10 {
&hellip;
}</p><h4 id=operands>Operands:</h4><ol><li>&laquo;unnamed&raquo;: any type</li></ol><h4 id=attributes>Attributes:</h4><h4 id=results>Results:</h4><h3 id=affine-if-affineifop>affine.if (AffineIfOp)</h3><p>if-then-else operation</p><h4 id=description-1>Description:</h4><p>The &ldquo;if&rdquo; operation represents an if-then-else construct for conditionally
executing two regions of code. The operands to an if operation are an
IntegerSet condition and a set of symbol/dimension operands to the
condition set. The operation produces no results. For example:</p><p>affine.if #set(%i) {
&hellip;
} else {
&hellip;
}</p><p>The &lsquo;else&rsquo; blocks to the if operation are optional, and may be omitted. For
example:</p><p>affine.if #set(%i) {
&hellip;
}</p><h4 id=operands-1>Operands:</h4><ol><li>&laquo;unnamed&raquo;: any type</li></ol><h4 id=attributes-1>Attributes:</h4><h4 id=results-1>Results:</h4><h3 id=affine-min-affineminop>affine.min (AffineMinOp)</h3><p>min operation</p><h4 id=description-2>Description:</h4><p>The &ldquo;min&rdquo; operation computes the minimum value result from a multi-result
affine map.</p><p>Example:</p><p>%0 = affine.min (d0) -&gt; (1000, d0 + 512) (%i0) : index</p><h4 id=operands-2>Operands:</h4><ol><li><code>operands</code>: index</li></ol><h4 id=attributes-2>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>map</code></td><td align=center><code>AffineMapAttr</code></td><td>AffineMap attribute attribute</td></tr></tbody></table><h4 id=results-2>Results:</h4><ol><li>&laquo;unnamed&raquo;: index</li></ol><h3 id=affine-prefetch-affineprefetchop>affine.prefetch (AffinePrefetchOp)</h3><p>affine prefetch operation</p><h4 id=description-3>Description:</h4><p>The &ldquo;affine.prefetch&rdquo; op prefetches data from a memref location described
with an affine subscript similar to affine.load, and has three attributes:
a read/write specifier, a locality hint, and a cache type specifier as shown
below:</p><p>affine.prefetch %0[%i, %j + 5], read, locality<3>, data
: memref<400x400xi32></p><p>The read/write specifier is either &lsquo;read&rsquo; or &lsquo;write&rsquo;, the locality hint
specifier ranges from locality<0> (no locality) to locality<3> (extremely
local keep in cache). The cache type specifier is either &lsquo;data&rsquo; or &lsquo;instr&rsquo;
and specifies whether the prefetch is performed on data cache or on
instruction cache.</p><h4 id=operands-3>Operands:</h4><ol><li><code>memref</code>: memref of any type values</li><li><code>indices</code>: index</li></ol><h4 id=attributes-3>Attributes:</h4><table><thead><tr><th align=center>Attribute</th><th align=center>MLIR Type</th><th>Description</th></tr></thead><tbody><tr><td align=center><code>isWrite</code></td><td align=center><code>BoolAttr</code></td><td>bool attribute attribute</td></tr><tr><td align=center><code>localityHint</code></td><td align=center><code>IntegerAttr</code></td><td>32-bit integer attribute whose minimum value is 0 whose maximum value is 3 attribute</td></tr><tr><td align=center><code>isDataCache</code></td><td align=center><code>BoolAttr</code></td><td>bool attribute attribute</td></tr></tbody></table><h4 id=results-3>Results:</h4><h3 id=affine-terminator-affineterminatorop>affine.terminator (AffineTerminatorOp)</h3><p>affine terminator operation</p><h4 id=description-4>Description:</h4><p>Affine terminator is a special terminator operation for blocks inside affine
loops and branches. It unconditionally transmits the control flow to the
successor of the operation enclosing the region.</p><p>This operation does <em>not</em> have a custom syntax. However, affine control
operations omit the terminator in their custom syntax for brevity.</p><h4 id=operands-4>Operands:</h4><h4 id=attributes-4>Attributes:</h4><h4 id=results-4>Results:</h4><div class=edit-meta>Last updated on 1 Jan 1970<br>Published on 1 Jan 1970<br><a href=https://github.com/llvm/mlir-www//edit/master/website/content/docs/Dialects/AffineOps.md class=edit-page><i class="fas fa-pen-square"></i>Edit on GitHub</a></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/Affine/ title="Affine Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - Affine Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/FxpMathOps/ title="Dialect 'fxpmath' definition">Next - Dialect &#39;fxpmath&#39; definition <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li class=active><a href=/docs/Dialects/AffineOps/>Dialect &#39;affine&#39; definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect &#39;fxpmath&#39; definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect &#39;gpu&#39; definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect &#39;linalg&#39; definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect &#39;loop&#39; definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect &#39;nvvm&#39; definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect &#39;quant&#39; definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect &#39;rocdl&#39; definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect &#39;spv&#39; definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect &#39;vector&#39; definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li><a href=/docs/Dialects/Linalg/>Linalg Dialect</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR&#39;s Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of &#39;Const&#39; in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>