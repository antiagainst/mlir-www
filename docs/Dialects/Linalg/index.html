<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>Linalg Dialect: The Case For Compiler-Friendly Custom Operations - MLIR</title><meta name=description content="Multi-Level IR Compiler Framework"><meta name=generator content="Hugo 0.63.2"><link href=https://mlir.llvm.org/index.xml rel=alternate type=application/rss+xml><link rel=canonical href=https://mlir.llvm.org/docs/Dialects/Linalg/><link rel=stylesheet href=https://mlir.llvm.org/css/theme.css><script src=https://use.fontawesome.com/releases/v5.0.6/js/all.js></script><link rel=stylesheet href=https://mlir.llvm.org/css/chroma.min.css><script src=https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js></script><script src=https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js></script><script src=https://mlir.llvm.org/js/bundle.js></script><style>:root{}</style></head><body><div class=container><header><h1><div><img src=https://mlir.llvm.org//mlir-logo.png width=40px align=absmiddle>
MLIR</div></h1><p class=description>Multi-Level IR Compiler Framework</p></header><div class=global-menu><nav><ul><li class=parent><a href>Community<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=https://llvm.discourse.group/c/llvm-project/mlir>Forums</a></li><li class=child><a href=https://discord.gg/JUQUPAZ>Chat</a></li></ul></li><li><a href=/getting_started/Faq/>FAQ</a></li><li class=parent><a href=https://github.com/llvm/llvm-project/tree/master/mlir>Source<i class="fas fa-angle-right"></i></a><ul class=sub-menu><li class=child><a href=doxygen/>Doxygen</a></li><li class=child><a href=https://github.com/llvm/llvm-project/tree/master/mlir>GitHub</a></li></ul></li><li><a href="https://bugs.llvm.org/buglist.cgi?bug_status=__open__&list_id=177877&order=changeddate%20DESC%2Cpriority%2Cbug_severity&product=MLIR&query_format=specific">Bugs</a></li></ul></nav></div><div class=content-container><main><h1>Linalg Dialect: The Case For Compiler-Friendly Custom Operations</h1><p>Table of contents:</p><ol><li><a href=#introduction>Introduction: Inception and Evolution</a></li><li><a href=#prior_art>Prior Art</a><ol><li><a href=#lessonsonnx>Lessons from ONNX</a></li><li><a href=#lessonslift>Lessons from LIFT</a></li><li><a href=#lessonsxla>Lessons from XLA</a></li><li><a href=#lessonshalide>Lessons from Halide and TVM</a></li><li><a href=#lessonspolyhedral>Lessons from Polyhedral compilers</a></li><li><a href=#lessonsaffine>Lessons from the Affine dialect</a></li></ol></li><li><a href=#guiding_principles>Core Guiding Principles</a><ol><li><a href=#transformations_first>Transformations and Simplicity First</a></li><li><a href=#information_preservation>Preservation of Information</a><ul><li><a href=#declarative_specification>Declarative Specification: Avoid Raising</a></li><li><a href=#progressive_lowering>Progressive Lowering: Don&rsquo;t Lose Information too Quickly</a></li></ul></li><li><a href=#declarative_transformations>Composable and Declarative Transformations</a></li><li><a href=#suitability_for_search>Suitability for Search and Machine Learning</a></li><li><a href=#future>Extensibility and Future-Proofness</a></li></ol></li><li><a href=#keyobservation>Key Observations</a><ol><li><a href=#data_and_compute>Algorithms + Data Structures = Programs</a></li><li><a href=#preserving_structure>Preserving Structure in the IR</a></li><li><a href=#dialect_not_closed>Dialect Needs Not Be Closed Under Transformations</a></li></ol></li><li><a href=#keyobservation>Key Design Decisions</a></li><li><a href=#key_transformations>Set of Key Transformations</a></li><li><a href=#linalg_ops>High-Level Description of Linalg Ops</a><ol><li><a href=#payload_ops>Payload-Carrying Ops</a><ol><li><a href=#prop1>Property 1: Input and Output Operands Define The Iteration Space</a></li><li><a href=#prop2>Property 2: Reversible Mappings Between Control and Data Structures</a></li><li><a href=#prop3>Property 3: The Type Of Iterators is Defined Explicitly</a></li><li><a href=#prop4>Property 4: The Compute Payload is Specified With a Region</a></li><li><a href=#prop5>Property 5: May Map To an External Library Call</a></li><li><a href=#prop6>Property 6: Perfectly Nested Writes To The Whole Output Operands</a></li><li><a href=#summary>Putting it Together</a></li></ol></li><li><a href=#views>Data Representation: Views</a></li><li><a href=#metadata_ops>Metadata Ops</a></li><li><a href=#named_ops>Named Payload-Carrying Ops</a></li></ol></li><li><a href=#open_issues>Open Issues and Design Alternatives</a></li></ol><h2 id=positioning>Positioning</h2><img width=200 align=left alt="Linalg High-Level Codegen Flow" src=https://user-images.githubusercontent.com/10148468/73235093-e8fd5500-415a-11ea-8db7-71d56a14e5dc.png><p>In his latest MLIR Open Design meeting presentation, Chris laid out a compelling
<a href=https://drive.google.com/corp/drive/folders/1C3SEjO4u9E0UB2IwztSxaovFTSATDxT6>vision</a>
for an MLIR-based codegen that would make the best use of the multi-level properties of
the infrastructure and be driven by search. The MLIR Linalg dialect aims at bringing an answer
to the higher-level codegen problem. This document describes the key design principles
that led to the existing implementation of Linalg and aims at exposing the tradeoffs
involved when building higher-level Intermediate Representations (IR) and Dialects to
facilitate code generation. Linalg is designed to interoperate nicely within a
<em>Mixture Of Expert Compilers</em> environment (i.e. the <em>CGSel</em> box).</p><p>This work is inspired by a wealth of
<a href=#prior_art>prior art</a>
in
the field, from which it seeks to learn key lessons. This documentation
and introspection effort also comes in the context of the proposal for a
working group for discussing the
<a href=https://llvm.discourse.group/t/development-of-high-level-tensor-compute-primitives-dialect-s-and-transformations/388/3>Development of high-level Tensor Compute
Primitives dialect(s) and
transformations</a>
.
We hope that the lessons from prior art, the design principles outlined in
this doc and the architecture of Linalg can help inform the community on a
path to defining these High-Level Tensor Compute Primitives.</p><h2 id=inception>Inception</h2><p>Linalg started as a pragmatic dialect to bootstrap code generation in MLIR, by
<em>defining away</em> complex code generation problems like precise dependence
analysis or polyhedral code generation and by introducing the ability to call
into fast library implementations when available. Linalg <strong>defines ops and
transformations declaratively</strong> and was originally restricted to ops with
<em>linear-algebra like</em> semantics (<code>pointwise</code>, <code>matmul</code>, <code>conv</code>&mldr;). This
approach enables building a high-level productivity-first codegen solution that
leverages <em>both</em> compiler optimizations <em>and</em> efficient library implementations
so as not to miss out on simple performance benefits. For example, if
one&rsquo;s favorite HPC library or ISA has a <code>matmul</code> primitive running at 95% of
the achievable peak performance, for operands stored in some memory, one should
be able to <strong>use the primitive</strong> when possible <em>and</em> generate code otherwise.</p><p>However, as the design of Linalg co-evolved with the design of MLIR, it became
apparent that it could extend to larger application domains than just machine
learning on dense tensors.</p><p>The design and evolution of Linalg follows a <em>codegen-friendly</em> approach where
the IR and the transformations evolve hand-in-hand.
The key idea is that op semantics <em>declare</em> and transport information that is
traditionally obtained by compiler analyses.
This information captures the legality and applicability of transformations and
is <strong>not lost by lowering prematurely to loop or CFG form</strong>. The key
transformations are designed so as to <strong>preserve this information</strong> as long as
necessary. For example, <code>linalg.matmul</code> remains <code>linalg.matmul</code> after tiling
and fusion.</p><p>Furthermore, Linalg decouples transformation validity from profitability
considerations and voluntarily leaves the latter aside in the first iteration
(see the
<a href=#suitability_for_search>suitability for search</a>
guiding principle).</p><p>The first incarnation of these ideas was presented as an example at the
EuroLLVM 2019 developer&rsquo;s meeting as part of the
<a href=https://llvm.org/devmtg/2019-04/slides/Tutorial-AminiVasilacheZinenko-MLIR.pdf>Linalg section</a>
of the first
<a href="https://www.youtube.com/watch?v=cyICUIZ56wQ">MLIR Tutorial</a>
.</p><h2 id=evolution>Evolution</h2><p>Since the initial implementation, the design has evolved with, and partially
driven the evolution of the core MLIR infrastructure to use
<a href=https://mlir.llvm.org/docs/LangRef/#regions>Regions</a>
,
<a href=https://mlir.llvm.org/docs/Interfaces/>OpInterfaces</a>
,
<a href=https://mlir.llvm.org/docs/OpDefinitions/>ODS</a>
and
<a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Declarative Rewrite Rules</a>
among others. The approach adopted by Linalg was extended to become
<a href=https://drive.google.com/drive/u/0/folders/1sRAsgsd8Bvpm_IxREmZf2agsGU2KvrK->StructuredOps abstractions</a>
,
with Linalg becoming its incarnation on tensors and buffers.
It is complemented by the
<a href=https://mlir.llvm.org/docs/Dialects/Vector/>Vector dialect</a>
,
which define structured operations on vectors, following the same rationale and
design principles as Linalg. (Vector dialect includes the higher-level
operations on multi-dimensional vectors and abstracts away the lowering to
single-dimensional vectors).</p><p>The Linalg dialect itself grew beyond linear algebra-like operations to become
more expressive, in particular by providing an abstraction of a loop nest
supporting parallelism, reductions and sliding windows around arbitrary MLIR
<a href=https://mlir.llvm.org/docs/LangRef/#regions>regions</a>
. It also has the
potential of growing beyond <em>dense</em> linear-algebra to support richer data
types, such as sparse and ragged tensors and buffers.</p><p>Linalg design remains open to evolution and cross-pollination with other
dialects and approaches. It has been successfully used as the staging ground
for code generation-related abstractions, spinning off the generalization of
the following:</p><ul><li>the <code>!linalg.view</code> type folded into the <em>&ldquo;Strided MemRef&rdquo;</em> type while
preserving structure to allow calling into external C++ libraries with
unsurprising ABI conventions;</li><li>the <code>linalg.view</code> and <code>linalg.subview</code> ops evolved into the standard dialect;</li><li>the <code>linalg.for</code>, <code>linalg.load</code> and <code>linalg.store</code> ops evolved into a prelude
to the <em>structured control flow</em> dialect (currently still named <code>LoopOps</code>).
More components can be extracted, redesigned and generalized when new uses or
requirements arise.</li></ul><p>Several
<a href=#open_issues>design questions</a>
remain open in Linalg, which does not
claim to be a general solution to all compilation problems.
It does aim at driving thinking and implementations of domain-specific
abstractions where programmer&rsquo;s intent can be captured at a very high level,
directly in the IR.</p><p>Given the evolution of the scope, it becomes apparent that a better name than
&ldquo;Linalg&rdquo; could remove some of the confusions related to the dialect (and the
underlying approach), its goals and limitations.</p><p>Linalg draws inspiration from decades of prior art to design a modern a
pragmatic solution. The following non-exhaustive list refers to some of the
projects that influenced Linalg design:</p><ul><li><a href=https://onnx.ai/>ONNX</a>
,</li><li><a href=https://www.lift-project.org/>LIFT</a>
,</li><li><a href=https://www.tensorflow.org/xla/architecture>XLA</a>
,</li><li><a href=https://halide-lang.org/>Halide</a>
and
<a href=https://tvm.apache.org/>TVM</a>
,</li><li><a href=http://tensor-compiler.org/>TACO</a>
,</li><li><a href=http://darkroom-lang.org/>Darkroom</a>
and
<a href=http://terralang.org/>Terra</a>
,</li><li><a href=http://spiral.ece.cmu.edu:8080/pub-spiral/pubfile/cgo16-preprint_248.pdf>Sigma-LL</a>
,</li><li><a href=https://research.fb.com/blog/2018/02/announcing-tensor-comprehensions/>Tensor Comprehensions</a>
,</li><li><a href=https://en.wikipedia.org/wiki/Polytope_model>Polyhedral Compilers</a>
,</li><li>the
<a href=https://mlir.llvm.org/docs/Dialects/Affine/>Affine dialect</a>
in MLIR,</li><li>Generic Loop Transformations (see Ken Kennedy&rsquo;s
<a href=https://www.elsevier.com/books/optimizing-compilers-for-modern-architectures/allen/978-0-08-051324-9>Optimizing Compilers for Modern Architectures</a>
)</li><li>Traditional compiler CFGs with SSA forms.</li></ul><p>Additionally, experience with the following tools proved very valuable when
thinking holistically about how all these components interplay all the way
up to the user and down to the hardware:</p><ul><li>the
<a href=http://torch.ch/>Torch</a>
machine-learning framework,</li><li>the LLVM compiler, specifically in JIT mode,</li><li>high-performance libraries (MKL, CUBLAS, FBFFT)</li><li>the
<a href=https://www.cs.utexas.edu/users/flame/BLISRetreat/BLISRetreatTalks/PeachPy.pdf>PeachPy</a>
assembler</li><li>current and potentially upcoming hardware ISAs.</li></ul><p>The novelty of MLIR&rsquo;s code base and its unprecedented support for defining and
mixing abstractions, enabling one to reflect on and integrate the key elements
of the prior art success as well as avoid the common pitfalls in the area of
code generation. Thus, instead of diverging into a discussion about the
implications of adopting any of the existing solutions, Linalg had the
possibility to build on all of them and learn from their experience while
leveraging the benefit of hindsight.</p><p>The following reflections on prior art have influenced the design of Linalg.
The discussion is by no means exhaustive but should capture the key motivations
behind Linalg.</p><h2 id=lessons-from-onnxa-namelessonsonnxa>Lessons from ONNX<a name=lessonsonnx></a></h2><p>ONNX is a specification of operations that appear in Machine Learning
workloads. As such, it is predominantly driven by the expressiveness requirements
of ML, and less by the considerations of IR design for HPC code generation.</p><p>Similarly to ONNX, Linalg defines <em>&ldquo;semantically charged&rdquo; named ops</em>.
But it also considers <em>transformations on these ops</em> as a key component and
defines the IR to support the transformations, preferring transformations over
expressiveness if necessary.</p><p>Linalg hopes to additionally address the following:</p><ul><li>facilitate frontend-compiler co-design by taking into account compiler
transformations and lowerings in op definition;</li><li>minimize the set of available ops by making them non-overlapping with each
other, thus simplifying the intermediate representation.</li></ul><h2 id=lessons-from-lifta-namelessonslifta>Lessons from LIFT<a name=lessonslift></a></h2><p><a href=https://www.lift-project.org/>LIFT</a>
is a system to write computational
kernels based on functional abstractions. Transformations are
represented by additional nodes in the IR, whose semantics are at the
level of the algorithm (e.g. <code>partialReduce</code>).
LIFT applies and composes transformations by using
<a href=https://www.lift-project.org/presentations/2015/ICFP-2015.pdf>local rewrite
rules</a>
that
embed these additional nodes directly in the functional abstraction.</p><p>Similarly to LIFT, Linalg uses local rewrite rules implemented with the MLIR
<a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>Declarative Rewrite Rules</a>
mechanisms.</p><p>Linalg builds on, and helps separate concerns in the LIFT approach as follows:</p><ul><li>transformations are either separated from the representation or expressed as
composable attributes that are independent of the actual computation,
avoiding intricate effects on performance;</li><li>abstractions are split into smaller components (e.g., control flow and data
structure abstractions) potentially reusable across different dialects in the
MLIR&rsquo;s open ecosystem.</li></ul><p>LIFT is expected to further influence the design of Linalg as it evolve. In
particular, extending the data structure abstractions to support non-dense
tensors can use the experience of LIFT abstractions for
<a href=https://www.lift-project.org/publications/2016/harries16sparse.pdf>sparse</a>
and
<a href=https://www.lift-project.org/publications/2019/pizzuti19positiondependentarrays.pdf>position-dependent
arrays</a>
.</p><h2 id=lessons-from-xlaa-namelessonsxlaa>Lessons from XLA<a name=lessonsxla></a></h2><p><a href=https://www.tensorflow.org/xla/architecture>XLA</a>
is one of the first
post-Theano ML compilers that was introduced as a pragmatic compilation
solution for TensorFlow. It shines on Google&rsquo;s xPU
hardware and is an important piece of the puzzle. It is particularly good at
(1) transforming code back and forth between the scalar and the vector
worlds, (2) passing function boundaries for handling both host and device
code, and (3) complying to stringent requirements imposed by energy-efficient
xPUs.
XLA followed a pragmatic design process where the compiler is given perfect
knowledge of each op&rsquo;s semantic, all starting from the mighty <code>conv</code> and
<code>matmul</code> ops. XLA transformations consist of writing emitters that compose, as C++
functions. Perfect op semantics knowledge has 2 big benefits: (1) transformations are
correct by construction (2) very strong performance on difficult xPU targets.</p><p>Similarly, Linalg ops <em>&ldquo;know their semantics&rdquo;</em> and <em>&ldquo;know how to transform and
lower themselves&rdquo;</em>. The means by which this information is made available and
how it is used in MLIR are, however, very different.</p><p>Linalg hopes to additionally address the following:</p><ul><li>HLOs are expressive as a whole, but each op has very limited and fixed
semantics: ops are not configurable. As a consequence, HLOs have evolved into
a too large set of ops whose semantics intersect.
This echoes the ops proliferation problem also exhibited by ONNX.</li><li>Reliance on perfect op knowledge leads to situations where transformations and
ops end up needing to know about each other&rsquo;s semantics (e.g. during fusion).
Since the transformations themselves are not simple local rewrite patterns
(unlike LIFT), code complexity grows quickly.</li><li>XLA lacks an independent IR that can be inspected, unit tested and used
independently. This monolithic design makes the system not portable: xPU passes
and GPU passes do not share much code.</li></ul><h2 id=lessons-from-halide-and-tvma-namelessonshalidea>Lessons from Halide and TVM<a name=lessonshalide></a></h2><p><a href=https://halide-lang.org/>Halide</a>
is a DSL embedded in C++ that provides a
way of metaprogramming the HalideIR and applying transformations declaratively
to let the expert user transform and optimize the program in tailored ways.
Halide, initially targeted the SIGGRAPH community but is now more generally
applicable.
<a href=https://tvm.apache.org/>TVM</a>
is an evolution of Halide into the
machine learning and deep-neural network space, based on HalideIR.</p><p>The Halide transformation methodology follows similar principles to the
<a href=http://icps.u-strasbg.fr/~bastoul/research/papers/GVBCPST06-IJPP.pdf>URUK</a>
and
<a href=https://pdfs.semanticscholar.org/6a46/20589f63f3385707d2d590f7b7dc8ee4d74f.pdf>CHiLL</a>
compiler transformation frameworks, but without the strengths (and especially
complexity) of the polyhedral model.</p><p>Halide particularly shines at making the HPC transformation methodology
accessible to $\Omega$(10-100) users, at a time when polyhedral tools are
still only accessible to $\Omega$(1-10) users. Halide makes heavy usage of
canonicalization rules that are also very prevalent in MLIR.</p><p>Linalg hopes to additionally address the following:</p><ul><li>Halide scheduling is powerful and explores a large swath of possible
transformations. But it&rsquo;s still too hard for newcomers to use or extend. The
level of performance you get from Halide is very different depending on
whether one is a seasoned veteran or a newcomer. This is especially true as
the number of transformations grow.</li><li>Halide raises rather than lowers in two ways, going counter-current to the
design goals we set for high-level codegen abstractions in in MLIR. First,
canonical Halide front-end code uses explicit indexing and math on scalar
values, so to target BLAS/DNN libraries one needs to add pattern matching
which is similarly brittle as in the affine case. While Halide&rsquo;s performance
is on par with the libraries on programmable targets (CPU/GPU), that
approach doesn&rsquo;t work on mobile accelerators or on xPUs, where the framework
ingests whole-tensor operations.
Second, reductions and scans are expressed using serial iteration, again
requiring pattern matching before they can be transformed (e.g. to do a
reduction using atomics, or hierarchically). The lesson to draw is that we
should start with higher-level primitives than Halide.</li></ul><p>Lessons from Polyhedral compilers<a name=lessonspolyhedral></a>
The polyhedral model has been on the cutting edge of loop-level optimization for
decades, with several incarnations in production compilers such as
<a href=https://gcc.gnu.org/wiki/Graphite>GRAPHITE</a>
for GCC and
<a href=https://polly.llvm.org>Polly</a>
for LLVM. Although it has proved crucial to
generate efficient code from domain-specific languages such as
<a href=http://mcl.csa.iisc.ac.in/polymage.html>PolyMage</a>
and
<a href=https://dl.acm.org/doi/abs/10.1145/3355606>Tensor
Comprehensions</a>
, it has never been
fully included into mainstream general-purpose optimization pipelines. Detailed
analysis of the role of polyhedral transformations is provided in the
<a href=https://mlir.llvm.org/docs/RationaleSimplifiedPolyhedralForm/>simplified polyhedral
form</a>
document
dating back to the inception of MLIR.</p><p>In particular, polyhedral abstractions have proved challenging to integrate with
a more conventional compiler due to the following.</p><ul><li>The transformed code (or IR) quickly gets complex and thus hard to analyze and
understand.</li><li>Code generation from the mathematical form used in the polyhedral model relies
on non-trivial exponentially complex algorithms.</li><li>The mathematical form is rarely composable with the SSA representation and
related algorithms, on which most mainstream compilers are built today.</li><li>Expressiveness limitations, although addressed in the scientific literature
through, e.g., summary functions, often remain present in actual
implementations.</li></ul><p>The Affine dialect in MLIR was specifically designed to address the integration
problems mention above. In particular, it maintains the IR in the same form
(loops with additional constraints on how the bounds are expressed) throughout
the transformation, decreasing the need for one-shot conversion between
drastically different representations. It also embeds the polyhedral
representation into the SSA form by using MLIR regions and thus allows one to
combine polyhedral and SSA-based transformations.</p><h2 id=lessons-from-the-affine-dialecta-namelessonsaffinea>Lessons from the Affine dialect<a name=lessonsaffine></a></h2><p>The Affine dialect in MLIR brings the polyhedral abstraction closer to the
conventional SSA representation. It addresses several long-standing integration
challenges as described above and is likely to be more suitable when compiling
from a C language-level abstraction.</p><p>MLIR makes it possible to start from a higher-level abstraction than C, for
example in machine learning workloads. In such cases, it may be possible to
avoid complex analyses (data-flow analysis across loop iterations is
exponentially complex) required for polyhedral transformation by leveraging the
information available at higher levels of abstractions, similarly to DSL
compilers. Linalg intends to use this information when available and ensure
<em>legality of transformations by construction</em>, by integrating legality
preconditions in the op semantics (for example, loop tiling can be applied to
the loop nest computing a matrix multiplication, no need to additionally rely on
affine dependence analysis to check this). This information is not readily
available in the Affine dialect, and can only be derived using potentially
expensive pattern-matching algorithms.</p><p>Informed by the practical experience in polyhedral compilation and with the
Affine dialects in particular, Linalg takes the following decisions.</p><ul><li><strong>Discourage loop skewing</strong>: the loop skewing transformation, that is
sometimes used to enable parallelization, often has surprising (negative)
effects on performance. In particular, polyhedral auto-transformation can be
expressed in a simpler way without loop skewing; skewing often leads to
complex control flow hampering performance on accelerators such as GPUs.
Moreover, the problems loop skewing addresses can be better addressed by other
approaches, e.g., diamond tiling. In the more restricted case of ML workloads,
multi-for loops with induction variables independent of each other (referred
to as hyper-rectangular iteration domains in the literature) such as the
proposed
[affine.parallel]((<a href=https://llvm.discourse.group/t/rfc-add-affine-parallel/350>https://llvm.discourse.group/t/rfc-add-affine-parallel/350</a>)
are sufficient in the majority of cases.</li><li><strong>Declarative Tiling</strong>: the <em>tiling</em> transformation is ubiquitous in HPC code
generation. It can be seen as a decomposition of either the iteration space or
the data space into smaller regular parts, referred to as tiles. Polyhedral
approaches, including the Affine dialect, mostly opt for iteration space
tiling, which introduces additional control flow and complex address
expressions. If the tile sizes are not known during the transformation (so
called parametric tiling), the address expressions and conditions quickly
become non-affine or require exponentially complex algorithms to reason about
them. Linalg focuses tiling on the data space instead, creating views into the
buffers that leverage MLIR&rsquo;s strided <code>memref</code> abstraction. These views compose
and the complexity of access expressions remains predictable.</li><li><strong>Preserve high-level information</strong>: Linalg maintains the information provided
by the op semantics as long as necessary for transformations. For example, the
result of tiling a matrix multiplication is loops around a smaller matrix
multiplication. Even with pattern-matching on top of the Affine dialect, this
would have required another step of pattern-matching after the transformation.</li></ul><p>Given these choices, Linalg intends to be a better fit for <strong>high-level
compilation</strong> were significantly more information is readily available in the
input representation and should be leveraged before lowering to other
abstractions. Affine remains a strong abstraction for mid-level transformation
and is used as a lowering target for Linalg, enabling further transformations
and combination of semantically-loaded and lower-level inputs. As such, Linalg
is intended to complement Affine rather than replace it.</p><h2 id=transformations-and-simplicity-firsta-nametransformations_firsta>Transformations and Simplicity First<a name=transformations_first></a></h2><p>The purpose of the Linalg IR and its operations is primarily to (1) develop a
set of key transformations and (2) make them correct by construction (3) make
them very simple to implement, apply, verify and especially maintain.
The problem at hand is fundamentally driven by compilation of domain-specific
workloads for high-performance and parallel hardware architectures: <strong>this is
an HPC compilation problem</strong>.</p><p>The selection of relevant transformations follows a codesign approach and
involves considerations related to:</p><ul><li>concrete current and future needs of the application domain,</li><li>concrete current and future hardware properties and ISAs,</li><li>understanding of strengths and limitations of
<a href=#prior_art>existing approaches</a>
,</li><li>taking advantage of the coexistence of multiple levels of IR in MLIR,</li></ul><p>One needs to be methodical to avoid proliferation and redundancy. A given
transformation could exist at multiple levels of abstraction but <strong>just
because one can write transformation X at level Y absolutely does not mean
one should</strong>. This is where evaluation of existing
systems and acknowledgement of their strengths and weaknesses is crucial:
simplicity and maintainability aspects must be first-order concerns. Without
this additional effort of introspection, a design will not stand the test of
time. At the same time, complexity is very hard to ward off. It seems one needs
to suffer complexity to be prompted to take a step back and rethink
abstractions.</p><p>This is not merely a reimplementation of idea X in system Y: simplicity
<strong>must be the outcome</strong> of this introspection effort.</p><h2 id=preservation-of-informationa-nameinformation_preservationa>Preservation of Information<a name=information_preservation></a></h2><p>The last two decades have seen a proliferation of Domain-Specific Languages
(DSLs) that have been very successful at limited application domains.
The main commonality between these systems is their use of a significantly
richer structural information than CFGs or loops.
Still, another commonality of existing systems is to lower to LLVM very quickly,
and cross a wide abstraction gap in a single step. This process often drops
semantic information that will later needs to be reconstructed,
when it is not irremediably lost.</p><p>These remarks, coupled with MLIR&rsquo;s suitability for defining IR at multiple
levels of abstraction led to the following 2 principles.</p><h3 id=declarative-specification-avoid-raisinga-namedeclarative_specificationa>Declarative Specification: Avoid Raising<a name=declarative_specification></a></h3><p>Compiler transformations need static structural information (e.g. loop-nests,
graphs of basic blocks, pure functions etc). When that structural information
is lost, it needs to be reconstructed.</p><p>A good illustration of this phenomenon is the notion of <em>raising</em> in polyhedral
compilers: multiple polyhedral tools start by raising from a simplified C
form or from SSA IR into a higher-level representation that is more amenable
to loop transformations.</p><p>In advanced polyhedral compilers, a second type of raising
may typically exist to detect particular patterns (often variations of
BLAS). Such patterns may be broken by transformations making their detection
very fragile or even just impossible (incorrect).</p><p>MLIR makes it easy to define op semantics declaratively thanks to the use of
regions and attributes. This is an ideal opportunity to define new abstractions
to convey user-intent directly into the proper abstraction.</p><h3 id=progressive-lowering-dont-lose-information-too-quicklya-nameprogressive_loweringa>Progressive Lowering: Don&rsquo;t Lose Information too Quickly<a name=#progressive_lowering></a></h3><p>Lowering too quickly to affine, generic loops or CFG form reduces the
amount of structure available to derive transformations from. While
manipulating loops is a net gain compared to CFG form for a certain class of
transformations, important information is still lost (e.g. parallel loops, or
mapping of a loop nest to an external implementation).</p><p>This creates non-trivial phase ordering issues. For instance, loop fusion may
easily destroy the ability to detect a BLAS pattern. One possible alternative
is to perform loop fusion, tiling, intra-tile loop distribution and then hope to
detect the BLAS pattern. Such a scheme presents difficult phase-ordering
constraints that will likely interfere with other decisions and passes.
Instead, certain Linalg ops are designed to maintain high-level information
across transformations such as tiling and fusion.</p><h2 id=composable-and-declarative-transformationsa-namedeclarative_transformationsa>Composable and Declarative Transformations<a name=declarative_transformations></a></h2><p>Complex and impactful transformations need not be hard to manipulate, write or
maintain. Mixing XLA-style high-level op semantics knowledge with generic
properties to describe these semantics, directly in MLIR, is a promising way to:</p><ul><li>Design transformations that are (1) correct by construction, (2) easy to
write, (3) easy to verify and (4) easy to maintain.</li><li>Provide a way to specify transformations and the units of IR they manipulate
declaratively. In turn this allows using local pattern rewrite rules in MLIR
(i.e.
<a href=https://mlir.llvm.org/docs/DeclarativeRewrites/>DRR</a>
).</li><li>Allow creating customizable passes declaratively by simply selecting rewrite
rules. This allows mixing transformations, canonicalizations, constant folding
and other enabling rewrites in a single pass. The result is a system where pass
fusion is very simple to obtain and gives hope to solving certain
<a href=https://dl.acm.org/doi/10.1145/201059.201061>phase ordering issues</a>
.</li></ul><h2 id=suitability-for-search-and-machine-learninga-namemla>Suitability for Search and Machine Learning<a name=ml></a></h2><p>The concept of compiler heuristics bears similarities to hand-crafted
human-engineered features: it is ripe for disruption by machine-learning
techniques. To enable search, compiler transformations should be fine-grained,
<a href=#declarative_transformations>composable</a>
and expose tuning parameters that
can modify their behavior. Previous experience with Tensor Comprehensions showed
that, fixing a few predefined strategies with parametric transformations and
tuning knobs, can already provide great results. In that previous work, simple
genetic search was sufficient. This requires code versions obtainable by the
various transformations to encompass versions that get close to the roofline
limit.</p><p>Of course, we are not advocating for using ML everywhere in the stack
immediately: low-level compilation and machine models are still quite performant
in LLVM. However, for the high-level and mid-level optimization problems,
models need to be conditioned on the low-level compiler which acts as a
blackbox. For these reasons we prioritize the design of IR and transformations
with search-friendly properties over building cost models.</p><h2 id=extensibility-and-future-proofnessa-namefuturea>Extensibility and Future-Proofness<a name=future></a></h2><p>MLIR defines IR for structured control flow and structured data types. In
particular, the <code>MemRefType</code> represents dense non-contiguous memory regions.
This structure should extend beyond simple dense data types and generalize to
ragged, sparse and mixed dens/sparse tensors as well as to trees, hash tables,
tables of records and maybe even graphs.</p><p>For such more advanced data types, the control-flow required to traverse the
data structures, termination conditions etc are much less simple to analyze and
characterize statically. As a consequence we need to also design solutions that
stand a chance of evolving into runtime and inspector-executor style of
computations. While there is no concrete solution today to solve these problems
in MLIR, it is pretty clear that perfect static knowledge and analyses will not
be serious contenders for these problems.</p><p>The following key observations have influenced the design of Linalg and helped
reconcile
<a href=#guiding_principles>core guiding principles</a>
with real-world
requirements when producing an implementation based on MLIR.</p><h2 id=algorithms--data-structures--programsa-namedata_and_computea>Algorithms + Data Structures = Programs<a name=data_and_compute></a></h2><p>This is a twist on Niklaus Wirth&rsquo;s formulation but captures the essence of the
design of Linalg: control-flow does not exist in a vacuum, independently of
data.
On the contrary, there is a very strong relationship between control-flow and
data structures: one cannot exist without the other. This has multiple
implications on the
<a href=#linalg_ops>semantics of Linalg Ops</a>
.</p><h2 id=preserving-structure-in-the-ira-namepreserving_structurea>Preserving Structure in the IR<a name=preserving_structure></a></h2><p>Perfectly nested loops form a particularly important class of structure that
enables key loop transformations such as tiling and mapping to library calls.
Unfortunately, this type of structure is easily broken by transformations such
as partial loop fusion. Tiling and mapping to library calls become more
challenging, or even infeasible.</p><p>Linalg GenericOps adopt perfect-nestedness as a first-class property: the
structure cannot be broken and is transported in the IR by construction. This
may seem limiting but in practice it combines nicely with the next observation.</p><h2 id=the-dialect-need-not-be-closed-under-transformationsa-namedialect_not_closeda>The Dialect Need not be Closed Under Transformations<a name=dialect_not_closed></a></h2><p>This is probably the most surprising and counter-intuitive observation. When one
designs IR for transformations, closed-ness is often a nonnegotiable property.
This is a key design principle of polyhedral IRs such as
<a href=http://icps.u-strasbg.fr/~bastoul/research/papers/GVBCPST06-IJPP.pdf>URUK</a>
and
<a href=https://en.wikipedia.org/wiki/Integer_set_library>ISL-based IRs</a>
:
they are closed under affine transformations.
In MLIR, multiple dialects coexist and form a coherent whole. After
experimenting with different alternatives, it became clear that strict dialect
closed-ness wasn&rsquo;t necessary and could be relaxed.</p><p>In practice, MLIR is designed as an infrastructure for <em><strong>progressive
lowering</strong></em>. Linalg fully embraces this notion and thinks of codegen in terms of
<em>reducing some potential function</em>. At this time, this potential is not yet
well-defined but the analogy with physics is still relevant.
Linalg-based codegen and
transformations start from higher-level IR ops and dialects. Then each
transformation application reduces the potential by introducing lower-level IR
ops, thus reducing the potential, all the way to Loops + VectorOps and LLVMIR.
When closed-ness under
transformation would dictate that the potential remains constant, Linalg
advocates for <em><strong>monotonicity</strong></em> under transformations.</p><p>Very concretely, despite the fact that GenericOp only allow perfectly nested
semantics, once tiling and fusion kick in, imperfectly nested loops are gradually
introduced.
In other words, imperfectly nested control flow appears as <em><strong>the result of
applying key transformations</strong></em>.</p><p>The following key transformations have been central to driving the design of
Linalg. They are all implemented in terms of the properties of the
<code>linalg.generic</code> OpInterface and avoid the pitfall of relying on hardcoded
one-off op knowledge.</p><p>The textual form description of these transformations is left for future
work. Still, it is useful to at list the key transformations that are
performed on the Linalg IR and that have influenced its design:</p><ol><li>Progressive Buffer Allocation.</li><li>Parametric Tiling.</li><li>Promotion to Temporary Buffer in Fast Memory.</li><li>Tiled Producer-Consumer Fusion with Parametric Tile-And-Fuse.</li><li>Map to Parallel and Reduction Loops and Hardware.</li><li>Vectorization: Rewrite in Vector Form.</li><li>Lower to Loops (Affine and/or Generic).</li><li>Lower to Library Calls or Special Instructions, Intrinsics or ISA.</li><li>Partially Lower to Iterations Over a Finer-Grained Linalg Op.</li></ol><p>Linalg takes at least some inspiration from all previously
<a href=#prior_art>listed prior
art</a>
. The design enables the definition of <em><strong>CustomOps</strong></em> with
generic properties that enable
<a href=#key_transformations>key transformations</a>
,
including lowering to scalar load/store and other operations or to external
library calls and intrinsics.</p><p>These ops can have <em><strong>either tensor or buffer operands</strong></em>.</p><h2 id=payload-carrying-opsa-namepayload_opsa>Payload-Carrying Ops<a name=payload_ops></a></h2><p>Linalg defines two payload carrying operations that implement the
<a href="https://docs.google.com/presentation/d/1P-j1GrH6Q5gLBjao0afQ-GfvcAeF-QU4GXXeSy0eJ9I/edit#slide=id.p">structured ops</a>
abstraction on tensors and buffers. This is architected as two generic operations
<code>linalg.generic</code> (resp. <code>linalg.indexed_generic</code>) that can expressing custom
operations with <em>index-free semantics</em> (resp. <em>indexing semantics</em>).
The properties of these generic ops are the result of applying the
<a href=#guiding_principles>guiding principles</a>
. They are listed next, with a brief example
and discussion for each .</p><h3 id=property-1-input-and-output-operands-define-the-iteration-spacea-nameprop1a>Property 1: Input and Output Operands Define The Iteration Space<a name=prop1></a></h3><p>A <code>linalg.generic</code> op fully <em>derives</em> the specification of its iteration space
from its operands.
The property enforces that a localized IR element (the op) <em>has</em> all the information
needed to synthesize the control-flow required to iterate over its operands,
according to their type. This notion of IR localization bears some resemblance
to
<a href=http://icps.u-strasbg.fr/~bastoul/research/papers/GVBCPST06-IJPP.pdf>URUK</a>
and <em>schedule trees</em> in
<a href=https://en.wikipedia.org/wiki/Integer_set_library>ISL</a>
.</p><p>Consider the following, partially specified, <code>linalg.generic</code> example:</p><pre><code>#attrs = {args_in: 1, args_out: 1}
func @example(%A: memref&lt;?xf32, layout1&gt;, 
              %B: memref&lt;?xvector&lt;4xf32, layout2&gt;&gt;) {
  linalg.generic #attrs (%2, %3): memref&lt;?xf32, layout1&gt;,
                                  memref&lt;?xvector&lt;4xf32, layout2&gt;&gt;
  return
}
</code></pre><p>The property &ldquo;<em>Input and Output Operands Define The Iteration Space</em>&rdquo; is
materialized by a lowering into a form that will resemble:</p><pre><code>func @example(%A: memref&lt;?xf32, layout1&gt;, 
              %B: memref&lt;?xvector&lt;4xf32, layout2&gt;&gt;) {
  %M = &quot;dim&quot; %A, 0: index
  %N = &quot;dim&quot; %B, 0: index
  %eq = eq %M, %N: i1   // iteration space is consistent with data
  assert(%eq): (i1) -&gt; ()
  for %i = 0 to %M {
    %a = load %A[%i]: memref&lt;?xf32, layout1&gt;
    %b = load %B[%i]: memref&lt;?xvector&lt;4xf32&gt;, layout2&gt;
    // compute arg types match elemental tensor types
    %c = &quot;some_compute&quot;(%a, %b): (f32, vector&lt;4xf32&gt;) -&gt; (vector&lt;4xf32&gt;)
    store %c, %B[%i]: memref&lt;?xvector&lt;4xf32&gt;, layout2&gt;
  }
  return
}
</code></pre><p>The property participates in simplifying analyses and transformations. For
instance, it guarantees no out-of bounds access can occur by construction
(assuming dynamic operand dimensions agree with each other, which is the
purpose of the <code>assert</code> runtime check).</p><p>Before lowering to loop form, loop induction variables and iterators are <em>not yet
materialized</em>. This is a necessary property if we want an abstraction that
works on both tensor values and buffers because <em><strong>values don’t escape
loops/nesting</strong></em>.</p><p>The main implications are that:</p><ol><li>The semantics of the ops are <em>restricted to operate on structured data
types</em>, on which we can define an iterator.</li><li>This does not model arbitrary code with side-effects.</li></ol><p>We do not think these are serious limitations in practice because MLIR is all
about mixing different levels of abstractions in the same IR. As long as
Linalg can progressively lower to the next level of abstraction, it can also
be just bypassed for things that do not fit.</p><p>At the same time, conditioning op semantics on structured data types is a very
promising path towards extensibility to non-dense tensors as experience with
LIFT abstractions for
<a href=https://www.lift-project.org/publications/2016/harries16sparse.pdf>sparse</a>
and
<a href=https://www.lift-project.org/publications/2019/pizzuti19positiondependentarrays.pdf>position-dependent
arrays</a>
,
as well as
<a href=http://tensor-compiler.org/>TACO</a>
, has shown.</p><h3 id=property-2-reversible-mappings-between-control-and-data-structuresa-nameprop2a>Property 2: Reversible Mappings Between Control and Data Structures<a name=prop2></a></h3><p>A <code>linalg.generic</code> <em>defines</em> the mapping between the iteration space (i.e. the
loops) and the data.</p><p>Consider the following, partially specified, <code>linalg.generic</code> example:</p><pre><code>#indexing_maps = { 
  (i, j) -&gt; (j, i), 
  (i, j) -&gt; (j) 
}
#attrs = {args_in: 1, args_out: 1, indexings: indexing_maps}
func @example(%A: memref&lt;?xf32, layout1&gt;, 
              %B: memref&lt;?xvector&lt;4xf32, layout2&gt;&gt;) {
  linalg.generic #attrs (%A, %B): memref&lt;?xf32, layout1&gt;,
                                  memref&lt;?xvector&lt;4xf32, layout2&gt;&gt;
  return
}
</code></pre><p>The property &ldquo;<em>Reversible Mappings Between Control and Data Structures</em>&rdquo; is
materialized by a lowering into a form that will resemble:</p><pre><code>#attrs = {args_in: 1, args_out: 1, indexings: indexing_maps}
func @example(%A: memref&lt;?xf32, layout1&gt;, 
              %B: memref&lt;?xvector&lt;4xf32, layout2&gt;&gt;) {
  // loop bounds determined from data sizes by “inverting the map”
  %J = &quot;dim&quot; %2, 0: index
  %I = &quot;dim&quot; %2, 1: index
  %J2 = &quot;dim&quot; %3, 0: index
  // iteration space is consistent with data + mapping inference 
  %eq = &quot;eq&quot; %J, %J2: i1
  &quot;assert&quot; %eq: (i1) -&gt; ()
  for %i = 0 to %I {           // loop order is fully defined by indexing maps
    for %j = 0 to %J {         // arbitrary permutations are possible
      %a = &quot;load&quot; %2, %j, %i: memref&lt;8x?xf32&gt;
      %b = &quot;load&quot; %3, %j: memref&lt;?xvector&lt;4xf32&gt;&gt;
      %c = &quot;some_compute&quot;(%a, %b): (f32, vector&lt;4xf32&gt;) -&gt; (vector&lt;4xf32&gt;)
      &quot;store&quot; %c, %3, %j: memref&lt;?xvector&lt;4xf32&gt;&gt;
    }
  }
  return
}
</code></pre><p>This mapping needs to be reversible because we want to be
able to go back and forth between the two and answer questions such as:</p><ul><li>Given a subset of the iteration space, what subset of data does it read and
write?</li><li>Given a subset of data read or written, what subset of the iteration space
is responsible for this read or write?</li></ul><p>Answering these <code>2</code> questions is one of the main analyses that Linalg uses to
implement transformations such as tiling, tiled producer-consumer fusion, and
promotion to temporary buffers in fast memory.</p><p>In the current implementation, <code>linalg.generic</code> uses a list of
<a href=/docs/Dialects/>AffineMaps</a>
.
This is a pragmatic short-term solution, but in the longer term note that
this property could be even evaluated dynamically, similarly to
inspector-executor algorithms.</p><h3 id=property-3-the-type-of-iterators-is-defined-explicitlya-nameprop3a>Property 3: The Type Of Iterators is Defined Explicitly<a name=prop3></a></h3><p>A <code>linalg.generic</code> op fully <em>declares</em> the type of its iterators. This
information is used in transformations.</p><p>These properties are derived from established practice in the field and mirror
the properties from Ken Kennedy&rsquo;s
<a href=https://www.elsevier.com/books/optimizing-compilers-for-modern-architectures/allen/978-0-08-051324-9>Optimizing Compilers for Modern Architectures</a>
.
The key idea of legality of loop transformations expressed by Kennedy is
that <em><strong>the lexicographic order of all dependence vectors must be
preserved</strong></em>.</p><p>This can be better captured directly at the loop level thanks to specific
iterator types, among which:
<em>parallel</em>, <em>reduction</em>, <em>partition</em>, <em>permutable/monotonic</em>, <em>sequential</em>,
<em>dependence distance</em>, &mldr;</p><p>These types are traditionally the result of complex dependence analyses and
have been referred to as &ldquo;<em>bands</em>&rdquo; in the polyhedral community (e.g. <em>parallel
bands</em>, <em>permutable bands</em>, etc, in
<a href=https://en.wikipedia.org/wiki/Integer_set_library>ISL</a>
schedule tree
parlance).</p><p>Specifying the information declaratively in a <code>linalg.generic</code> allows
conveying properties that may be hard (or even impossible) to derive from
lower-level information. These properties can be brought all the way to the
moment when they are useful for transformations, used and then discarded.</p><p>Additionally, these properties may also be viewed as a contract that the
frontend/user guarantees and that the compiler may take advantage of. The
common example is the use of data-dependent reduction semantics for
specifying histogram computations. If the frontend has additional knowledge
that proper atomic operations are available, it may be better to specify
parallel semantics and use the special atomic in the computation region.</p><p>At this time, Linalg only has an explicit use for <em>parallel</em> and <em>reduction</em>
loops but previous experience shows that the abstraction generalizes.</p><h3 id=property-4-the-compute-payload-is-specified-with-a-regiona-nameprop4a>Property 4: The Compute Payload is Specified With a Region<a name=prop4></a></h3><p>A <code>linalg.generic</code> op has a compute payload that is fully generic thanks to
the use of
<a href=https://github.com/llvm/llvm-project/blob/58265ad42a90ae8905be6a447cb42e53529a54a0/mlir/docs/LangRef.md#regions>Regions</a>
.</p><p>The region takes as arguments the scalar elemental types of the tensor or
buffer operands of the <code>linalg.generic</code>. For flexibility and ability to match
library calls, additional special values may be passed. For instance, a
<code>linalg.fill</code> operation takes a buffer and an additional scalar value.</p><p>At this time there are no additional restrictions to the region
semantics. This is meant to allow the exploration of various design tradeoffs
at the intersection of regions and iterator types.
In particular, the frontend is responsible for the semantics of iterator types
to correspond to the operations inside the region: the region can capture
buffers arbitrarily and write into them. If this conflicts with some parallel
iterator requirement, this is undefined behavior.</p><p>Concretely, consider the following, partially specified, <code>linalg.generic</code>
example:</p><pre><code>#indexing_maps = { 
  (i, j) -&gt; (i, j), 
  (i, j) -&gt; (i, j) 
}
#attrs = {args_in: 1, args_out: 1, indexings: #indexing_maps}
func @example(%A: memref&lt;?x?xf32&gt;, %B: memref&lt;?x?xf32&gt;, %C: memref&lt;?x?xf32&gt;) {
  linalg.generic #attrs (%A, %B, %C) {
    ^bb0(%a: f32, %b: f32):
      %c = addf %a, %b : f32
      return %c : f32
  }: memref&lt;?x?xf32&gt;, memref&lt;?x?xf32&gt;, memref&lt;?x?xf32&gt;
  return
}
</code></pre><p>The property &ldquo;<em>The Compute Payload is Specified With a Region</em>&rdquo; is
materialized by a lowering into a form that will resemble:</p><pre><code>func @example(%A: memref&lt;?x?xf32&gt;, %B: memref&lt;?x?xf32&gt;, %C: memref&lt;?x?xf32&gt;) {
  %M = dim %A, 0: index
  %N = dim %B, 1: index
  for %i = 0 to %M {
    for %j = 0 to %N {
      %a = load %A[%i, %j]: memref&lt;?x?xf32&gt;
      %b = load %B[%i, %j]: memref&lt;?x?xf32&gt;&gt;
      %c = addf %a, %b : f32
      store %c, %C[%i, %j]: memref&lt;?x?xf32&gt;
    }
  }
  return
}
</code></pre><p>In the process of lowering to loops and lower-level constructs, similar
requirements are encountered, as are discussed in the
<a href=https://llvm.discourse.group/t/introduce-std-inlined-call-op-proposal/282/2>inlined call op
proposal</a>
.
We expect to be able to reuse the common lower-level infrastructure provided
it evolves to support both region arguments and captures.</p><h3 id=property-5-may-map-to-an-external-library-calla-nameprop5a>Property 5: May Map To an External Library Call<a name=prop5></a></h3><p>A <code>linalg.generic</code> op may map to an external library call by specifying a
<code>SymbolAttr</code>. At this level of abstraction, the important glue is the ability
to perform transformations that preserve the structure necessary to <em><strong>call
the external library after different transformations have been applied</strong></em>.</p><p>This involves considerations related to preservation of op semantics
and integration at the ABI level. Regardless of whether one wants to use
external library calls or a custom ISA, the problem for codegen is similar:
preservation of a fixed granularity.</p><p>Consider the following, partially specified, <code>linalg.generic</code>
example:</p><pre><code>#fun_attr = &quot;pointwise_add&quot;
#indexing_maps = { 
  (i, j) -&gt; (i, j), 
  (i, j) -&gt; (i, j) 
}
#attrs = {args_in: 1, args_out: 1, indexings: #indexing_maps, fun: #fun_attr}
func @example(%A: memref&lt;?x?xf32&gt;, %B: memref&lt;?x?xf32&gt;, %C: memref&lt;?x?xf32&gt;) {
  linalg.generic #attrs (%A, %B, %C) {
    ^bb0(%a: f32, %b: f32):
      %c = addf %a, %b : f32
      return %c : f32
  }: memref&lt;?x?xf32&gt;, memref&lt;?x?xf32&gt;, memref&lt;?x?xf32&gt;
  return
}
</code></pre><p>The property &ldquo;<em>Map To an External Library Call</em>&rdquo; is
materialized by a lowering into a form that will resemble:</p><pre><code>func @pointwise_add_sxsxf32_sxsxf32(memref&lt;?x?xf32&gt;, memref&lt;?x?xf32&gt;, memref&lt;?x?xf32&gt;) -&gt; ()

func @example(%A: memref&lt;?x?xf32&gt;, %B: memref&lt;?x?xf32&gt;, %C: memref&lt;?x?xf32&gt;) {
  call @pointwise_add_sxsxf32_sxsxf32 (%A, %B, %C): 
    (memref&lt;?x?xf32&gt;, memref&lt;?x?xf32&gt;, memref&lt;?x?xf32&gt;) -&gt; ()
  return
}
</code></pre><p>Which, after lowering to LLVM resembles:</p><pre><code>func @pointwise_add_sxsxf32_sxsxf32(!llvm&lt;&quot;{ float*, i64, [2 x i64], [3 x i64] }*&quot;&gt;, 
                                    !llvm&lt;&quot;{ float*, i64, [2 x i64], [3 x i64] }*&quot;&gt;, 
                                    !llvm&lt;&quot;{ float*, i64, [2 x i64], [3 x i64] }*&quot;&gt;) -&gt; ()

func @example(%A: !llvm&lt;&quot;{ float*, i64, [2 x i64], [3 x i64] }*&quot;&gt;, 
              %B: !llvm&lt;&quot;{ float*, i64, [2 x i64], [3 x i64] }*&quot;&gt;, 
              %C: !llvm&lt;&quot;{ float*, i64, [2 x i64], [3 x i64] }*&quot;&gt;) {
  llvm.call @pointwise_add_sxsxf32_sxsxf32 (%A, %B, %C): 
    (!llvm&lt;&quot;{ float*, i64, [2 x i64], [3 x i64] }*&quot;&gt;...) -&gt; ()
  return
}
</code></pre><h4 id=convention-for-external-library-interoperability>Convention For External Library Interoperability</h4><p>The <code>linalg</code> dialect adopts a convention that is similar to <code>BLAS</code> when
offloading operations to fast library implementations: pass a non-owning
pointer to input and output data with additional metadata. This convention
is also found in libraries such as <code>MKL</code>, <code>OpenBLAS</code>, <code>BLIS</code>, <code>cuBLAS</code>,
<code>cuDNN</code>, etc.. and more generally at interface points across language
boundaries (e.g. C++ / Python).</p><p>Generally, <code>linalg</code> passes non-owning pointers to View data structures
to pre-compiled library calls linked externally.</p><p>There is an
<a href=https://llvm.discourse.group/t/lowering-optional-attributes-in-linalg-structuredops-to-standard-dialect/333/3>ongoing
discussion</a>
on the topic of extending interoperability in the presence of key attributes.</p><h3 id=property-6-perfectly-nested-writes-to-the-whole-output-operandsa-nameprop6a>Property 6: Perfectly Nested Writes To The Whole Output Operands<a name=prop6></a></h3><p>A <code>linalg.generic</code> op represents a perfectly nested loop nest that writes the
entire memory region. This is a structural constraint across regions and
loops that has proven to be key in simplifying transformations.</p><p>One particular point to mention is that converting imperfectly nested code
into perfectly nested code can often be done with enough loop distribution
and embedding of conditionals down to the innermost loop level.</p><p>Previous experience with Tensor Comprehensions gave us the intuition that
forcing innermost control-flow nesting is a lot like writing data-parallel
code with arrays of boolean values and predication.
This type of trick has also been used before in polyhedral compilers to
convert non-affine control into affine compute dependencies.</p><p>While it may be possible to automate such rewrites from generic IR,
<code>linalg.generic</code> just forces the semantics for now.</p><p>The key implication is that this conversion to deep predication needs to be
undone once we are done with Linalg transformations.
After iterators and induction variables are materialized (i.e. after lowering
out of <code>linalg.generic</code> occurred), the overall performance will be greatly
influenced by the quality of canonicalizations, foldings and <em>Loop Independent
Code Motion</em> (LICM).</p><p>In the grander scheme, the reliance on late LICM was deemed a necessary risk.</p><h3 id=putting-it-togethera-namesummarya>Putting it Together<a name=summary></a></h3><p>As it stands, the six properties above define the semantics of a
<code>linalg.generic</code> op. It is an open question whether all of these semantics are
strictly necessary in practice and whether some should or could be derived
automatically while still maintaining the
<a href=#guiding_principles>core guiding
principles</a>
.</p><p>For the time being, we have settled on the combination of these properties
because of empirical evidence building and working on multiple high-level
compilers. As we lay those down and engage more with the community, we expect
multiple rounds of discussions and design changes to the original architecture.</p><h2 id=data-representation-viewsa-nameviewsa>Data Representation: Views<a name=views></a></h2><p>The current implementation uses the
<a href=https://groups.google.com/a/tensorflow.org/forum/#!topic/mlir/MaL8m2nXuio>Strided MemRef (a.k.a View)</a>
abstraction. The name <em>View</em> is used interchangeably in <code>linalg</code> to signify
<em>Strided MemRef</em>.
In the future we expect to use other structured data types and
support ragged, mixed-sparse and other types. As mentioned
<a href=#lessonslift>previously</a>
we expect to draw on the
experience from existing LIFT abstractions for
<a href=https://www.lift-project.org/publications/2016/harries16sparse.pdf>sparse</a>
and
<a href=https://www.lift-project.org/publications/2019/pizzuti19positiondependentarrays.pdf>position-dependent
arrays</a>
.</p><h2 id=metadata-opsa-namemetadata_opsa>Metadata Ops<a name=metadata_ops></a></h2><p>A set of ops that manipulate metadata but do not move memory. These ops take
<code>view</code> operands + extra attributes and return new <code>view</code>s. The returned
<code>view</code>s generally alias the operand <code>view</code>. At the moment the existing ops
are:</p><pre><code>* `std.view`,
* `std.subview`,
* `linalg.range`,
* `linalg.slice`,
* `linalg.transpose`.
* `linalg.reshape`,
</code></pre><p>Future ops are added on a per-need basis but should include:</p><pre><code>* `linalg.tile`,
* `linalg.intersection`,
* `linalg.convex_union`,
* `linalg.difference` (would need to work on a list of views).
</code></pre><p>These additional operations correspond to abstractions that have been known to
work in the field of large-scale distributed stencil computations.</p><p>In a longer-term future, the abstractions from
<a href=https://legion.stanford.edu/overview/>Legion data-centric
programming model</a>
seem generally
appealing.</p><h2 id=named-payload-carrying-opsa-namenamed_opsa>Named Payload-Carrying Ops<a name=named_ops></a></h2><p>Additionally, <code>linalg</code> provides a small subset of commonly named operations:</p><pre><code>* `linalg.copy`,
* `linalg.fill`,
* `linalg.dot`,
* `linalg.matmul`,
* `linalg.conv`.
</code></pre><p>These named operations adhere to the <code>linalg.generic</code> op interface. Work is in
progress to define declarative mechanisms to automatically generate named ops
from a description in terms of only the generic op interface.</p><p>This is the main reason there are only a small number of ops today: we expect
them to be auto-generated from Tablegen soon.</p><p>Multiple open issues and design alternatives are in flight and it is time to
lay them out for the community to discuss and pick apart:</p><ol><li>Should <code>linalg.generic</code> support nesting?</li><li>Should <code>linalg.generic</code> regions take views or only scalars?</li><li>Should we try to solve automatic differentiation at this level of
abstraction?</li><li>Are all the six properties really necessary?</li><li>Is this relying too much on declarative specification and would we be
better off relying more on analyses?</li><li>Is this general enough for the community&rsquo;s needs? If not how should this be
extended, if at all?
&mldr;</li></ol><p>These key questions (and much more) should be really thought of in the general
context of MLIR in which different levels of IR interoperate seamlessly. In
practice, it is not necessary (or beneficial) to try and solve all problems in the
same IR.</p><div class=edit-meta><br></div><nav class=pagination><a class="nav nav-prev" href=/docs/Dialects/GPU/ title="GPU Dialect"><i class="fas fa-arrow-left" aria-hidden=true></i>Prev - GPU Dialect</a>
<a class="nav nav-next" href=/docs/Dialects/LLVM/ title="LLVM IR Dialect">Next - LLVM IR Dialect <i class="fas fa-arrow-right" aria-hidden=true></i></a></nav><footer><p class=powered>Powered by <a href=https://gohugo.io>Hugo</a>. Theme by <a href=https://themes.gohugo.io/hugo-theme-techdoc/>TechDoc</a>. Designed by <a href=https://github.com/thingsym/hugo-theme-techdoc>Thingsym</a>.</p></footer></main><div class=sidebar><nav class=slide-menu><ul><li><a href=https://mlir.llvm.org/>Home</a></li><li><a href=/talks/>Talks and Related Publications</a></li><li><a href=/users/>Users of MLIR</a></li><li class=has-sub-menu><a href=/getting_started/>Getting Started<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/getting_started/Faq/>FAQ</a></li><li><a href=/getting_started/Contributing/>How to Contribute</a></li><li><a href=/getting_started/DeveloperGuide/>Developer Guide</a></li><li><a href=/getting_started/openprojects/>Open Projects</a></li><li><a href=/getting_started/Glossary/>Glossary</a></li><li><a href=/getting_started/TestingGuide/>Testing Guide</a></li></ul></li><li class="parent has-sub-menu"><a href=/docs/>Code Documentation<span class="mark opened">-</span></a><ul class=sub-menu><li class="parent has-sub-menu"><a href=/docs/Dialects/>Dialects<span class="mark opened">-</span></a><ul class=sub-menu><li><a href=/docs/Dialects/Affine/>Affine Dialect</a></li><li><a href=/docs/Dialects/AffineOps/>Dialect 'affine' definition</a></li><li><a href=/docs/Dialects/FxpMathOps/>Dialect 'fxpmath' definition</a></li><li><a href=/docs/Dialects/GPUOps/>Dialect 'gpu' definition</a></li><li><a href=/docs/Dialects/LinalgDoc/>Dialect 'linalg' definition</a></li><li><a href=/docs/Dialects/LoopOps/>Dialect 'loop' definition</a></li><li><a href=/docs/Dialects/NVVMOps/>Dialect 'nvvm' definition</a></li><li><a href=/docs/Dialects/QuantOps/>Dialect 'quant' definition</a></li><li><a href=/docs/Dialects/ROCDLOps/>Dialect 'rocdl' definition</a></li><li><a href=/docs/Dialects/SPIRVOps/>Dialect 'spv' definition</a></li><li><a href=/docs/Dialects/VectorOps/>Dialect 'vector' definition</a></li><li><a href=/docs/Dialects/GPU/>GPU Dialect</a></li><li class=active><a href=/docs/Dialects/Linalg/>Linalg Dialect: The Case For Compiler-Friendly Custom Operations</a></li><li><a href=/docs/Dialects/LLVM/>LLVM IR Dialect</a></li><li><a href=/docs/Dialects/SPIR-V/>SPIR-V Dialect</a></li><li><a href=/docs/Dialects/Standard/>Standard Dialect</a></li><li><a href=/docs/Dialects/Vector/>Vector Dialect</a></li></ul></li><li class=has-sub-menu><a href=/docs/Tutorials/Toy/>Toy<span class="mark closed">+</span></a><ul class=sub-menu><li><a href=/docs/Tutorials/Toy/Ch-1/>Chapter 1: Toy Tutorial Introduction</a></li><li><a href=/docs/Tutorials/Toy/Ch-2/>Chapter 2: Emitting Basic MLIR</a></li><li><a href=/docs/Tutorials/Toy/Ch-3/>Chapter 3: High-level Language-Specific Analysis and Transformation</a></li><li><a href=/docs/Tutorials/Toy/Ch-4/>Chapter 4: Enabling Generic Transformation with Interfaces</a></li><li><a href=/docs/Tutorials/Toy/Ch-5/>Chapter 5: Partial Lowering to Lower-Level Dialects for Optimization</a></li><li><a href=/docs/Tutorials/Toy/Ch-6/>Chapter 6: Lowering to LLVM and CodeGeneration</a></li><li><a href=/docs/Tutorials/Toy/Ch-7/>Chapter 7: Adding a Composite Type to Toy</a></li></ul></li><li><a href=/docs/EDSC/>Background: declarative builders API</a></li><li><a href=/docs/ConversionToLLVMDialect/>Conversion to the LLVM Dialect</a></li><li><a href=/docs/DialectConversion/>Dialect Conversion</a></li><li><a href=/docs/Diagnostics/>Introduction and Usage Guide to MLIR's Diagnostics Infrastructure</a></li><li><a href=/docs/Interfaces/>Introduction to MLIR Interfaces</a></li><li><a href=/docs/Traits/>Introduction to MLIR Operation Traits</a></li><li><a href=/docs/GenericDAGRewriter/>MLIR Generic DAG Rewriter Infrastructure</a></li><li><a href=/docs/Passes/>MLIR Passes</a></li><li><a href=/docs/Quantization/>MLIR Quantization</a></li><li><a href=/docs/Rationale/>MLIR Rationale</a></li><li><a href=/docs/LangRef/>MLIR Specification</a></li><li><a href=/docs/MLIRForGraphAlgorithms/>MLIR: Incremental Application to Graph Algorithms in ML Frameworks</a></li><li><a href=/docs/RationaleSimplifiedPolyhedralForm/>MLIR: The case for a simplified polyhedral form</a></li><li><a href=/docs/Canonicalization/>Operation Canonicalization in MLIR</a></li><li><a href=/docs/QuickstartRewrites/>Quickstart tutorial to adding MLIR graph rewrite</a></li><li><a href=/docs/DefiningAttributesAndTypes/>Quickstart tutorial to defining custom dialect attributes and types</a></li><li><a href=/docs/ShapeInference/>Shape inference</a></li><li><a href=/docs/DeclarativeRewrites/>Table-driven Declarative Rewrite Rule (DRR)</a></li><li><a href=/docs/OpDefinitions/>Table-driven Operation Definition Specification (ODS)</a></li><li><a href=/docs/UsageOfConst/>Usage of 'Const' in MLIR, for core IR types</a></li><li><a href=/docs/WritingAPass/>Writing a Pass</a></li></ul></li></ul></nav><div class=sidebar-footer></div></div></div><a href=# id=backtothetop-fixed class=backtothetop data-backtothetop-duration=600 data-backtothetop-easing=easeOutQuart data-backtothetop-fixed-fadein=1000 data-backtothetop-fixed-fadeout=1000 data-backtothetop-fixed-bottom=10 data-backtothetop-fixed-right=20><span class="fa-layers fa-fw"><i class="fas fa-circle"></i><i class="fas fa-arrow-circle-up"></i></span></a></div></body></html>