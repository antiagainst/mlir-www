<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::edsc Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">11.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="namespacemlir_1_1edsc.html">edsc</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mlir::edsc Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1edsc_1_1intrinsics"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html">intrinsics</a></td></tr>
<tr class="memdesc:namespacemlir_1_1edsc_1_1intrinsics"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides a set of first class intrinsics. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1edsc_1_1op"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc_1_1op.html">op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1edsc_1_1ops"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc_1_1ops.html">ops</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1AffineLoopNestBuilder.html">AffineLoopNestBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit nested <a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html" title="A LoopBuilder is a generic NestedBuilder for loop-like MLIR operations. ">LoopBuilder</a>.  <a href="classmlir_1_1edsc_1_1AffineLoopNestBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1Append.html">Append</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1BlockBuilder.html">BlockBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1BlockBuilder.html" title="A BlockBuilder is a NestedBuilder for mlir::Block*. ">BlockBuilder</a> is a <a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html" title="A NestedBuilder is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves th...">NestedBuilder</a> for <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">mlir::Block</a>*.  <a href="classmlir_1_1edsc_1_1BlockBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1BlockHandle.html">BlockHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1BlockHandle.html" title="A BlockHandle represents a (potentially &quot;delayed&quot;) Block abstraction. ">BlockHandle</a> represents a (potentially "delayed") <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a> abstraction.  <a href="classmlir_1_1edsc_1_1BlockHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1CapturableHandle.html">CapturableHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html" title="ValueHandle implements a (potentially &quot;delayed&quot;) typed Value abstraction. ">ValueHandle</a>, <a class="el" href="structmlir_1_1edsc_1_1OperationHandle.html" title="An OperationHandle can be used in lieu of ValueHandle to capture the operation in cases when one does...">OperationHandle</a> and <a class="el" href="classmlir_1_1edsc_1_1BlockHandle.html" title="A BlockHandle represents a (potentially &quot;delayed&quot;) Block abstraction. ">BlockHandle</a>.  <a href="classmlir_1_1edsc_1_1CapturableHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1edsc_1_1CustomOperation.html">CustomOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple wrapper to build a generic operation without successor blocks.  <a href="structmlir_1_1edsc_1_1CustomOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1GenericLoopNestRangeBuilder.html">GenericLoopNestRangeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper template class for building loop.for and affine.loop nests from ranges.  <a href="classmlir_1_1edsc_1_1GenericLoopNestRangeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1edsc_1_1index__type.html">index_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1edsc_1_1IndexHandle.html">IndexHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="structmlir_1_1edsc_1_1IndexHandle.html" title="An IndexHandle is a simple wrapper around a ValueHandle. ">IndexHandle</a> is a simple wrapper around a <a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html" title="ValueHandle implements a (potentially &quot;delayed&quot;) typed Value abstraction. ">ValueHandle</a>.  <a href="structmlir_1_1edsc_1_1IndexHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html">LoopBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1LoopBuilder.html" title="A LoopBuilder is a generic NestedBuilder for loop-like MLIR operations. ">LoopBuilder</a> is a generic <a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html" title="A NestedBuilder is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves th...">NestedBuilder</a> for loop-like MLIR operations.  <a href="classmlir_1_1edsc_1_1LoopBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1LoopNestBuilder.html">LoopNestBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to sugar building loop.for loop nests from ranges.  <a href="classmlir_1_1edsc_1_1LoopNestBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1LoopNestRangeBuilder.html">LoopNestRangeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to sugar building loop.for loop nests from ranges.  <a href="classmlir_1_1edsc_1_1LoopNestRangeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1LoopRangeBuilder.html">LoopRangeBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1LoopRangeBuilder.html" title="A LoopRangeBuilder is a generic NestedBuilder for loop.for operations. ">LoopRangeBuilder</a> is a generic <a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html" title="A NestedBuilder is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves th...">NestedBuilder</a> for loop.for operations.  <a href="classmlir_1_1edsc_1_1LoopRangeBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1MemRefView.html">MemRefView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1MemRefView.html" title="A MemRefView represents the information required to step through a MemRef. ">MemRefView</a> represents the information required to step through a MemRef.  <a href="classmlir_1_1edsc_1_1MemRefView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html">NestedBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1NestedBuilder.html" title="A NestedBuilder is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves th...">NestedBuilder</a> is a scoping abstraction to create an idiomatic syntax embedded in C++ that serves the purpose of building nested MLIR.  <a href="classmlir_1_1edsc_1_1NestedBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1edsc_1_1OperationHandle.html">OperationHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="structmlir_1_1edsc_1_1OperationHandle.html" title="An OperationHandle can be used in lieu of ValueHandle to capture the operation in cases when one does...">OperationHandle</a> can be used in lieu of <a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html" title="ValueHandle implements a (potentially &quot;delayed&quot;) typed Value abstraction. ">ValueHandle</a> to capture the operation in cases when one does not care about, or cannot extract, a unique <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> from the operation.  <a href="structmlir_1_1edsc_1_1OperationHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1ScopedContext.html">ScopedContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to transparently handle builder insertion points by RAII.  <a href="classmlir_1_1edsc_1_1ScopedContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html" title="A StructuredIndexed represents an indexable quantity that is either: ">StructuredIndexed</a> represents an indexable quantity that is either:  <a href="structmlir_1_1edsc_1_1StructuredIndexed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html">TemplatedIndexedValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html" title="A TemplatedIndexedValue brings an index notation over the template Load and Store parameters...">TemplatedIndexedValue</a> brings an index notation over the template Load and Store parameters.  <a href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html">ValueHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html" title="ValueHandle implements a (potentially &quot;delayed&quot;) typed Value abstraction. ">ValueHandle</a> implements a (potentially "delayed") typed <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> abstraction.  <a href="classmlir_1_1edsc_1_1ValueHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1VectorView.html">VectorView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1edsc_1_1VectorView.html" title="A VectorView represents the information required to step through a Vector accessing each scalar eleme...">VectorView</a> represents the information required to step through a Vector accessing each scalar element at a time.  <a href="classmlir_1_1edsc_1_1VectorView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1edsc_1_1View.html">View</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8be7c530f08fab744d30a205fd99d169"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a8be7c530f08fab744d30a205fd99d169">IndexedValue</a> = <a class="el" href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html">TemplatedIndexedValue</a>&lt; <a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html#a0dd77ddae0ff1d1ddfd37b8c59824b10">intrinsics::affine_load</a>, <a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html#ac4576301782326f0d29de97f3e9d6915">intrinsics::affine_store</a> &gt;</td></tr>
<tr class="separator:a8be7c530f08fab744d30a205fd99d169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ed9b5ed111c244a6a7724e61bcfbd4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a30ed9b5ed111c244a6a7724e61bcfbd4">StdIndexedValue</a> = <a class="el" href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html">TemplatedIndexedValue</a>&lt; <a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html#aa7f94d14d584c7ba77e31e16404f3480">intrinsics::std_load</a>, <a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html#a141a72fd8ae7bec70b32615562ce5aea">intrinsics::std_store</a> &gt;</td></tr>
<tr class="separator:a30ed9b5ed111c244a6a7724e61bcfbd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae8511f7c9b194ab830b58cd6f15d371e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371e">IterType</a> { <a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371ea98402eecfbcefc336954458a01752131">IterType::Parallel</a>, 
<a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371ea9e834f13e35e4edf64863ab414a6217a">IterType::Reduction</a>
 }</td></tr>
<tr class="separator:ae8511f7c9b194ab830b58cd6f15d371e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a52de97d5ace4e3c8f15cd35f1a5ff8a3"><td class="memItemLeft" align="right" valign="top">StringRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a52de97d5ace4e3c8f15cd35f1a5ff8a3">toString</a> (<a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371e">IterType</a> t)</td></tr>
<tr class="separator:a52de97d5ace4e3c8f15cd35f1a5ff8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2530abadfa4b280f31ddd2f62d5db514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a2530abadfa4b280f31ddd2f62d5db514">defaultRegionBuilder</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt; args)</td></tr>
<tr class="separator:a2530abadfa4b280f31ddd2f62d5db514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd127624ef670af5d265b7f481cc02bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#afd127624ef670af5d265b7f481cc02bc">makeGenericLinalgOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371e">IterType</a> &gt; iteratorTypes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a> &gt; inputs, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a> &gt; outputs, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;)&gt; regionBuilder=<a class="el" href="namespacemlir_1_1edsc.html#a2530abadfa4b280f31ddd2f62d5db514">defaultRegionBuilder</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; otherValues={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; otherAttributes={})</td></tr>
<tr class="memdesc:afd127624ef670af5d265b7f481cc02bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a <code>linalg.generic</code> op with the specified <code>inputs</code>, <code>outputs</code> and <code>region</code>.  <a href="#afd127624ef670af5d265b7f481cc02bc">More...</a><br /></td></tr>
<tr class="separator:afd127624ef670af5d265b7f481cc02bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf4a1e5a7cb44434fbb2a960332c86c8"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:adf4a1e5a7cb44434fbb2a960332c86c8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html">ValueHandle</a>, 8 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#adf4a1e5a7cb44434fbb2a960332c86c8">makeValueHandles</a> (Container values)</td></tr>
<tr class="memdesc:adf4a1e5a7cb44434fbb2a960332c86c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point to build multiple <a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html" title="ValueHandle implements a (potentially &quot;delayed&quot;) typed Value abstraction. ">ValueHandle</a> from a <code>Container</code> of <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> or <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a>.  <a href="#adf4a1e5a7cb44434fbb2a960332c86c8">More...</a><br /></td></tr>
<tr class="separator:adf4a1e5a7cb44434fbb2a960332c86c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3015a0c7d1dafc7729d8242901ad9374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1IndexHandle.html">IndexHandle</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a3015a0c7d1dafc7729d8242901ad9374">makeIndexHandles</a> (unsigned rank)</td></tr>
<tr class="separator:a3015a0c7d1dafc7729d8242901ad9374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331aa19dae759031f6493883e706c5f9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a331aa19dae759031f6493883e706c5f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html">ValueHandle</a> *, 8 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a331aa19dae759031f6493883e706c5f9">makeHandlePointers</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; T &gt; ivs)</td></tr>
<tr class="memdesc:a331aa19dae759031f6493883e706c5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point to build multiple ValueHandle* from a mutable list <code>ivs</code> of T.  <a href="#a331aa19dae759031f6493883e706c5f9">More...</a><br /></td></tr>
<tr class="separator:a331aa19dae759031f6493883e706c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a54964bd79802c599b2b9d0aa6f45f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html#a9a54964bd79802c599b2b9d0aa6f45f1">extractValues</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1IndexHandle.html">IndexHandle</a> &gt; ivs)</td></tr>
<tr class="memdesc:a9a54964bd79802c599b2b9d0aa6f45f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of the underlying <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> from <code>ivs</code>.  <a href="#a9a54964bd79802c599b2b9d0aa6f45f1">More...</a><br /></td></tr>
<tr class="separator:a9a54964bd79802c599b2b9d0aa6f45f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8be7c530f08fab744d30a205fd99d169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be7c530f08fab744d30a205fd99d169">&#9670;&nbsp;</a></span>IndexedValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1edsc.html#a8be7c530f08fab744d30a205fd99d169">mlir::edsc::IndexedValue</a> = typedef <a class="el" href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html">TemplatedIndexedValue</a>&lt;<a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html#a0dd77ddae0ff1d1ddfd37b8c59824b10">intrinsics::affine_load</a>, <a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html#ac4576301782326f0d29de97f3e9d6915">intrinsics::affine_store</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Helpers_8h_source.html#l00030">30</a> of file <a class="el" href="Helpers_8h_source.html">Helpers.h</a>.</p>

</div>
</div>
<a id="a30ed9b5ed111c244a6a7724e61bcfbd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ed9b5ed111c244a6a7724e61bcfbd4">&#9670;&nbsp;</a></span>StdIndexedValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir_1_1edsc.html#a30ed9b5ed111c244a6a7724e61bcfbd4">mlir::edsc::StdIndexedValue</a> = typedef <a class="el" href="classmlir_1_1edsc_1_1TemplatedIndexedValue.html">TemplatedIndexedValue</a>&lt;<a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html#aa7f94d14d584c7ba77e31e16404f3480">intrinsics::std_load</a>, <a class="el" href="namespacemlir_1_1edsc_1_1intrinsics.html#a141a72fd8ae7bec70b32615562ce5aea">intrinsics::std_store</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Helpers_8h_source.html#l00032">32</a> of file <a class="el" href="Helpers_8h_source.html">Helpers.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae8511f7c9b194ab830b58cd6f15d371e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8511f7c9b194ab830b58cd6f15d371e">&#9670;&nbsp;</a></span>IterType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371e">mlir::edsc::IterType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae8511f7c9b194ab830b58cd6f15d371ea98402eecfbcefc336954458a01752131"></a>Parallel&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae8511f7c9b194ab830b58cd6f15d371ea9e834f13e35e4edf64863ab414a6217a"></a>Reduction&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00085">85</a> of file <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html">Builders.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a2530abadfa4b280f31ddd2f62d5db514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2530abadfa4b280f31ddd2f62d5db514">&#9670;&nbsp;</a></span>defaultRegionBuilder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::edsc::defaultRegionBuilder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00136">136</a> of file <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html">Builders.h</a>.</p>

<p class="reference">References <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00129">makeGenericLinalgOp()</a>.</p>

</div>
</div>
<a id="a9a54964bd79802c599b2b9d0aa6f45f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a54964bd79802c599b2b9d0aa6f45f1">&#9670;&nbsp;</a></span>extractValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1Value.html">Value</a>, 8&gt; mlir::edsc::extractValues </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1IndexHandle.html">IndexHandle</a> &gt;&#160;</td>
          <td class="paramname"><em>ivs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a vector of the underlying <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> from <code>ivs</code>. </p>

<p class="definition">Definition at line <a class="el" href="EDSC_2Intrinsics_8h_source.html#l00074">74</a> of file <a class="el" href="EDSC_2Intrinsics_8h_source.html">Intrinsics.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLoops_8cpp_source.html#l00071">emitLoopRanges()</a>.</p>

</div>
</div>
<a id="afd127624ef670af5d265b7f481cc02bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd127624ef670af5d265b7f481cc02bc">&#9670;&nbsp;</a></span>makeGenericLinalgOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a> * mlir::edsc::makeGenericLinalgOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371e">IterType</a> &gt;&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a> &gt;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html">StructuredIndexed</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a> &gt;)&gt;&#160;</td>
          <td class="paramname"><em>regionBuilder</em> = <code><a class="el" href="namespacemlir_1_1edsc.html#a2530abadfa4b280f31ddd2f62d5db514">defaultRegionBuilder</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>otherValues</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>otherAttributes</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a <code>linalg.generic</code> op with the specified <code>inputs</code>, <code>outputs</code> and <code>region</code>. </p>
<p><code>otherValues</code> and <code>otherAttributes</code> may be passed and will be appended as operands and attributes respectively.</p>
<h1>Prerequisites: </h1>
<ol type="1">
<li><code>inputs</code> may contain <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html" title="A StructuredIndexed represents an indexable quantity that is either: ">StructuredIndexed</a> that capture either buffer or tensor values.</li>
<li><code>outputs</code> may contain <a class="el" href="structmlir_1_1edsc_1_1StructuredIndexed.html" title="A StructuredIndexed represents an indexable quantity that is either: ">StructuredIndexed</a> that capture either buffer values or tensor types. If both buffer values and tensor types are present, then all buffer values must appear before any tensor type. Without this restriction output tensor results would need to be reordered, which would result in surprising behavior when combined with region definition. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00129">129</a> of file <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html">Builders.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="Matchers_8h_source.html#l00180">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00511">mlir::IntegerType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00271">mlir::IntegerAttr::get()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00052">mlir::edsc::ScopedContext::getBuilder()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00021">mlir::getElementTypeOrSelf()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00058">mlir::edsc::ScopedContext::getLocation()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00117">getMaxDimIndex()</a>, <a class="el" href="EDSC_2Intrinsics_8h_source.html#l00064">makeHandlePointers()</a>, <a class="el" href="EDSC_2Builders_8h_source.html#l00541">makeValueHandles()</a>, <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>, and <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00087">toString()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00136">defaultRegionBuilder()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00301">mlir::edsc::ops::linalg_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00335">mlir::edsc::ops::linalg_dilated_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00287">mlir::edsc::ops::linalg_matmul()</a>, and <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00216">mlir::edsc::ops::linalg_pointwise()</a>.</p>

</div>
</div>
<a id="a331aa19dae759031f6493883e706c5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331aa19dae759031f6493883e706c5f9">&#9670;&nbsp;</a></span>makeHandlePointers()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html">ValueHandle</a> *, 8&gt; mlir::edsc::makeHandlePointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ivs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point to build multiple ValueHandle* from a mutable list <code>ivs</code> of T. </p>

<p class="definition">Definition at line <a class="el" href="EDSC_2Intrinsics_8h_source.html#l00064">64</a> of file <a class="el" href="EDSC_2Intrinsics_8h_source.html">Intrinsics.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLoops_8cpp_source.html#l00071">clip()</a>, <a class="el" href="LinalgToLoops_8cpp_source.html#l00071">emitLoopRanges()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00043">insertCopyLoops()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00129">makeGenericLinalgOp()</a>, and <a class="el" href="Tiling_8cpp_source.html#l00311">mlir::linalg::tileLinalgOp()</a>.</p>

</div>
</div>
<a id="a3015a0c7d1dafc7729d8242901ad9374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3015a0c7d1dafc7729d8242901ad9374">&#9670;&nbsp;</a></span>makeIndexHandles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="structmlir_1_1edsc_1_1IndexHandle.html">IndexHandle</a>, 8&gt; mlir::edsc::makeIndexHandles </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="EDSC_2Intrinsics_8h_source.html#l00057">57</a> of file <a class="el" href="EDSC_2Intrinsics_8h_source.html">Intrinsics.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertVectorToLoops_8cpp_source.html#l00071">clip()</a>, and <a class="el" href="MemoryPromotion_8cpp_source.html#l00043">insertCopyLoops()</a>.</p>

</div>
</div>
<a id="adf4a1e5a7cb44434fbb2a960332c86c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf4a1e5a7cb44434fbb2a960332c86c8">&#9670;&nbsp;</a></span>makeValueHandles()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;<a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html">ValueHandle</a>, 8&gt; mlir::edsc::makeValueHandles </td>
          <td>(</td>
          <td class="paramtype">Container&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point to build multiple <a class="el" href="classmlir_1_1edsc_1_1ValueHandle.html" title="ValueHandle implements a (potentially &quot;delayed&quot;) typed Value abstraction. ">ValueHandle</a> from a <code>Container</code> of <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> or <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a>. </p>

<p class="definition">Definition at line <a class="el" href="EDSC_2Builders_8h_source.html#l00541">541</a> of file <a class="el" href="EDSC_2Builders_8h_source.html">Builders.h</a>.</p>

<p class="reference">References <a class="el" href="EDSC_2Builders_8h_source.html#l00030">mlir::edsc::index_type::v</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00129">makeGenericLinalgOp()</a>.</p>

</div>
</div>
<a id="a52de97d5ace4e3c8f15cd35f1a5ff8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52de97d5ace4e3c8f15cd35f1a5ff8a3">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StringRef mlir::edsc::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371e">IterType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00087">87</a> of file <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html">Builders.h</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8h_source.html#l00064">mlir::getParallelIteratorTypeName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00069">mlir::getReductionIteratorTypeName()</a>, <a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371ea98402eecfbcefc336954458a01752131">Parallel</a>, and <a class="el" href="namespacemlir_1_1edsc.html#ae8511f7c9b194ab830b58cd6f15d371ea9e834f13e35e4edf64863ab414a6217a">Reduction</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00129">makeGenericLinalgOp()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jan 30 2020 18:40:02 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
