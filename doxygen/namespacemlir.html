<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">11.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mlir Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file provides some simple template functional-style sugar to operate on <b>value</b> types.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemlir_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1detail.html">detail</a></td></tr>
<tr class="memdesc:namespacemlir_1_1detail"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utilities for detecting if a given trait holds for some set of arguments 'Args'. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1edsc"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1edsc.html">edsc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1functional"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1functional.html">functional</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1fxpmath"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1fxpmath.html">fxpmath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1gpu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1gpu.html">gpu</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1impl"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1impl.html">impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1linalg"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1linalg.html">linalg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1LLVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1loop"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1loop.html">loop</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1matcher"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matcher.html">matcher</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1matchers"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1matchers.html">matchers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1NVVM"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ops__assertions"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ops__assertions.html">ops_assertions</a></td></tr>
<tr class="memdesc:namespacemlir_1_1ops__assertions"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded arithmetic operators for <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> expressions asserting that their arguments have the proper <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> expression subtype. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1OpTrait"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1OpTrait.html">OpTrait</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1quant"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1quant.html">quant</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1quantizer"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1quantizer.html">quantizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1ROCDL"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1spirv"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1spirv.html">spirv</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1StandardAttributes"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1StandardAttributes.html">StandardAttributes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1StandardTypes"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1StandardTypes.html">StandardTypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1tblgen"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1tblgen.html">tblgen</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemlir_1_1vector"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir_1_1vector.html">vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AbstractOperation.html">AbstractOperation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a "type erased" representation of a registered operation.  <a href="classmlir_1_1AbstractOperation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineApplyNormalizer.html">AffineApplyNormalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="structmlir_1_1AffineApplyNormalizer.html" title="An AffineApplyNormalizer is a helper class that supports renumbering operands of AffineApplyOp. ">AffineApplyNormalizer</a></code> is a helper class that supports renumbering operands of <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>.  <a href="structmlir_1_1AffineApplyNormalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineApplyOp.html">AffineApplyOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "affine.apply" operation applies an affine map to a list of operands, yielding a single result.  <a href="classmlir_1_1AffineApplyOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBinaryOpExpr.html">AffineBinaryOpExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Affine binary operation expression.  <a href="classmlir_1_1AffineBinaryOpExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineBound.html">AffineBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineBound.html" title="AffineBound represents a lower or upper bound in the for operation. ">AffineBound</a> represents a lower or upper bound in the for operation.  <a href="classmlir_1_1AffineBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineConstantExpr.html">AffineConstantExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer constant appearing in affine expression.  <a href="classmlir_1_1AffineConstantExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explicit copy / DMA generation options for <a class="el" href="namespacemlir.html#ad7e21be21731f5958cbe1b0dbc79c684" title="Performs explicit copying for the contiguous sequence of operations in the block iterator range [`beg...">mlir::affineDataCopyGenerate</a>.  <a href="structmlir_1_1AffineCopyOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDimExpr.html">AffineDimExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dimensional identifier appearing in an affine expression.  <a href="classmlir_1_1AffineDimExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaStartOp.html">AffineDmaStartOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineDmaStartOp.html" title="AffineDmaStartOp starts a non-blocking DMA operation that transfers data from a source memref to a de...">AffineDmaStartOp</a> starts a non-blocking DMA operation that transfers data from a source memref to a destination memref.  <a href="classmlir_1_1AffineDmaStartOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineDmaWaitOp.html">AffineDmaWaitOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1AffineDmaWaitOp.html" title="AffineDmaWaitOp blocks until the completion of a DMA operation associated with the tag element &#39;tag[i...">AffineDmaWaitOp</a> blocks until the completion of a DMA operation associated with the tag element 'tag[index]'.  <a href="classmlir_1_1AffineDmaWaitOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base type for affine expression.  <a href="classmlir_1_1AffineExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineExprVisitor.html">AffineExprVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> visitors/walkers.  <a href="classmlir_1_1AffineExprVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineLoadOp.html">AffineLoadOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "affine.load" op reads an element from a memref, where the index for each memref dimension is an affine expression of loop induction variables and symbols.  <a href="classmlir_1_1AffineLoadOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A multi-dimensional affine map Affine map's are immutable like <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a>'s, and they are uniqued.  <a href="classmlir_1_1AffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineMapAttr.html">AffineMapAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineOpsDialect.html">AffineOpsDialect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineStoreOp.html">AffineStoreOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The "affine.store" op writes an element to a memref, where the index for each memref dimension is an affine expression of loop induction variables and symbols.  <a href="classmlir_1_1AffineStoreOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineSymbolExpr.html">AffineSymbolExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbolic identifier appearing in an affine expression.  <a href="classmlir_1_1AffineSymbolExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AffineValueMap.html">AffineValueMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1AffineValueMap.html" title="An AffineValueMap is an affine map plus its ML value operands and results for analysis purposes...">AffineValueMap</a> is an affine map plus its ML value operands and results for analysis purposes.  <a href="classmlir_1_1AffineValueMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AnalysisManager.html">AnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an analysis manager for a particular operation instance.  <a href="classmlir_1_1AnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array attributes are lists of other attributes.  <a href="classmlir_1_1ArrayAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AsmState.html">AsmState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides management for the lifetime of the state used when printing the IR.  <a href="classmlir_1_1AsmState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes are known-constant values of operations and functions.  <a href="classmlir_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in an attribute.  <a href="classmlir_1_1AttributeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BaseMemRefType.html">BaseMemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base MemRef for Ranked and Unranked variants.  <a href="classmlir_1_1BaseMemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a></code> represents an ordered list of <code><a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a></code>s.  <a href="classmlir_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockArgument.html">BlockArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a> arguments are values.  <a href="classmlir_1_1BlockArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BlockOperand.html">BlockOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminator operations can have <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a> operands to represent successors.  <a href="classmlir_1_1BlockOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1BoolAttr.html">BoolAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Builder.html">Builder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a general helper class for creating context-global objects like types, attributes, and affine expressions.  <a href="classmlir_1_1Builder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallGraphNode.html">CallGraphNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single callable in the callgraph.  <a href="classmlir_1_1CallGraphNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1CallInterfaceCallable.html">CallInterfaceCallable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A callable is either a symbol, or an SSA value, that is referenced by a call-like operation.  <a href="structmlir_1_1CallInterfaceCallable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1CallSiteLoc.html">CallSiteLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location as call site.  <a href="classmlir_1_1CallSiteLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ClassID.html">ClassID</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special type used to provide an address for a given class that can act as a unique identifier during pass registration.  <a href="structmlir_1_1ClassID.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ComplexType.html">ComplexType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The 'complex' type represents a complex number with a parameterized element type, which is composed of a real and imaginary value of that element type.  <a href="classmlir_1_1ComplexType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1ComputationSliceState.html" title="ComputationSliceState aggregates loop IVs, loop bound AffineMaps and their associated operands for a ...">ComputationSliceState</a> aggregates loop IVs, loop bound AffineMaps and their associated operands for a set of loops within a loop nest (typically the set of loops surrounding a store operation).  <a href="structmlir_1_1ComputationSliceState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantFloatOp.html">ConstantFloatOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a refinement of the "constant" op for the case where it is returning a float value of <a class="el" href="classmlir_1_1FloatType.html">FloatType</a>.  <a href="classmlir_1_1ConstantFloatOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantIndexOp.html">ConstantIndexOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a refinement of the "constant" op for the case where it is returning an integer value of Index type.  <a href="classmlir_1_1ConstantIndexOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConstantIntOp.html">ConstantIntOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a refinement of the "constant" op for the case where it is returning an integer value of <a class="el" href="classmlir_1_1IntegerType.html" title="Integer types can have arbitrary bitwidth up to a large fixed limit. ">IntegerType</a>.  <a href="classmlir_1_1ConstantIntOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPattern.html">ConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for the conversion patterns that require type changes.  <a href="classmlir_1_1ConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionPatternRewriter.html">ConversionPatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a pattern rewriter for use with ConversionPatterns.  <a href="classmlir_1_1ConversionPatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class describes a specific conversion target.  <a href="classmlir_1_1ConversionTarget.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseElementsAttr.html">DenseElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense vector or tensor object.  <a href="classmlir_1_1DenseElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseFPElementsAttr.html">DenseFPElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense float vector or tensor object.  <a href="classmlir_1_1DenseFPElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DenseIntElementsAttr.html">DenseIntElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a dense integer vector or tensor object.  <a href="classmlir_1_1DenseIntElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether two accesses to the same memref access the same element.  <a href="structmlir_1_1DependenceResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains all of the information necessary to report a diagnostic to the <a class="el" href="classmlir_1_1DiagnosticEngine.html" title="This class is the main interface for diagnostics. ">DiagnosticEngine</a>.  <a href="classmlir_1_1Diagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A variant type that holds a single argument for a diagnostic.  <a href="classmlir_1_1DiagnosticArgument.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DiagnosticEngine.html">DiagnosticEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is the main interface for diagnostics.  <a href="classmlir_1_1DiagnosticEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dialects are groups of MLIR operations and behavior associated with the entire group.  <a href="classmlir_1_1Dialect.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmParser.html">DialectAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1DialectAsmParser.html" title="The DialectAsmParser has methods for interacting with the asm parser: parsing things from it...">DialectAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  <a href="classmlir_1_1DialectAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom printAttribute/printType() method on a dialect.  <a href="classmlir_1_1DialectAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectHooks.html">DialectHooks</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations and behavior associated with the entire group. ">Dialect</a> hooks allow external components to register their functions to be called for specific tasks specialized per dialect, such as decoding of opaque constants.  <a href="classmlir_1_1DialectHooks.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DialectHooksRegistration.html">DialectHooksRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1DialectHooksRegistration.html" title="DialectHooksRegistration provides a global initializer that registers a dialect hooks setter routine...">DialectHooksRegistration</a> provides a global initializer that registers a dialect hooks setter routine.  <a href="structmlir_1_1DialectHooksRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInlinerInterface.html">DialectInlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the interface that must be implemented by the dialects of operations to be inlined.  <a href="classmlir_1_1DialectInlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterface.html">DialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an interface overridden for a single dialect.  <a href="classmlir_1_1DialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DialectInterfaceCollection.html">DialectInterfaceCollection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A collection of dialect interfaces within a context, for a given concrete interface type.  <a href="classmlir_1_1DialectInterfaceCollection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1DialectRegistration.html">DialectRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1DialectRegistration.html" title="DialectRegistration provides a global initializer that registers a Dialect allocation routine...">DialectRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Dialect.html" title="Dialects are groups of MLIR operations and behavior associated with the entire group. ">Dialect</a> allocation routine.  <a href="structmlir_1_1DialectRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DictionaryAttr.html">DictionaryAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dictionary attribute is an attribute that represents a sorted collection of named attribute values.  <a href="classmlir_1_1DictionaryAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DmaStartOp.html">DmaStartOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DmaWaitOp.html">DmaWaitOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1DominanceInfo.html">DominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic dominance information.  <a href="classmlir_1_1DominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ElementsAttr.html">ElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base attribute that represents a reference to a static shaped tensor or vector constant.  <a href="classmlir_1_1ElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1EmptyPipelineOptions.html">EmptyPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A default empty option struct to be used for passes that do not need to take any options.  <a href="structmlir_1_1EmptyPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ExecutionEngine.html">ExecutionEngine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">JIT-backed execution engine for MLIR modules.  <a href="classmlir_1_1ExecutionEngine.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FileLineColLoc.html">FileLineColLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location derived from a file/line/column location.  <a href="classmlir_1_1FileLineColLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FilteredValueUseIterator.html">FilteredValueUseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an iterator of the uses of a IR object that optionally filters on a specific sub-value.  <a href="classmlir_1_1FilteredValueUseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A flat list of affine equalities and inequalities in the form.  <a href="classmlir_1_1FlatAffineConstraints.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FlatSymbolRefAttr.html">FlatSymbolRefAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol reference with a reference path containing a single element.  <a href="classmlir_1_1FlatSymbolRefAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FloatAttr.html">FloatAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FloatType.html">FloatType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FoldingHook.html">FoldingHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template defines the foldHook as used by <a class="el" href="classmlir_1_1AbstractOperation.html" title="This is a &quot;type erased&quot; representation of a registered operation. ">AbstractOperation</a>.  <a href="classmlir_1_1FoldingHook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FoldingHook_3_01ConcreteType_00_01isSingleResult_00_01typename_01std_1_1enable__if_189bf6924ecff7e8cff06519bed3e164.html">FoldingHook&lt; ConcreteType, isSingleResult, typename std::enable_if&lt; isSingleResult &gt;::type &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template specialization defines the foldHook as used by <a class="el" href="classmlir_1_1AbstractOperation.html" title="This is a &quot;type erased&quot; representation of a registered operation. ">AbstractOperation</a> for single-result operations.  <a href="classmlir_1_1FoldingHook_3_01ConcreteType_00_01isSingleResult_00_01typename_01std_1_1enable__if_189bf6924ecff7e8cff06519bed3e164.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1FuncOp.html" title="FuncOp represents a function, or an operation containing one region that forms a CFG(Control Flow Gra...">FuncOp</a> represents a function, or an operation containing one region that forms a CFG(Control Flow Graph).  <a href="classmlir_1_1FuncOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FunctionPass.html">FunctionPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A model for providing function pass specific utilities.  <a href="structmlir_1_1FunctionPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FunctionTraits.html">FunctionTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides various trait information about a callable object.  <a href="structmlir_1_1FunctionTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FunctionTraits_3_01ReturnType_07_5_08_07Args_8_8_8_08_00_01false_01_4.html">FunctionTraits&lt; ReturnType(*)(Args...), false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for non-class function types.  <a href="structmlir_1_1FunctionTraits_3_01ReturnType_07_5_08_07Args_8_8_8_08_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FunctionTraits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_00_01false_01_4.html">FunctionTraits&lt; ReturnType(ClassType::*)(Args...) const, false &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload for class function types.  <a href="structmlir_1_1FunctionTraits_3_01ReturnType_07ClassType_1_1_5_08_07Args_8_8_8_08_01const_00_01false_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FunctionType.html">FunctionType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function types map from a list of inputs to a list of results.  <a href="classmlir_1_1FunctionType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1FusedLoc.html">FusedLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a value composed of multiple source constructs, with an optional metadata attribute.  <a href="classmlir_1_1FusedLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1GenInfo.html">GenInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a generator (argument to invoke via mlir-tblgen, description, and generator function).  <a href="classmlir_1_1GenInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenNameParser.html">GenNameParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds command line option for each registered generator.  <a href="structmlir_1_1GenNameParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GenRegistration.html">GenRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1GenRegistration.html" title="GenRegistration provides a global initializer that registers a generator function. ">GenRegistration</a> provides a global initializer that registers a generator function.  <a href="structmlir_1_1GenRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1GPUIndexIntrinsicOpLowering.html">GPUIndexIntrinsicOpLowering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a uniqued string owned by an <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a>.  <a href="classmlir_1_1Identifier.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1indexed__accessor__iterator.html">indexed_accessor_iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class used to implement an iterator that contains some base object and an index.  <a href="classmlir_1_1indexed__accessor__iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1indexed__accessor__range.html">indexed_accessor_range</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an implementation of a range of indexed_accessor_iterators where the base is not indexable.  <a href="classmlir_1_1indexed__accessor__range.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IndexType.html">IndexType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index is a special integer-like type with unknown platform-dependent bit width.  <a href="classmlir_1_1IndexType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a diagnostic that is inflight and set to be reported.  <a href="classmlir_1_1InFlightDiagnostic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This interface provides the hooks into the inlining interface.  <a href="classmlir_1_1InlinerInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerAttr.html">IntegerAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An integer set representing a conjunction of one or more affine equalities and inequalities.  <a href="classmlir_1_1IntegerSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerSetAttr.html">IntegerSetAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerType.html">IntegerType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer types can have arbitrary bitwidth up to a large fixed limit.  <a href="classmlir_1_1IntegerType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntegerValueSet.html">IntegerValueSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1IntegerValueSet.html" title="An IntegerValueSet is an integer set plus its operands. ">IntegerValueSet</a> is an integer set plus its operands.  <a href="classmlir_1_1IntegerValueSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> to represent an integer with potentially infinite positive value.  <a href="classmlir_1_1IntInfty.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRMultiObjectWithUseList.html">IRMultiObjectWithUseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents multiple IR objects with a single use list.  <a href="classmlir_1_1IRMultiObjectWithUseList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IRObjectWithUseList.html">IRObjectWithUseList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single IR object that contains a use list.  <a href="classmlir_1_1IRObjectWithUseList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1IROperand.html">IROperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a value, suitable for use as an operand of an operation.  <a href="classmlir_1_1IROperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Lexer.html">Lexer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class breaks up the current file into a token stream.  <a href="classmlir_1_1Lexer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LinalgTypeConverter.html">LinalgTypeConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Liveness.html">Liveness</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an analysis for computing liveness information from a given top-level operation.  <a href="classmlir_1_1Liveness.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LivenessBlockInfo.html">LivenessBlockInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents liveness information on block level.  <a href="classmlir_1_1LivenessBlockInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMOpLowering.html">LLVMOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for operation conversions targeting the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1LLVMOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conversion from types in the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect.  <a href="classmlir_1_1LLVMTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Location.html">Location</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around a <a class="el" href="classmlir_1_1LocationAttr.html" title="Location objects represent source locations information in MLIR. ">LocationAttr</a>.  <a href="classmlir_1_1Location.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1LocationAttr.html">LocationAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> objects represent source locations information in MLIR.  <a href="classmlir_1_1LocationAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1LoopNestStats.html" title="LoopNestStats aggregates various per-loop statistics (eg. ">LoopNestStats</a> aggregates various per-loop statistics (eg.  <a href="structmlir_1_1LoopNestStats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates a memref load or store access information.  <a href="structmlir_1_1MemRefAccess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefDescriptor.html">MemRefDescriptor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting elements of a MemRef descriptor.  <a href="classmlir_1_1MemRefDescriptor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MemRefRegion.html">MemRefRegion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A region of a memref's data space; this is typically constructed by analyzing load/store op's on this memref and the index space of loops surrounding such op's.  <a href="structmlir_1_1MemRefRegion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MemRef types represent a region of memory that have a shape with a fixed number of dimensions.  <a href="classmlir_1_1MemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a> is the top-level object for a collection of MLIR modules.  <a href="classmlir_1_1MLIRContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1MLIRContextImpl.html">MLIRContextImpl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the implementation of the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a> class, using the pImpl idiom.  <a href="classmlir_1_1MLIRContextImpl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModuleAnalysisManager.html">ModuleAnalysisManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An analysis manager class specifically for the top-level module operation.  <a href="classmlir_1_1ModuleAnalysisManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ModuleOp.html" title="ModuleOp represents a module, or an operation containing one region with a single block containing op...">ModuleOp</a> represents a module, or an operation containing one region with a single block containing opaque operations.  <a href="classmlir_1_1ModuleOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1ModulePass.html">ModulePass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A model for providing module pass specific utilities.  <a href="structmlir_1_1ModulePass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ModuleTerminatorOp.html">ModuleTerminatorOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1ModuleTerminatorOp.html" title="The ModuleTerminatorOp is a special terminator operation for the body of a ModuleOp, it has no semantic meaning beyond keeping the body of a ModuleOp well-formed. ">ModuleTerminatorOp</a> is a special terminator operation for the body of a <a class="el" href="classmlir_1_1ModuleOp.html" title="ModuleOp represents a module, or an operation containing one region with a single block containing op...">ModuleOp</a>, it has no semantic meaning beyond keeping the body of a <a class="el" href="classmlir_1_1ModuleOp.html" title="ModuleOp represents a module, or an operation containing one region with a single block containing op...">ModuleOp</a> well-formed.  <a href="classmlir_1_1ModuleTerminatorOp.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MutableAffineMap.html">MutableAffineMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable affine map. Its affine expressions are however unique.  <a href="structmlir_1_1MutableAffineMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1MutableIntegerSet.html">MutableIntegerSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mutable integer set. Its affine expressions are however unique.  <a href="structmlir_1_1MutableIntegerSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NamedAttributeList.html">NamedAttributeList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1NamedAttributeList.html" title="A NamedAttributeList is used to manage a list of named attributes. ">NamedAttributeList</a> is used to manage a list of named attributes.  <a href="classmlir_1_1NamedAttributeList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NameLoc.html">NameLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an identity name attached to a child location.  <a href="classmlir_1_1NameLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedMatch.html">NestedMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> captures nested patterns in the IR.  <a href="classmlir_1_1NestedMatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NestedPatternContext.html">NestedPatternContext</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">RAII structure to transparently manage the bump allocator for <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> and <a class="el" href="classmlir_1_1NestedMatch.html" title="An NestedPattern captures nested patterns in the IR. ">NestedMatch</a> classes.  <a href="classmlir_1_1NestedPatternContext.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1NoneType.html">NoneType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1NoneType.html" title="NoneType is a unit type, i.e. ">NoneType</a> is a unit type, i.e.  <a href="classmlir_1_1NoneType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Op.html">Op</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This provides public APIs that all operations should have.  <a href="classmlir_1_1Op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueAttr.html">OpaqueAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque attributes represent attributes of non-registered dialects.  <a href="classmlir_1_1OpaqueAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueElementsAttr.html">OpaqueElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An opaque attribute that represents a reference to a vector or tensor constant with opaque content.  <a href="classmlir_1_1OpaqueElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueLoc.html">OpaqueLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a location that is external to MLIR.  <a href="classmlir_1_1OpaqueLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpaqueType.html">OpaqueType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque types represent types of non-registered dialects.  <a href="classmlir_1_1OpaqueType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmDialectInterface.html">OpAsmDialectInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classmlir_1_1OpAsmParser.html" title="The OpAsmParser has methods for interacting with the asm parser: parsing things from it...">OpAsmParser</a> has methods for interacting with the asm parser: parsing things from it, emitting errors etc.  <a href="classmlir_1_1OpAsmParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a pure-virtual base class that exposes the asmprinter hooks necessary to implement a custom <a class="el" href="AffineOps_8cpp.html#a7a4c0c8d777ec2f19a412cb98fc33b7e">print()</a> method.  <a href="classmlir_1_1OpAsmPrinter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class helps build Operations.  <a href="classmlir_1_1OpBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpConversionPattern.html">OpConversionPattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpConversionPattern.html" title="OpConversionPattern is a wrapper around ConversionPattern that allows for matching and rewriting agai...">OpConversionPattern</a> is a wrapper around <a class="el" href="classmlir_1_1ConversionPattern.html" title="Base class for the conversion patterns that require type changes. ">ConversionPattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a>.  <a href="structmlir_1_1OpConversionPattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperandRange.html">OperandRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the operand iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a> class.  <a href="classmlir_1_1OperandRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Operation.html">Operation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a> is a basic unit of execution within a function.  <a href="classmlir_1_1Operation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationFolder.html">OperationFolder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class for folding operations, and unifying duplicated constants generated along the way.  <a href="classmlir_1_1OperationFolder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OperationPass.html">OperationPass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to transform an operation of a specific type.  <a href="classmlir_1_1OperationPass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationPass_3_01PassT_00_01void_01_4.html">OperationPass&lt; PassT, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to transform an operation.  <a href="structmlir_1_1OperationPass_3_01PassT_00_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OperationState.html">OperationState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents an operation in an abstracted form, suitable for use with the builder APIs.  <a href="structmlir_1_1OperationState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFolderDialectInterface.html">OpFolderDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class defines a dialect interface used to assist the operation folder.  <a href="classmlir_1_1OpFolderDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpFoldResult.html">OpFoldResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a single result from folding an operation.  <a href="classmlir_1_1OpFoldResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpInterface.html">OpInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the base of an operation interface.  <a href="classmlir_1_1OpInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a value, suitable for use as an operand of an operation.  <a href="classmlir_1_1OpOperand.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility base class for OpPass below to denote an opaque pass operating on a specific operation type.  <a href="classmlir_1_1OpPassBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a pass manager that runs passes on a specific operation type.  <a href="classmlir_1_1OpPassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpPrintingFlags.html">OpPrintingFlags</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of flags used to control the behavior of the various IR print methods (e.g.  <a href="classmlir_1_1OpPrintingFlags.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpResult.html">OpResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a value defined by a result of an operation.  <a href="classmlir_1_1OpResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpRewritePattern.html">OpRewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1OpRewritePattern.html" title="OpRewritePattern is a wrapper around RewritePattern that allows for matching and rewriting against an...">OpRewritePattern</a> is a wrapper around <a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> that allows for matching and rewriting against an instance of a derived operation class as opposed to a raw <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a>.  <a href="structmlir_1_1OpRewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OpState.html">OpState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the concrete base class that holds the operation pointer and has non-generic methods that only depend on State (to avoid having them instantiated on template types that don't affect them.  <a href="classmlir_1_1OpState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OptionalParseResult.html">OptionalParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <code>Optional</code> functionality for <a class="el" href="classmlir_1_1ParseResult.html" title="This class represents success/failure for operation parsing. ">ParseResult</a>.  <a href="classmlir_1_1OptionalParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1OpToFuncCallLowering.html">OpToFuncCallLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewriting that replace SourceOp with a CallOp to <code>f32Func</code> or <code>f64Func</code> depending on the element type that <a class="el" href="classmlir_1_1Op.html" title="This provides public APIs that all operations should have. ">Op</a> operates upon.  <a href="structmlir_1_1OpToFuncCallLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as an owning reference to a module, and will automatically destroy the held module if valid.  <a href="classmlir_1_1OwningModuleRef.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParallelDiagnosticHandler.html">ParallelDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use when multi-threading some part of the compiler where diagnostics may be emitted.  <a href="classmlir_1_1ParallelDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents success/failure for operation parsing.  <a href="classmlir_1_1ParseResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pass.html">Pass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The abstract base pass class.  <a href="classmlir_1_1Pass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInfo.html">PassInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information for a derived pass class.  <a href="classmlir_1_1PassInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentation.html">PassInstrumentation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure. ">PassInstrumentation</a> provides several entry points into the pass manager infrastructure.  <a href="classmlir_1_1PassInstrumentation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassInstrumentor.html">PassInstrumentor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class holds a collection of <a class="el" href="classmlir_1_1PassInstrumentation.html" title="PassInstrumentation provides several entry points into the pass manager infrastructure. ">PassInstrumentation</a> objects, and invokes their respective call backs.  <a href="classmlir_1_1PassInstrumentor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main pass manager and pipeline builder.  <a href="classmlir_1_1PassManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a command-line parser for MLIR passes.  <a href="classmlir_1_1PassPipelineCLParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineInfo.html">PassPipelineInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A structure to represent the information of a registered pass pipeline.  <a href="classmlir_1_1PassPipelineInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassPipelineOptions.html">PassPipelineOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subclasses of <a class="el" href="classmlir_1_1PassPipelineOptions.html" title="Subclasses of PassPipelineOptions provide a set of options that can be used to initialize a pass pipe...">PassPipelineOptions</a> provide a set of options that can be used to initialize a pass pipeline.  <a href="classmlir_1_1PassPipelineOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration.html">PassPipelineRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> pipeline builder routine.  <a href="structmlir_1_1PassPipelineRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html">PassPipelineRegistration&lt; EmptyPipelineOptions &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> for EmptyPassOptions that does not pass an empty options struct to the pass builder function.  <a href="structmlir_1_1PassPipelineRegistration_3_01EmptyPipelineOptions_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1PassRegistration.html">PassRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> provides a global initializer that registers a <a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> allocation routine for a concrete pass instance.  <a href="structmlir_1_1PassRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PassRegistryEntry.html">PassRegistryEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to group information about a passes and pass pipelines (argument to invoke via mlir-opt, description, pass pipeline builder).  <a href="classmlir_1_1PassRegistryEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Pattern.html">Pattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of <a class="el" href="classmlir_1_1Pattern.html" title="Instances of Pattern can be matched against SSA IR. ">Pattern</a> can be matched against SSA IR.  <a href="classmlir_1_1Pattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternBenefit.html">PatternBenefit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents the benefit of a pattern match in a unitless scheme that ranges from 0 (very little benefit) to 65K.  <a href="classmlir_1_1PatternBenefit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternRewriter.html">PatternRewriter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class coordinates the application of a pattern to the current function, providing a way to create operations and keep track of what gets deleted.  <a href="classmlir_1_1PatternRewriter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PatternState.html">PatternState</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pattern.html" title="Instances of Pattern can be matched against SSA IR. ">Pattern</a> state is used by patterns that want to maintain state between their match and rewrite phases.  <a href="classmlir_1_1PatternState.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PostDominanceInfo.html">PostDominanceInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class for computing basic postdominance information.  <a href="classmlir_1_1PostDominanceInfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1PredecessorIterator.html">PredecessorIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implement a predecessor iterator for blocks.  <a href="classmlir_1_1PredecessorIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RankedTensorType.html">RankedTensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ranked tensor types represent multi-dimensional arrays that have a shape with a fixed number of dimensions.  <a href="classmlir_1_1RankedTensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Region.html">Region</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class contains a list of basic blocks and a link to the parent operation it is attached to.  <a href="classmlir_1_1Region.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RegionRange.html">RegionRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Regions.  <a href="classmlir_1_1RegionRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ResultRange.html">ResultRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the result iterators for the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a> class.  <a href="classmlir_1_1ResultRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePattern.html">RewritePattern</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1RewritePattern.html" title="RewritePattern is the common base class for all DAG to DAG replacements. ">RewritePattern</a> is the common base class for all DAG to DAG replacements.  <a href="classmlir_1_1RewritePattern.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1RewritePatternMatcher.html">RewritePatternMatcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class manages optimization and execution of a group of rewrite patterns, providing an API for finding and applying, the best match against a given node.  <a href="classmlir_1_1RewritePatternMatcher.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ScopedDiagnosticHandler.html">ScopedDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This diagnostic handler is a simple RAII class that registers and erases a diagnostic handler on a given context.  <a href="classmlir_1_1ScopedDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBM.html">SDBM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs interpreted as inequalities "expr &lt;= 0".  <a href="classmlir_1_1SDBM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMConstantExpr.html">SDBMConstantExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> constant expression, wraps a 64-bit integer.  <a href="classmlir_1_1SDBMConstantExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMDialect.html">SDBMDialect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMDiffExpr.html">SDBMDiffExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> difference expression.  <a href="classmlir_1_1SDBMDiffExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMDimExpr.html">SDBMDimExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> dimension expression.  <a href="classmlir_1_1SDBMDimExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMDirectExpr.html">SDBMDirectExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> direct expression includes exactly one variable (symbol or dimension), which is not negated in the expression.  <a href="classmlir_1_1SDBMDirectExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMExpr.html">SDBMExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Striped Difference-Bounded Matrix (<a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a>) expression is a base left-hand side expression for the <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> framework.  <a href="classmlir_1_1SDBMExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMInputExpr.html">SDBMInputExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> "input" variable expression can be either a dimension identifier or a symbol identifier.  <a href="classmlir_1_1SDBMInputExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMNegExpr.html">SDBMNegExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Negation of an <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> variable expression.  <a href="classmlir_1_1SDBMNegExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMStripeExpr.html">SDBMStripeExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> stripe expression "x # C" where "x" is a term expression, "C" is a constant expression and "#" is the stripe operator defined as: x # C = x - x mod C.  <a href="classmlir_1_1SDBMStripeExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMSumExpr.html">SDBMSumExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> sum expression. LHS is a term expression and RHS is a constant.  <a href="classmlir_1_1SDBMSumExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMSymbolExpr.html">SDBMSymbolExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> symbol expression.  <a href="classmlir_1_1SDBMSymbolExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMTermExpr.html">SDBMTermExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> term expression can be one of:  <a href="classmlir_1_1SDBMTermExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMVaryingExpr.html">SDBMVaryingExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> varying expression can be one of:  <a href="classmlir_1_1SDBMVaryingExpr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SDBMVisitor.html">SDBMVisitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A visitor class for <a class="el" href="classmlir_1_1SDBM.html" title="Striped difference-bound matrix is a representation of an integer set bound by a system of SDBMExprs ...">SDBM</a> expressions.  <a href="classmlir_1_1SDBMVisitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapedType.html">ShapedType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a common base class between Vector, UnrankedTensor, RankedTensor, and MemRef types because they share behavior and semantics around shape, rank, and fixed element type.  <a href="classmlir_1_1ShapedType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ShapedTypeComponents.html">ShapedTypeComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1ShapedTypeComponents.html" title="ShapedTypeComponents that represents the components of a ShapedType. ">ShapedTypeComponents</a> that represents the components of a <a class="el" href="classmlir_1_1ShapedType.html" title="This is a common base class between Vector, UnrankedTensor, RankedTensor, and MemRef types because th...">ShapedType</a>.  <a href="classmlir_1_1ShapedTypeComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SideEffectsDialectInterface.html">SideEffectsDialectInterface</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies an interface for basic side-effect modelling that is used by the loop-invariant code motion pass.  <a href="classmlir_1_1SideEffectsDialectInterface.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SideEffectsInterface.html">SideEffectsInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleAffineExprFlattener.html">SimpleAffineExprFlattener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SimpleObjectCache.html">SimpleObjectCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple object cache following Lang's LLJITWithObjectCache example.  <a href="classmlir_1_1SimpleObjectCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html">SourceMgrDiagnosticHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr.  <a href="classmlir_1_1SourceMgrDiagnosticHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html">SourceMgrDiagnosticVerifierHandler</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a utility diagnostic handler for use with llvm::SourceMgr that verifies that emitted diagnostics match 'expected-*' lines on the corresponding line of the source file.  <a href="classmlir_1_1SourceMgrDiagnosticVerifierHandler.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SparseElementsAttr.html">SparseElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a sparse vector or tensor object.  <a href="classmlir_1_1SparseElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVOpLowering.html">SPIRVOpLowering</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class to define a conversion pattern to lower <code>SourceOp</code> into SPIR-V.  <a href="classmlir_1_1SPIRVOpLowering.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> conversion from standard types to SPIR-V types for shader interface.  <a href="classmlir_1_1SPIRVTypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SplatElementsAttr.html">SplatElementsAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An attribute that represents a reference to a splat vector or tensor constant, meaning all of the elements have the same value.  <a href="classmlir_1_1SplatElementsAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StandardOpsDialect.html">StandardOpsDialect</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StorageUniquer.html">StorageUniquer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility class to get, or create instances of storage classes.  <a href="classmlir_1_1StorageUniquer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StringAttr.html">StringAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1StructBuilder.html">StructBuilder</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class to produce <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect operations extracting or inserting values to a struct.  <a href="classmlir_1_1StructBuilder.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SuccessorRange.html">SuccessorRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements the successor iterators for <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.  <a href="classmlir_1_1SuccessorRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolRefAttr.html">SymbolRefAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A symbol reference attribute represents a symbolic reference to another operation.  <a href="classmlir_1_1SymbolRefAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1SymbolTable.html">SymbolTable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class allows for representing and managing the symbol table used by operations with the '<a class="el" href="classmlir_1_1SymbolTable.html" title="This class allows for representing and managing the symbol table used by operations with the &#39;SymbolT...">SymbolTable</a>' trait.  <a href="classmlir_1_1SymbolTable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TensorType.html">TensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tensor types represent multi-dimensional arrays, and have two variants: <a class="el" href="classmlir_1_1RankedTensorType.html" title="Ranked tensor types represent multi-dimensional arrays that have a shape with a fixed number of dimen...">RankedTensorType</a> and <a class="el" href="classmlir_1_1UnrankedTensorType.html" title="Unranked tensor types represent multi-dimensional arrays that have an unknown shape. ">UnrankedTensorType</a>.  <a href="classmlir_1_1TensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Token.html">Token</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a token in the MLIR syntax.  <a href="classmlir_1_1Token.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateFromMLIRRegistration.html">TranslateFromMLIRRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateRegistration.html">TranslateRegistration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslateToMLIRRegistration.html">TranslateToMLIRRegistration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use Translate[ToMLIR|FromMLIR]Registration as a global initializer that registers a function and associates it with name.  <a href="structmlir_1_1TranslateToMLIRRegistration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmlir_1_1TranslationParser.html">TranslationParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Custom parser for TranslateFunction.  <a href="structmlir_1_1TranslationParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TupleType.html">TupleType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple types represent a collection of other types.  <a href="classmlir_1_1TupleType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html">Type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> class are immutable and uniqued.  <a href="classmlir_1_1Type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeAttr.html">TypeAttr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for type conversion interface.  <a href="classmlir_1_1TypeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base storage class appearing in a <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a>.  <a href="classmlir_1_1TypeStorage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeSwitch.html">TypeSwitch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a switch-like dispatch statement for a value of 'T' using dyn_cast functionality.  <a href="classmlir_1_1TypeSwitch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1TypeSwitch_3_01T_00_01void_01_4.html">TypeSwitch&lt; T, void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of <a class="el" href="classmlir_1_1TypeSwitch.html" title="This class implements a switch-like dispatch statement for a value of &#39;T&#39; using dyn_cast functionalit...">TypeSwitch</a> for void returning callables.  <a href="classmlir_1_1TypeSwitch_3_01T_00_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnitAttr.html">UnitAttr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unit attributes are attributes that hold no specific value and are given meaning by their existence.  <a href="classmlir_1_1UnitAttr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnknownLoc.html">UnknownLoc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an unknown location.  <a href="classmlir_1_1UnknownLoc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedMemRefDescriptor.html">UnrankedMemRefDescriptor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedMemRefType.html">UnrankedMemRefType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unranked MemRef type represent multi-dimensional MemRefs that have an unknown rank.  <a href="classmlir_1_1UnrankedMemRefType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1UnrankedTensorType.html">UnrankedTensorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unranked tensor types represent multi-dimensional arrays that have an unknown shape.  <a href="classmlir_1_1UnrankedTensorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents an instance of an SSA value in the MLIR system, representing a computable value that has a type and a set of users.  <a href="classmlir_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueRange.html">ValueRange</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides an abstraction over the different types of ranges over Values.  <a href="classmlir_1_1ValueRange.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueTypeIterator.html">ValueTypeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements iteration on the types of a given range of values.  <a href="classmlir_1_1ValueTypeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUseIterator.html">ValueUseIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over all of the uses of an IR object.  <a href="classmlir_1_1ValueUseIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1ValueUserIterator.html">ValueUserIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator over all users of a ValueBase.  <a href="classmlir_1_1ValueUserIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VectorType.html">VectorType</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector types represent multi-dimensional SIMD vectors, and have a fixed known constant shape with one or more dimension.  <a href="classmlir_1_1VectorType.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1VulkanLayoutUtils.html">VulkanLayoutUtils</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">According to the Vulkan spec "14.5.4. Offset and Stride Assignment": "There are different alignment requirements depending on the specific resources and on the features enabled on the device.  <a href="classmlir_1_1VulkanLayoutUtils.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1WalkResult.html">WalkResult</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility result that is used to signal if a walk method should be interrupted or advance.  <a href="classmlir_1_1WalkResult.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aedbc3d0362a57c5175f05dd95fb59641"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">DominanceInfoNode</a> = llvm::DomTreeNodeBase&lt; <a class="el" href="classmlir_1_1Block.html">Block</a> &gt;</td></tr>
<tr class="separator:aedbc3d0362a57c5175f05dd95fb59641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10a637dbeb6e0d2178032f95fb5ea1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa10a637dbeb6e0d2178032f95fb5ea1b">VectorizableLoopFun</a> = std::function&lt; bool(AffineForOp)&gt;</td></tr>
<tr class="separator:aa10a637dbeb6e0d2178032f95fb5ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a899fdaa9e41cd3d5abb2b4cc44dba232">FilterFunctionType</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that:  <a href="#a899fdaa9e41cd3d5abb2b4cc44dba232">More...</a><br /></td></tr>
<tr class="separator:a899fdaa9e41cd3d5abb2b4cc44dba232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389845a5dc285d746b24f6012a0ca2e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> = std::function&lt; bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td></tr>
<tr class="memdesc:a389845a5dc285d746b24f6012a0ca2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> of the condition to limit the propagation of transitive use-defs.  <a href="#a389845a5dc285d746b24f6012a0ca2e3">More...</a><br /></td></tr>
<tr class="separator:a389845a5dc285d746b24f6012a0ca2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49966a7e55b91f74977c5e65a1ce9b48"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a49966a7e55b91f74977c5e65a1ce9b48">OwnedCubin</a> = std::unique_ptr&lt; std::vector&lt; char &gt; &gt;</td></tr>
<tr class="separator:a49966a7e55b91f74977c5e65a1ce9b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac778e98bba4a5f7b76ead3e1d37c6892"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac778e98bba4a5f7b76ead3e1d37c6892">CubinGenerator</a> = std::function&lt; <a class="el" href="namespacemlir.html#a49966a7e55b91f74977c5e65a1ce9b48">OwnedCubin</a>(const std::string &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, StringRef)&gt;</td></tr>
<tr class="separator:ac778e98bba4a5f7b76ead3e1d37c6892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021ec11591c1abe2294a6c0a9e5caa29"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a021ec11591c1abe2294a6c0a9e5caa29">LLVMPatternListFiller</a> = std::function&lt; void(<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a021ec11591c1abe2294a6c0a9e5caa29"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> for a callback constructing the owning list of patterns for the conversion to the LLVMIR dialect.  <a href="#a021ec11591c1abe2294a6c0a9e5caa29">More...</a><br /></td></tr>
<tr class="separator:a021ec11591c1abe2294a6c0a9e5caa29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a624defb326870761dd5923452a374"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab4a624defb326870761dd5923452a374">LLVMTypeConverterMaker</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &gt;(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:ab4a624defb326870761dd5923452a374"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> for a callback constructing the type converter for the conversion to the LLVMIR dialect.  <a href="#ab4a624defb326870761dd5923452a374">More...</a><br /></td></tr>
<tr class="separator:ab4a624defb326870761dd5923452a374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd440a077557b4421b2cfd06d48956a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">NamedAttribute</a> = std::pair&lt; <a class="el" href="classmlir_1_1Identifier.html">Identifier</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;</td></tr>
<tr class="memdesc:a2bd440a077557b4421b2cfd06d48956a"><td class="mdescLeft">&#160;</td><td class="mdescRight">NamedAttribute is used for dictionary attributes, it holds an identifier for the name and a value for the attribute.  <a href="#a2bd440a077557b4421b2cfd06d48956a">More...</a><br /></td></tr>
<tr class="separator:a2bd440a077557b4421b2cfd06d48956a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759bdae349015b16ce375bdd46c1e16c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">DefaultAttributeStorage</a> = <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td></tr>
<tr class="memdesc:a759bdae349015b16ce375bdd46c1e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for attributes that require no additional initialization or storage.  <a href="#a759bdae349015b16ce375bdd46c1e16c">More...</a><br /></td></tr>
<tr class="separator:a759bdae349015b16ce375bdd46c1e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8f5011648c4f698028afb8a96b31ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">AttributeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="separator:aad8f5011648c4f698028afb8a96b31ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9632a07fcad8faa7c654d03748218864"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9632a07fcad8faa7c654d03748218864">DialectConstantDecodeHook</a> = std::function&lt; bool(const <a class="el" href="classmlir_1_1OpaqueElementsAttr.html">OpaqueElementsAttr</a>, <a class="el" href="classmlir_1_1ElementsAttr.html">ElementsAttr</a> &amp;)&gt;</td></tr>
<tr class="separator:a9632a07fcad8faa7c654d03748218864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3c2070dfa94ad02acc17bed0273d64"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb3c2070dfa94ad02acc17bed0273d64">DialectConstantFoldHook</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; &amp;)&gt;</td></tr>
<tr class="separator:abb3c2070dfa94ad02acc17bed0273d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c219ce87441d381c0ec080f4ba5b439"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c219ce87441d381c0ec080f4ba5b439">DialectExtractElementHook</a> = std::function&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>(const <a class="el" href="classmlir_1_1OpaqueElementsAttr.html">OpaqueElementsAttr</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;)&gt;</td></tr>
<tr class="separator:a6c219ce87441d381c0ec080f4ba5b439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ae7dda0e636afc0a58acb0ed3342b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a94ae7dda0e636afc0a58acb0ed3342b4">DialectAllocatorFunction</a> = std::function&lt; void(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a94ae7dda0e636afc0a58acb0ed3342b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485453da011e03403b043a915fd368ab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a485453da011e03403b043a915fd368ab">DialectHooksSetter</a> = std::function&lt; void(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="separator:a485453da011e03403b043a915fd368ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfe54a0bc784b7267e1455fa16ea891"><td class="memTemplParams" colspan="2">template&lt;typename OpTy &gt; </td></tr>
<tr class="memitem:addfe54a0bc784b7267e1455fa16ea891"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addfe54a0bc784b7267e1455fa16ea891">OperandAdaptor</a> = typename OpTy::OperandAdaptor</td></tr>
<tr class="memdesc:addfe54a0bc784b7267e1455fa16ea891"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an adaptor from a list of values to named operands of OpTy.  <a href="#addfe54a0bc784b7267e1455fa16ea891">More...</a><br /></td></tr>
<tr class="separator:addfe54a0bc784b7267e1455fa16ea891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0887111bf825d1f766ef9e0911394d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">OpAsmSetValueNameFn</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td></tr>
<tr class="memdesc:ab0887111bf825d1f766ef9e0911394d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A functor used to set the name of the start of a result group of an operation.  <a href="#ab0887111bf825d1f766ef9e0911394d5">More...</a><br /></td></tr>
<tr class="separator:ab0887111bf825d1f766ef9e0911394d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a748507dc3cf99476f7a1b9ec7430bd65"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a748507dc3cf99476f7a1b9ec7430bd65">PatternMatchResult</a> = <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1PatternState.html">PatternState</a> &gt; &gt;</td></tr>
<tr class="memdesc:a748507dc3cf99476f7a1b9ec7430bd65"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type returned by a pattern match.  <a href="#a748507dc3cf99476f7a1b9ec7430bd65">More...</a><br /></td></tr>
<tr class="separator:a748507dc3cf99476f7a1b9ec7430bd65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">DefaultTypeStorage</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="memdesc:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default storage type for types that require no additional initialization or storage.  <a href="#a8b36f0e85767ed4e793d86f40bd8fe55">More...</a><br /></td></tr>
<tr class="separator:a8b36f0e85767ed4e793d86f40bd8fe55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e9069ef9040ccc727d541c02d49ecd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">TypeStorageAllocator</a> = <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td></tr>
<tr class="separator:a01e9069ef9040ccc727d541c02d49ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">OperandElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a3789e28c54bcaf5d2c3baf5f99eb615f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">ResultElementTypeRange</a> = <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a> &gt;</td></tr>
<tr class="separator:a253b95ef2aaf79bdc612ae40fddc0732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa9cda38190c43a3ddb40fb8ca0112b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaa9cda38190c43a3ddb40fb8ca0112b6">AnalysisID</a> = <a class="el" href="structmlir_1_1ClassID.html">ClassID</a></td></tr>
<tr class="memdesc:aaa9cda38190c43a3ddb40fb8ca0112b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special type used by analyses to provide an address that identifies a particular analysis set or a concrete analysis type.  <a href="#aaa9cda38190c43a3ddb40fb8ca0112b6">More...</a><br /></td></tr>
<tr class="separator:aaa9cda38190c43a3ddb40fb8ca0112b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d158c94373a029243fd7006eb79cc87"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9d158c94373a029243fd7006eb79cc87">PassRegistryFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="PassManagerOptions_8cpp.html#a708ec942a8188388392fb8fa522c3d35">options</a>)&gt;</td></tr>
<tr class="memdesc:a9d158c94373a029243fd7006eb79cc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">A registry function that adds passes to the given pass manager.  <a href="#a9d158c94373a029243fd7006eb79cc87">More...</a><br /></td></tr>
<tr class="separator:a9d158c94373a029243fd7006eb79cc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> = std::function&lt; std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;()&gt;</td></tr>
<tr class="separator:a48db7fd5d49bfa7ca8c81e5a6a058683"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf899dff597a809a700779b46dc4972"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3bf899dff597a809a700779b46dc4972">PassID</a> = <a class="el" href="structmlir_1_1ClassID.html">ClassID</a></td></tr>
<tr class="memdesc:a3bf899dff597a809a700779b46dc4972"><td class="mdescLeft">&#160;</td><td class="mdescRight">A special type used by transformation passes to provide an address that can act as a unique identifier during pass registration.  <a href="#a3bf899dff597a809a700779b46dc4972">More...</a><br /></td></tr>
<tr class="separator:a3bf899dff597a809a700779b46dc4972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </td></tr>
<tr class="memitem:ad7f731697783a754f6f0e3821d1264b2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">DenseMap</a> = <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt; KeyT, ValueT, KeyInfoT, BucketT &gt;</td></tr>
<tr class="separator:ad7f731697783a754f6f0e3821d1264b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplParams" colspan="2">template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </td></tr>
<tr class="memitem:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a> = <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt; ValueT, ValueInfoT &gt;</td></tr>
<tr class="separator:a59d6aae8a616cd9d13c8b1edb1095948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplParams" colspan="2">template&lt;typename Fn &gt; </td></tr>
<tr class="memitem:a0bff6226b7c81b6134b8c1130403a172"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a> = <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; Fn &gt;</td></tr>
<tr class="separator:a0bff6226b7c81b6134b8c1130403a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084549cd18226f1b294a368dfcd7cdce"><td class="memTemplParams" colspan="2">template&lt;template&lt; class... &gt; class Op, class... Args&gt; </td></tr>
<tr class="memitem:a084549cd18226f1b294a368dfcd7cdce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a084549cd18226f1b294a368dfcd7cdce">is_detected</a> = typename <a class="el" href="structmlir_1_1detail_1_1detector.html">detail::detector</a>&lt; void, <a class="el" href="classmlir_1_1Op.html">Op</a>, Args... &gt;::value_t</td></tr>
<tr class="separator:a084549cd18226f1b294a368dfcd7cdce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5485eeb23e06cd22ad2ac521edffa100"><td class="memTemplParams" colspan="2">template&lt;typename Callable , typename... Args&gt; </td></tr>
<tr class="memitem:a5485eeb23e06cd22ad2ac521edffa100"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5485eeb23e06cd22ad2ac521edffa100">is_invocable</a> = <a class="el" href="namespacemlir.html#a084549cd18226f1b294a368dfcd7cdce">is_detected</a>&lt; <a class="el" href="namespacemlir_1_1detail.html#a3db85740fd43b571f247cd8ae5d627f5">detail::is_invocable</a>, Callable, Args... &gt;</td></tr>
<tr class="separator:a5485eeb23e06cd22ad2ac521edffa100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb0c2458571cd80ebb876d979e24346"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> = <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(std::unique_ptr&lt; llvm::MemoryBuffer &gt; chunkBuffer, raw_ostream &amp;os)&gt;</td></tr>
<tr class="separator:aafb0c2458571cd80ebb876d979e24346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">GenFunction</a> = std::function&lt; bool(const llvm::RecordKeeper &amp;recordKeeper, raw_ostream &amp;os)&gt;</td></tr>
<tr class="memdesc:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generator function to invoke.  <a href="#a4ddb6704fdaa06a1d6d81b12d73eac94">More...</a><br /></td></tr>
<tr class="separator:a4ddb6704fdaa06a1d6d81b12d73eac94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb10c37aa0b69dce04cbdf7a84e64228"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a> = <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; loop::ForOp, 8 &gt;</td></tr>
<tr class="memdesc:abb10c37aa0b69dce04cbdf7a84e64228"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>.  <a href="#abb10c37aa0b69dce04cbdf7a84e64228">More...</a><br /></td></tr>
<tr class="separator:abb10c37aa0b69dce04cbdf7a84e64228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> = std::pair&lt; <a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a>, <a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a> &gt;</td></tr>
<tr class="separator:a3f0d45d0562d47acc2c42934ccbfea19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16773901a5b8781f9be66507fad3c5b4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16773901a5b8781f9be66507fad3c5b4">TranslateSourceMgrToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a16773901a5b8781f9be66507fad3c5b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR.  <a href="#a16773901a5b8781f9be66507fad3c5b4">More...</a><br /></td></tr>
<tr class="separator:a16773901a5b8781f9be66507fad3c5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995eefe8643c3770dfe42925733c17f8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a995eefe8643c3770dfe42925733c17f8">TranslateStringRefToMLIRFunction</a> = std::function&lt; <a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:a995eefe8643c3770dfe42925733c17f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates the given string to MLIR.  <a href="#a995eefe8643c3770dfe42925733c17f8">More...</a><br /></td></tr>
<tr class="separator:a995eefe8643c3770dfe42925733c17f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13b54e61e2491e2bc91c54f8ef429cfa">TranslateFromMLIRFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a>, llvm::raw_ostream &amp;output)&gt;</td></tr>
<tr class="memdesc:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that translates MLIR to a different format and outputs the result to a stream.  <a href="#a13b54e61e2491e2bc91c54f8ef429cfa">More...</a><br /></td></tr>
<tr class="separator:a13b54e61e2491e2bc91c54f8ef429cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbb54b5d484b1a53b08f04871fb0da8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addbb54b5d484b1a53b08f04871fb0da8">TranslateFunction</a> = std::function&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(llvm::SourceMgr &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td></tr>
<tr class="memdesc:addbb54b5d484b1a53b08f04871fb0da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the function that performs file-to-file translation involving MLIR.  <a href="#addbb54b5d484b1a53b08f04871fb0da8">More...</a><br /></td></tr>
<tr class="separator:addbb54b5d484b1a53b08f04871fb0da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae0a5f1311f5db69741663dd9e28a3c9b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9b">SDBMExprKind</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9baec211f7c20af43e742bf2570c3cb84f9">SDBMExprKind::Add</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bace7566d1d08cc094b74cf283cf9c56a5">SDBMExprKind::Stripe</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9ba49630f5d7723e9b41474bd1cb1887b9d">SDBMExprKind::Diff</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bacb17869fe51048b5a5c4c6106551a255">SDBMExprKind::Constant</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bab49b848e4bb608f4d5650e4b2817c641">SDBMExprKind::DimId</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9baea00d3c6059a4ff11d351696747fc7ff">SDBMExprKind::SymbolId</a>, 
<a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bafb278fa5defd7e699fcbc930c3e76ccd">SDBMExprKind::Neg</a>
<br />
 }</td></tr>
<tr class="separator:ae0a5f1311f5db69741663dd9e28a3c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eec030e79134e91fb05b8292b926ced"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ced">CmpFPredicate</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda16bc26a24d0ab96c13eb2b9e978e4cd9">CmpFPredicate::FirstValidValue</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda8cec5cec7e1bd101eefe8dde47c99289">CmpFPredicate::AlwaysFalse</a> = FirstValidValue, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda9e55d7c6936a06336f631f412cf5da92">CmpFPredicate::OEQ</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedad7bc4f60747e9364d82cffe507605303">CmpFPredicate::OGT</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedaf36752024f8d66ec77bdf0516130c5fc">CmpFPredicate::OGE</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedabab6f0ecb8f89999407a1001a52791c6">CmpFPredicate::OLT</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda4702e1e1f9db3a2ae4da4e8d63c5944d">CmpFPredicate::OLE</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedabc21e6484530fc9d0313cb816b733396">CmpFPredicate::ONE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedac23431d0209648a6b31fa837dd56d681">CmpFPredicate::ORD</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedae38e4eeca7782ab6c251c9619df3152e">CmpFPredicate::UEQ</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda7efc25ec6c881b13261c1a6d88762483">CmpFPredicate::UGT</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedada0d6078de3703b5680eb9361f2d68fd">CmpFPredicate::UGE</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda2b4652512a6c88f5a39c3288081b6e13">CmpFPredicate::ULT</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedae29e365fd3b5e59c86218486a0c1c7c1">CmpFPredicate::ULE</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926cedab57b8eb662c518fa21051312319f6270">CmpFPredicate::UNE</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda59f822bcaa8e119bde63eb00919b367a">CmpFPredicate::UNO</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda65db12e33585aff2007aad58b62b7bcd">CmpFPredicate::AlwaysTrue</a>, 
<a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ceda6d38e67a05ce973a273ab1f8e84d1b6a">CmpFPredicate::NumPredicates</a>
<br />
 }<tr class="memdesc:a6eec030e79134e91fb05b8292b926ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">The predicate indicates the type of the comparison to perform: (un)orderedness, (in)equality and less/greater than (or equal to) as well as predicates that are always true or false.  <a href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ced">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a6eec030e79134e91fb05b8292b926ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3b7fd763c24274db6c115579084133"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> { <br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9">AffineExprKind::Add</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">AffineExprKind::Mul</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">AffineExprKind::Mod</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">AffineExprKind::FloorDiv</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">AffineExprKind::CeilDiv</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24">AffineExprKind::LAST_AFFINE_BINARY_OP</a> = CeilDiv, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255">AffineExprKind::Constant</a>, 
<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641">AffineExprKind::DimId</a>, 
<br />
&#160;&#160;<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff">AffineExprKind::SymbolId</a>
<br />
 }</td></tr>
<tr class="separator:a6d3b7fd763c24274db6c115579084133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">DiagnosticSeverity</a> { <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec">DiagnosticSeverity::Note</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">DiagnosticSeverity::Warning</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">DiagnosticSeverity::Error</a>, 
<a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">DiagnosticSeverity::Remark</a>
 }<tr class="memdesc:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the different supported severity of a diagnostic.  <a href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a247bc9a6d1f1577f2d876cb55e2ea752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583774594e92d8af2d0884e3262d7e24"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24">OperationProperty</a> { <a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24ac9f87f9079df3ae77c58b9258f497dfb">OperationProperty::Commutative</a> = 0x1, 
<a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24adf103a49f1843ddea54be10b182ef456">OperationProperty::NoSideEffect</a> = 0x2, 
<a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24ab420c1d31e69a823fbc30a434907c9c0">OperationProperty::Terminator</a> = 0x4, 
<a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24aee504cc3a721fbb8c7898dcc0798d273">OperationProperty::IsolatedFromAbove</a> = 0x8
 }</td></tr>
<tr class="separator:a583774594e92d8af2d0884e3262d7e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64460ede39d8480e398fd2e6810d95b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">PassDisplayMode</a> { <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135">PassDisplayMode::List</a>, 
<a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72">PassDisplayMode::Pipeline</a>
 }<tr class="memdesc:ab64460ede39d8480e398fd2e6810d95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">An enum describing the different display modes for the information within the pass manager.  <a href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab64460ede39d8480e398fd2e6810d95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1522039bca148f6d365612eb404e0994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1522039bca148f6d365612eb404e0994">getReachableAffineApplyOps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;affineApplyOps)</td></tr>
<tr class="memdesc:a1522039bca148f6d365612eb404e0994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in <code>affineApplyOps</code>, the sequence of those <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> Operations that are reachable via a search starting from <code>operands</code> and ending at those operands that are not the result of an <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>.  <a href="#a1522039bca148f6d365612eb404e0994">More...</a><br /></td></tr>
<tr class="separator:a1522039bca148f6d365612eb404e0994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22708f1f7f952a54a86ec8ea10cc2e40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a22708f1f7f952a54a86ec8ea10cc2e40">getIndexSet</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *domain)</td></tr>
<tr class="memdesc:a22708f1f7f952a54a86ec8ea10cc2e40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a system of constraints with dimensional identifiers corresponding to the loop IVs of the forOps appearing in that order.  <a href="#a22708f1f7f952a54a86ec8ea10cc2e40">More...</a><br /></td></tr>
<tr class="separator:a22708f1f7f952a54a86ec8ea10cc2e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af210ccb9e9409d8494b8998f50b6d274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af210ccb9e9409d8494b8998f50b6d274">checkMemrefAccessDependence</a> (const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;srcAccess, const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;dstAccess, unsigned loopDepth, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *dependenceConstraints, <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *dependenceComponents, bool allowRAR=false)</td></tr>
<tr class="separator:af210ccb9e9409d8494b8998f50b6d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0139b17eb17bf529e630ec15f2051472"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0139b17eb17bf529e630ec15f2051472">hasDependence</a> (<a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a> result)</td></tr>
<tr class="memdesc:a0139b17eb17bf529e630ec15f2051472"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element. ">DependenceResult</a> corresponds to a dependence result.  <a href="#a0139b17eb17bf529e630ec15f2051472">More...</a><br /></td></tr>
<tr class="separator:a0139b17eb17bf529e630ec15f2051472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7a72abd84dcc66c8c890fc6c5e0d24f8">getDependenceComponents</a> (AffineForOp forOp, unsigned maxLoopDepth, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; *depCompsVec)</td></tr>
<tr class="memdesc:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth].  <a href="#a7a72abd84dcc66c8c890fc6c5e0d24f8">More...</a><br /></td></tr>
<tr class="separator:a7a72abd84dcc66c8c890fc6c5e0d24f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf369c69cfb613cd018ef4ce188809c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acbf369c69cfb613cd018ef4ce188809c">simplifyAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols)</td></tr>
<tr class="memdesc:acbf369c69cfb613cd018ef4ce188809c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify an affine expression by flattening and some amount of simple analysis.  <a href="#acbf369c69cfb613cd018ef4ce188809c">More...</a><br /></td></tr>
<tr class="separator:acbf369c69cfb613cd018ef4ce188809c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7746ab6b30038f20f1508c7821fa3052"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7746ab6b30038f20f1508c7821fa3052">getFlattenedAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *flattenedExpr, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst=nullptr)</td></tr>
<tr class="memdesc:a7746ab6b30038f20f1508c7821fa3052"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions.  <a href="#a7746ab6b30038f20f1508c7821fa3052">More...</a><br /></td></tr>
<tr class="separator:a7746ab6b30038f20f1508c7821fa3052"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54668e284d7e980f404164472f75c62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae54668e284d7e980f404164472f75c62">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst=nullptr)</td></tr>
<tr class="memdesc:ae54668e284d7e980f404164472f75c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'.  <a href="#ae54668e284d7e980f404164472f75c62">More...</a><br /></td></tr>
<tr class="separator:ae54668e284d7e980f404164472f75c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f3de480d05c0d64fcc14fd29efde14"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a50f3de480d05c0d64fcc14fd29efde14">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *cst=nullptr)</td></tr>
<tr class="separator:a50f3de480d05c0d64fcc14fd29efde14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d90e917cd6d91240a86ce6e3c9a9c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a90d90e917cd6d91240a86ce6e3c9a9c6">buildTripCountMapAndOperands</a> (AffineForOp forOp, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a90d90e917cd6d91240a86ce6e3c9a9c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise.  <a href="#a90d90e917cd6d91240a86ce6e3c9a9c6">More...</a><br /></td></tr>
<tr class="separator:a90d90e917cd6d91240a86ce6e3c9a9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdcd2c284243df5d427fcdfe4edde75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8cdcd2c284243df5d427fcdfe4edde75">getConstantTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a8cdcd2c284243df5d427fcdfe4edde75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the trip count of the loop if it's a constant, None otherwise.  <a href="#a8cdcd2c284243df5d427fcdfe4edde75">More...</a><br /></td></tr>
<tr class="separator:a8cdcd2c284243df5d427fcdfe4edde75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c3272c7e5d627a525a70f55fb93fb57"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8c3272c7e5d627a525a70f55fb93fb57">getLargestDivisorOfTripCount</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a8c3272c7e5d627a525a70f55fb93fb57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the greatest known integral divisor of the trip count.  <a href="#a8c3272c7e5d627a525a70f55fb93fb57">More...</a><br /></td></tr>
<tr class="separator:a8c3272c7e5d627a525a70f55fb93fb57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4243a75480867bb61c05aa5879d2a32f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, <a class="el" href="structllvm_1_1DenseMapInfo.html">DenseMapInfo</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4243a75480867bb61c05aa5879d2a32f">getInvariantAccesses</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> iv, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; indices)</td></tr>
<tr class="memdesc:a4243a75480867bb61c05aa5879d2a32f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an induction variable <code>iv</code> of type AffineForOp and <code>indices</code> of type <a class="el" href="classmlir_1_1IndexType.html" title="Index is a special integer-like type with unknown platform-dependent bit width. ">IndexType</a>, returns the set of <code>indices</code> that are independent of <code>iv</code>.  <a href="#a4243a75480867bb61c05aa5879d2a32f">More...</a><br /></td></tr>
<tr class="separator:a4243a75480867bb61c05aa5879d2a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76b6d2ee408bfc5909eb81779da3e0f1">isVectorizableLoopBody</a> (AffineForOp loop, <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable; i.e.  <a href="#a76b6d2ee408bfc5909eb81779da3e0f1">More...</a><br /></td></tr>
<tr class="separator:a76b6d2ee408bfc5909eb81779da3e0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13f2a9f8242f345de0163689c30304e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae13f2a9f8242f345de0163689c30304e">isVectorizableLoopBody</a> (AffineForOp loop, int *memRefDim, <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;vectorTransferMatcher)</td></tr>
<tr class="memdesc:ae13f2a9f8242f345de0163689c30304e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are are either:  <a href="#ae13f2a9f8242f345de0163689c30304e">More...</a><br /></td></tr>
<tr class="separator:ae13f2a9f8242f345de0163689c30304e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd425fb7a4b98fc6a1343e123a2217f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5cd425fb7a4b98fc6a1343e123a2217f">isInstwiseShiftValid</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts)</td></tr>
<tr class="memdesc:a5cd425fb7a4b98fc6a1343e123a2217f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.  <a href="#a5cd425fb7a4b98fc6a1343e123a2217f">More...</a><br /></td></tr>
<tr class="separator:a5cd425fb7a4b98fc6a1343e123a2217f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc425822a826dd76ea2e8185aeb9fab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7dc425822a826dd76ea2e8185aeb9fab">defaultFilterFunction</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)</td></tr>
<tr class="separator:a7dc425822a826dd76ea2e8185aeb9fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4c6e0fa0595b4c4f3dc095fd0bda08"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe4c6e0fa0595b4c4f3dc095fd0bda08">createMemRefBoundCheckPass</a> ()</td></tr>
<tr class="memdesc:afe4c6e0fa0595b4c4f3dc095fd0bda08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to check memref accesses in a Function.  <a href="#afe4c6e0fa0595b4c4f3dc095fd0bda08">More...</a><br /></td></tr>
<tr class="separator:afe4c6e0fa0595b4c4f3dc095fd0bda08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f3afa4304b636b1d037fecee420e58c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3f3afa4304b636b1d037fecee420e58c">createTestMemRefDependenceCheckPass</a> ()</td></tr>
<tr class="memdesc:a3f3afa4304b636b1d037fecee420e58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to check memref access dependences in a Function.  <a href="#a3f3afa4304b636b1d037fecee420e58c">More...</a><br /></td></tr>
<tr class="separator:a3f3afa4304b636b1d037fecee420e58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cce4c7ca75e0e63b1688053ba457aae"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3cce4c7ca75e0e63b1688053ba457aae">createParallelismDetectionTestPass</a> ()</td></tr>
<tr class="memdesc:a3cce4c7ca75e0e63b1688053ba457aae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to test parallelism detection; emits note for parallel loops.  <a href="#a3cce4c7ca75e0e63b1688053ba457aae">More...</a><br /></td></tr>
<tr class="separator:a3cce4c7ca75e0e63b1688053ba457aae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c9138cd38e82a78b5895b0e606d5d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab3c9138cd38e82a78b5895b0e606d5d6">getForwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *forwardSlice, <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> filter=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return true;})</td></tr>
<tr class="memdesc:ab3c9138cd38e82a78b5895b0e606d5d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>forwardSlice</code> with the computed forward slice (i.e.  <a href="#ab3c9138cd38e82a78b5895b0e606d5d6">More...</a><br /></td></tr>
<tr class="separator:ab3c9138cd38e82a78b5895b0e606d5d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40741d257063d17fe7e8da3ebea443a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a40741d257063d17fe7e8da3ebea443a3">getBackwardSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *backwardSlice, <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> filter=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return true;})</td></tr>
<tr class="memdesc:a40741d257063d17fe7e8da3ebea443a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills <code>backwardSlice</code> with the computed backward slice (i.e.  <a href="#a40741d257063d17fe7e8da3ebea443a3">More...</a><br /></td></tr>
<tr class="separator:a40741d257063d17fe7e8da3ebea443a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7beb62292ad20dc8c447387c371f9a2"><td class="memItemLeft" align="right" valign="top">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae7beb62292ad20dc8c447387c371f9a2">getSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> backwardFilter=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return true;}, <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a> forwardFilter=[](<a class="el" href="classmlir_1_1Operation.html">Operation</a> *) { return true;})</td></tr>
<tr class="memdesc:ae7beb62292ad20dc8c447387c371f9a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteratively computes backward slices and forward slices until a fixed point is reached.  <a href="#ae7beb62292ad20dc8c447387c371f9a2">More...</a><br /></td></tr>
<tr class="separator:ae7beb62292ad20dc8c447387c371f9a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f5deb263dc3ca56a8c5ae015cba4af"><td class="memItemLeft" align="right" valign="top">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a67f5deb263dc3ca56a8c5ae015cba4af">topologicalSort</a> (const llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;toSort)</td></tr>
<tr class="memdesc:a67f5deb263dc3ca56a8c5ae015cba4af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-root DAG topological sort.  <a href="#a67f5deb263dc3ca56a8c5ae015cba4af">More...</a><br /></td></tr>
<tr class="separator:a67f5deb263dc3ca56a8c5ae015cba4af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991e7b35354627941316244640aa4392"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a991e7b35354627941316244640aa4392">getLoopIVs</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *loops)</td></tr>
<tr class="memdesc:a991e7b35354627941316244640aa4392"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populates 'loops' with IVs of the loops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one.  <a href="#a991e7b35354627941316244640aa4392">More...</a><br /></td></tr>
<tr class="separator:a991e7b35354627941316244640aa4392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae005ef4690791c3f145f4efcfff38fb2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae005ef4690791c3f145f4efcfff38fb2">getNestingDepth</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="memdesc:ae005ef4690791c3f145f4efcfff38fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation.  <a href="#ae005ef4690791c3f145f4efcfff38fb2">More...</a><br /></td></tr>
<tr class="separator:ae005ef4690791c3f145f4efcfff38fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4052bdb6ce4bde76e5de054805848162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4052bdb6ce4bde76e5de054805848162">getSequentialLoops</a> (AffineForOp forOp, llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *sequentialLoops)</td></tr>
<tr class="memdesc:a4052bdb6ce4bde76e5de054805848162"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'.  <a href="#a4052bdb6ce4bde76e5de054805848162">More...</a><br /></td></tr>
<tr class="separator:a4052bdb6ce4bde76e5de054805848162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dfa6bfaaa9a03dcbfdaeee28dc80ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68dfa6bfaaa9a03dcbfdaeee28dc80ab">getComputationSliceState</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSourceOp, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *depSinkOp, <a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *dependenceConstraints, unsigned loopDepth, bool isBackwardSlice, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:a68dfa6bfaaa9a03dcbfdaeee28dc80ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'.  <a href="#a68dfa6bfaaa9a03dcbfdaeee28dc80ab">More...</a><br /></td></tr>
<tr class="separator:a68dfa6bfaaa9a03dcbfdaeee28dc80ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa68a5a18c2ea856568b0fbfb272e2b0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa68a5a18c2ea856568b0fbfb272e2b0d">computeSliceUnion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; opsA, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; opsB, unsigned loopDepth, unsigned numCommonLoops, bool isBackwardSlice, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceUnion)</td></tr>
<tr class="memdesc:aa68a5a18c2ea856568b0fbfb272e2b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB'.  <a href="#aa68a5a18c2ea856568b0fbfb272e2b0d">More...</a><br /></td></tr>
<tr class="separator:aa68a5a18c2ea856568b0fbfb272e2b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c76f66345aba4e6cabb250bf7699c1"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa8c76f66345aba4e6cabb250bf7699c1">insertBackwardComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *srcOpInst, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *dstOpInst, unsigned dstLoopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *sliceState)</td></tr>
<tr class="memdesc:aa8c76f66345aba4e6cabb250bf7699c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'.  <a href="#aa8c76f66345aba4e6cabb250bf7699c1">More...</a><br /></td></tr>
<tr class="separator:aa8c76f66345aba4e6cabb250bf7699c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bd0c019a961c60a1fd09225b7dcd3be">getMemRefSizeInBytes</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> memRefType)</td></tr>
<tr class="memdesc:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of memref data in bytes if it's statically shaped, None otherwise.  <a href="#a5bd0c019a961c60a1fd09225b7dcd3be">More...</a><br /></td></tr>
<tr class="separator:a5bd0c019a961c60a1fd09225b7dcd3be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memTemplParams" colspan="2">template&lt;typename LoadOrStoreOpPointer &gt; </td></tr>
<tr class="memitem:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdb92b40e131a0a6bd17fc39f1f3e371">boundCheckLoadOrStoreOp</a> (LoadOrStoreOpPointer loadOrStoreOp, bool <a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a>=true)</td></tr>
<tr class="memdesc:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise.  <a href="#afdb92b40e131a0a6bd17fc39f1f3e371">More...</a><br /></td></tr>
<tr class="separator:afdb92b40e131a0a6bd17fc39f1f3e371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9ce1eb0663c1448ebc1bbeccc2b6bcf">getNumCommonSurroundingLoops</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;A, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;B)</td></tr>
<tr class="memdesc:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of surrounding loops common to both A and B.  <a href="#af9ce1eb0663c1448ebc1bbeccc2b6bcf">More...</a><br /></td></tr>
<tr class="separator:af9ce1eb0663c1448ebc1bbeccc2b6bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1670cd81ab396ba425cd0063d516b9a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1670cd81ab396ba425cd0063d516b9a9">getMemoryFootprintBytes</a> (AffineForOp forOp, int memorySpace=-1)</td></tr>
<tr class="memdesc:a1670cd81ab396ba425cd0063d516b9a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces.  <a href="#a1670cd81ab396ba425cd0063d516b9a9">More...</a><br /></td></tr>
<tr class="separator:a1670cd81ab396ba425cd0063d516b9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9c4fc904589c35cd742b2f96393ee2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0d9c4fc904589c35cd742b2f96393ee2">isLoopParallel</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a0d9c4fc904589c35cd742b2f96393ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if `forOp' is a parallel loop.  <a href="#a0d9c4fc904589c35cd742b2f96393ee2">More...</a><br /></td></tr>
<tr class="separator:a0d9c4fc904589c35cd742b2f96393ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8311703578f50c8d610c687db37a8dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8311703578f50c8d610c687db37a8dc4">verify</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op)</td></tr>
<tr class="memdesc:a8311703578f50c8d610c687db37a8dc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations.  <a href="#a8311703578f50c8d610c687db37a8dc4">More...</a><br /></td></tr>
<tr class="separator:a8311703578f50c8d610c687db37a8dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85875ff18480bfcf5b02dcbccd2fea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa85875ff18480bfcf5b02dcbccd2fea2">expandAffineExpr</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; dimValues, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolValues)</td></tr>
<tr class="memdesc:aa85875ff18480bfcf5b02dcbccd2fea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values.  <a href="#aa85875ff18480bfcf5b02dcbccd2fea2">More...</a><br /></td></tr>
<tr class="separator:aa85875ff18480bfcf5b02dcbccd2fea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8c7352bef2e6ad933b0342ac148d83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0a8c7352bef2e6ad933b0342ac148d83">populateAffineToStdConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a0a8c7352bef2e6ad933b0342ac148d83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow.  <a href="#a0a8c7352bef2e6ad933b0342ac148d83">More...</a><br /></td></tr>
<tr class="separator:a0a8c7352bef2e6ad933b0342ac148d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdf4bbbb9eb7a9678bd98d122b837cbd">lowerAffineLowerBound</a> (AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the lower bound of the given affine loop using standard arithmetic operations.  <a href="#afdf4bbbb9eb7a9678bd98d122b837cbd">More...</a><br /></td></tr>
<tr class="separator:afdf4bbbb9eb7a9678bd98d122b837cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d924b9762c352e82e8fe0fb1e222288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2d924b9762c352e82e8fe0fb1e222288">lowerAffineUpperBound</a> (AffineForOp op, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a2d924b9762c352e82e8fe0fb1e222288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit code that computes the upper bound of the given affine loop using standard arithmetic operations.  <a href="#a2d924b9762c352e82e8fe0fb1e222288">More...</a><br /></td></tr>
<tr class="separator:a2d924b9762c352e82e8fe0fb1e222288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a812eaea183edd3a043221352c421d456"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a812eaea183edd3a043221352c421d456">createConvertGPUKernelToCubinPass</a> (<a class="el" href="namespacemlir.html#ac778e98bba4a5f7b76ead3e1d37c6892">CubinGenerator</a> cubinGenerator)</td></tr>
<tr class="memdesc:a812eaea183edd3a043221352c421d456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert kernel functions into CUBIN blobs.  <a href="#a812eaea183edd3a043221352c421d456">More...</a><br /></td></tr>
<tr class="separator:a812eaea183edd3a043221352c421d456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f00f1726e12db17c287b1d465a788f"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac6f00f1726e12db17c287b1d465a788f">createConvertGpuLaunchFuncToCudaCallsPass</a> ()</td></tr>
<tr class="memdesc:ac6f00f1726e12db17c287b1d465a788f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert a gpu.launch_func operation into a sequence of CUDA calls.  <a href="#ac6f00f1726e12db17c287b1d465a788f">More...</a><br /></td></tr>
<tr class="separator:ac6f00f1726e12db17c287b1d465a788f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb104ff278ae6a462a7e4339637f405"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2cb104ff278ae6a462a7e4339637f405">populateGpuToNVVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a2cb104ff278ae6a462a7e4339637f405"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>.  <a href="#a2cb104ff278ae6a462a7e4339637f405">More...</a><br /></td></tr>
<tr class="separator:a2cb104ff278ae6a462a7e4339637f405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783d4bfe3cfba7dfe204f37dfc48b994"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a783d4bfe3cfba7dfe204f37dfc48b994">createLowerGpuOpsToNVVMOpsPass</a> ()</td></tr>
<tr class="memdesc:a783d4bfe3cfba7dfe204f37dfc48b994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> counterparts.  <a href="#a783d4bfe3cfba7dfe204f37dfc48b994">More...</a><br /></td></tr>
<tr class="separator:a783d4bfe3cfba7dfe204f37dfc48b994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd81a6ae73cd5c075caf6af24b13eff"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; gpu::GPUModuleOp &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afcd81a6ae73cd5c075caf6af24b13eff">createLowerGpuOpsToROCDLOpsPass</a> ()</td></tr>
<tr class="memdesc:afcd81a6ae73cd5c075caf6af24b13eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> counterparts.  <a href="#afcd81a6ae73cd5c075caf6af24b13eff">More...</a><br /></td></tr>
<tr class="separator:afcd81a6ae73cd5c075caf6af24b13eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22eea25e76e053acdaf89905feba42d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a22eea25e76e053acdaf89905feba42d4">populateGPUToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; workGroupSize)</td></tr>
<tr class="memdesc:a22eea25e76e053acdaf89905feba42d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops.  <a href="#a22eea25e76e053acdaf89905feba42d4">More...</a><br /></td></tr>
<tr class="separator:a22eea25e76e053acdaf89905feba42d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b936baa53d3e2755b359b551fa87aa"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69b936baa53d3e2755b359b551fa87aa">createConvertGPUToSPIRVPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; workGroupSize)</td></tr>
<tr class="memdesc:a69b936baa53d3e2755b359b551fa87aa"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert GPU Ops to SPIR-V ops.  <a href="#a69b936baa53d3e2755b359b551fa87aa">More...</a><br /></td></tr>
<tr class="separator:a69b936baa53d3e2755b359b551fa87aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbac6a13953f49ca582ee2b710d1f45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdbac6a13953f49ca582ee2b710d1f45">populateLinalgToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LinalgTypeConverter.html">LinalgTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:afdbac6a13953f49ca582ee2b710d1f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate the given list with patterns that convert from Linalg to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#afdbac6a13953f49ca582ee2b710d1f45">More...</a><br /></td></tr>
<tr class="separator:afdbac6a13953f49ca582ee2b710d1f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7217579d47066ee187bc2a14081ecd4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad7217579d47066ee187bc2a14081ecd4">createConvertLinalgToLLVMPass</a> ()</td></tr>
<tr class="memdesc:ad7217579d47066ee187bc2a14081ecd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to the LLVMIR dialect.  <a href="#ad7217579d47066ee187bc2a14081ecd4">More...</a><br /></td></tr>
<tr class="separator:ad7217579d47066ee187bc2a14081ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbe63747d3d90805543a5697ca8aca9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addbe63747d3d90805543a5697ca8aca9">convertAffineLoopNestToGPULaunch</a> (AffineForOp forOp, unsigned numBlockDims, unsigned numThreadDims)</td></tr>
<tr class="memdesc:addbe63747d3d90805543a5697ca8aca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation.  <a href="#addbe63747d3d90805543a5697ca8aca9">More...</a><br /></td></tr>
<tr class="separator:addbe63747d3d90805543a5697ca8aca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba4e422d65880a2c3356017568b7df9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9ba4e422d65880a2c3356017568b7df9">convertLoopNestToGPULaunch</a> (loop::ForOp forOp, unsigned numBlockDims, unsigned numThreadDims)</td></tr>
<tr class="memdesc:a9ba4e422d65880a2c3356017568b7df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a perfect linalg loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation.  <a href="#a9ba4e422d65880a2c3356017568b7df9">More...</a><br /></td></tr>
<tr class="separator:a9ba4e422d65880a2c3356017568b7df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c080f43260d9c1211bd2da15ee3ab1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c080f43260d9c1211bd2da15ee3ab1e">convertLoopToGPULaunch</a> (loop::ForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; numWorkGroups, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; workGroupSizes)</td></tr>
<tr class="memdesc:a6c080f43260d9c1211bd2da15ee3ab1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a loop operation into a GPU launch with the values provided in <code>numWorkGroups</code> as the grid size and the values provided in <code>workGroupSizes</code> as the block size.  <a href="#a6c080f43260d9c1211bd2da15ee3ab1e">More...</a><br /></td></tr>
<tr class="separator:a6c080f43260d9c1211bd2da15ee3ab1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820e7febf74c59d4401b11a97a5c4a09"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a820e7febf74c59d4401b11a97a5c4a09">createSimpleLoopsToGPUPass</a> (unsigned numBlockDims, unsigned numThreadDims)</td></tr>
<tr class="memdesc:a820e7febf74c59d4401b11a97a5c4a09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that converts loop nests into GPU kernels.  <a href="#a820e7febf74c59d4401b11a97a5c4a09">More...</a><br /></td></tr>
<tr class="separator:a820e7febf74c59d4401b11a97a5c4a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e5cd2cdbeaef2fc1810b52ce012b24"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13e5cd2cdbeaef2fc1810b52ce012b24">createLoopToGPUPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; numWorkGroups, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; workGroupSize)</td></tr>
<tr class="memdesc:a13e5cd2cdbeaef2fc1810b52ce012b24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass that converts every loop operation within the body of the <a class="el" href="classmlir_1_1FuncOp.html" title="FuncOp represents a function, or an operation containing one region that forms a CFG(Control Flow Gra...">FuncOp</a> into a GPU launch.  <a href="#a13e5cd2cdbeaef2fc1810b52ce012b24">More...</a><br /></td></tr>
<tr class="separator:a13e5cd2cdbeaef2fc1810b52ce012b24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca74253af65583026863be8081bbd84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1ca74253af65583026863be8081bbd84">populateLoopToStdConversionPatterns</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx)</td></tr>
<tr class="memdesc:a1ca74253af65583026863be8081bbd84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to lower from loop.for, loop.if, and loop.terminator to CFG operations within the Standard dialect, in particular convert structured control flow into CFG branch-based control flow.  <a href="#a1ca74253af65583026863be8081bbd84">More...</a><br /></td></tr>
<tr class="separator:a1ca74253af65583026863be8081bbd84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bcd86978ddc5c8c9eb55e995fa7d69"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa7bcd86978ddc5c8c9eb55e995fa7d69">createLowerToCFGPass</a> ()</td></tr>
<tr class="memdesc:aa7bcd86978ddc5c8c9eb55e995fa7d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert loop.for, loop.if and loop.terminator ops to CFG.  <a href="#aa7bcd86978ddc5c8c9eb55e995fa7d69">More...</a><br /></td></tr>
<tr class="separator:aa7bcd86978ddc5c8c9eb55e995fa7d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295a0479fed5f043620777a1f1e6f93b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a295a0479fed5f043620777a1f1e6f93b">populateStdToLLVMMemoryConversionPatters</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a295a0479fed5f043620777a1f1e6f93b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert memory-related operations from the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, excluding the memory-related operations.  <a href="#a295a0479fed5f043620777a1f1e6f93b">More...</a><br /></td></tr>
<tr class="separator:a295a0479fed5f043620777a1f1e6f93b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac272d602be4199d577e0a2e42788c50d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac272d602be4199d577e0a2e42788c50d">populateStdToLLVMNonMemoryConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ac272d602be4199d577e0a2e42788c50d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, excluding the memory-related operations.  <a href="#ac272d602be4199d577e0a2e42788c50d">More...</a><br /></td></tr>
<tr class="separator:ac272d602be4199d577e0a2e42788c50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a595c6a19148f86b48b2121b201475618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a595c6a19148f86b48b2121b201475618">populateStdToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a595c6a19148f86b48b2121b201475618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Standard dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a595c6a19148f86b48b2121b201475618">More...</a><br /></td></tr>
<tr class="separator:a595c6a19148f86b48b2121b201475618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdd4bb3719cfea4b8c15e63476d9d39"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2cdd4bb3719cfea4b8c15e63476d9d39">createLowerToLLVMPass</a> (bool useAlloca=false)</td></tr>
<tr class="memdesc:a2cdd4bb3719cfea4b8c15e63476d9d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert the Standard dialect into the LLVMIR dialect.  <a href="#a2cdd4bb3719cfea4b8c15e63476d9d39">More...</a><br /></td></tr>
<tr class="separator:a2cdd4bb3719cfea4b8c15e63476d9d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a912cc5d2766aefdccb2880236aee54bb"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a912cc5d2766aefdccb2880236aee54bb">createLowerToLLVMPass</a> (<a class="el" href="namespacemlir.html#a021ec11591c1abe2294a6c0a9e5caa29">LLVMPatternListFiller</a> patternListFiller, <a class="el" href="namespacemlir.html#ab4a624defb326870761dd5923452a374">LLVMTypeConverterMaker</a> typeConverterMaker, bool useAlloca=false)</td></tr>
<tr class="memdesc:a912cc5d2766aefdccb2880236aee54bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert operations to the LLVMIR dialect.  <a href="#a912cc5d2766aefdccb2880236aee54bb">More...</a><br /></td></tr>
<tr class="separator:a912cc5d2766aefdccb2880236aee54bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96088b7ac20f8219884aa02965be52e"><td class="memTemplParams" colspan="2">template&lt;typename TypeConverter  = LLVMTypeConverter&gt; </td></tr>
<tr class="memitem:af96088b7ac20f8219884aa02965be52e"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af96088b7ac20f8219884aa02965be52e">createLowerToLLVMPass</a> (<a class="el" href="namespacemlir.html#a021ec11591c1abe2294a6c0a9e5caa29">LLVMPatternListFiller</a> patternListFiller, bool useAlloca=false)</td></tr>
<tr class="memdesc:af96088b7ac20f8219884aa02965be52e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to convert operations to the LLVMIR dialect.  <a href="#af96088b7ac20f8219884aa02965be52e">More...</a><br /></td></tr>
<tr class="separator:af96088b7ac20f8219884aa02965be52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1de38d84e16c5c7e869995fb1c3605b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad1de38d84e16c5c7e869995fb1c3605b">populateStandardToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ad1de38d84e16c5c7e869995fb1c3605b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating StandardOps to SPIR-V ops.  <a href="#ad1de38d84e16c5c7e869995fb1c3605b">More...</a><br /></td></tr>
<tr class="separator:ad1de38d84e16c5c7e869995fb1c3605b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ac4da050bc6b23d395d3480f9dfae8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ac4da050bc6b23d395d3480f9dfae8a">populateStdLegalizationPatternsForSPIRVLowering</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a6ac4da050bc6b23d395d3480f9dfae8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list patterns to legalize ops that are not directly lowered to SPIR-V.  <a href="#a6ac4da050bc6b23d395d3480f9dfae8a">More...</a><br /></td></tr>
<tr class="separator:a6ac4da050bc6b23d395d3480f9dfae8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af42feeffcca4b155ef99c1ef00c1629a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af42feeffcca4b155ef99c1ef00c1629a">createConvertStandardToSPIRVPass</a> ()</td></tr>
<tr class="memdesc:af42feeffcca4b155ef99c1ef00c1629a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert StandardOps to SPIR-V ops.  <a href="#af42feeffcca4b155ef99c1ef00c1629a">More...</a><br /></td></tr>
<tr class="separator:af42feeffcca4b155ef99c1ef00c1629a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8665adb3fa2ac64504cfff30192ecb5e"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8665adb3fa2ac64504cfff30192ecb5e">createLegalizeStdOpsForSPIRVLoweringPass</a> ()</td></tr>
<tr class="memdesc:a8665adb3fa2ac64504cfff30192ecb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to legalize ops that are not directly lowered to SPIR-V.  <a href="#a8665adb3fa2ac64504cfff30192ecb5e">More...</a><br /></td></tr>
<tr class="separator:a8665adb3fa2ac64504cfff30192ecb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8bf0ac3b61b7aa5915ddf914c2d66e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7c8bf0ac3b61b7aa5915ddf914c2d66e">populateVectorToLLVMConversionPatterns</a> (<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;converter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a7c8bf0ac3b61b7aa5915ddf914c2d66e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Vector dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.  <a href="#a7c8bf0ac3b61b7aa5915ddf914c2d66e">More...</a><br /></td></tr>
<tr class="separator:a7c8bf0ac3b61b7aa5915ddf914c2d66e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491624870c7a589aca2f9d0f6eb9b8e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a491624870c7a589aca2f9d0f6eb9b8e4">createLowerVectorToLLVMPass</a> ()</td></tr>
<tr class="memdesc:a491624870c7a589aca2f9d0f6eb9b8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert vector operations to the LLVMIR dialect.  <a href="#a491624870c7a589aca2f9d0f6eb9b8e4">More...</a><br /></td></tr>
<tr class="separator:a491624870c7a589aca2f9d0f6eb9b8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619f33d7fea7eea9addb79a3d680cc9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a619f33d7fea7eea9addb79a3d680cc9b">populateVectorToAffineLoopsConversionPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a619f33d7fea7eea9addb79a3d680cc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Vector dialect to loops + std.  <a href="#a619f33d7fea7eea9addb79a3d680cc9b">More...</a><br /></td></tr>
<tr class="separator:a619f33d7fea7eea9addb79a3d680cc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b0f1033aa9d5b5d3d199c3f94d742e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a67b0f1033aa9d5b5d3d199c3f94d742e">createLowerVectorToLoopsPass</a> ()</td></tr>
<tr class="memdesc:a67b0f1033aa9d5b5d3d199c3f94d742e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert vector operations to affine loops + std dialect.  <a href="#a67b0f1033aa9d5b5d3d199c3f94d742e">More...</a><br /></td></tr>
<tr class="separator:a67b0f1033aa9d5b5d3d199c3f94d742e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa36b5164871eaf1d6423cd0a2eb4e4fd">isTopLevelValue</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A utility function to check if a value is defined at the top level of a function.  <a href="#aa36b5164871eaf1d6423cd0a2eb4e4fd">More...</a><br /></td></tr>
<tr class="separator:aa36b5164871eaf1d6423cd0a2eb4e4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e447f320894cc02bbaeff66dd31ccee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e447f320894cc02bbaeff66dd31ccee">isValidDim</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a9e447f320894cc02bbaeff66dd31ccee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id.  <a href="#a9e447f320894cc02bbaeff66dd31ccee">More...</a><br /></td></tr>
<tr class="separator:a9e447f320894cc02bbaeff66dd31ccee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f320624f15a47e5732c1142f99dc144"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f320624f15a47e5732c1142f99dc144">isValidSymbol</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="memdesc:a6f320624f15a47e5732c1142f99dc144"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol.  <a href="#a6f320624f15a47e5732c1142f99dc144">More...</a><br /></td></tr>
<tr class="separator:a6f320624f15a47e5732c1142f99dc144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bde50e2368b8864c8bc070a11fdd71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad8bde50e2368b8864c8bc070a11fdd71">canonicalizeMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:ad8bde50e2368b8864c8bc070a11fdd71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modifies both <code>map</code> and <code>operands</code> in-place so as to:  <a href="#ad8bde50e2368b8864c8bc070a11fdd71">More...</a><br /></td></tr>
<tr class="separator:ad8bde50e2368b8864c8bc070a11fdd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d761b15655cb81ff4b40dbf49445db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a02d761b15655cb81ff4b40dbf49445db">canonicalizeSetAndOperands</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *set, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:a02d761b15655cb81ff4b40dbf49445db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps.  <a href="#a02d761b15655cb81ff4b40dbf49445db">More...</a><br /></td></tr>
<tr class="separator:a02d761b15655cb81ff4b40dbf49445db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1186a736d12d4f188f6eac3c02a11b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineApplyOp.html">AffineApplyOp</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1186a736d12d4f188f6eac3c02a11b0f">makeComposedAffineApply</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;b, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands)</td></tr>
<tr class="memdesc:a1186a736d12d4f188f6eac3c02a11b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a composed <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> by composing <code>map</code> and <code>operands</code> with other AffineApplyOps supplying those operands.  <a href="#a1186a736d12d4f188f6eac3c02a11b0f">More...</a><br /></td></tr>
<tr class="separator:a1186a736d12d4f188f6eac3c02a11b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80da81dcbeeee5cc76ed25a83f10200"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab80da81dcbeeee5cc76ed25a83f10200">fullyComposeAffineMapAndOperands</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands)</td></tr>
<tr class="memdesc:ab80da81dcbeeee5cc76ed25a83f10200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an affine map <code>map</code> and its input <code>operands</code>, this method composes into <code>map</code>, maps of AffineApplyOps whose results are the values in <code>operands</code>, iteratively until no more of <code>operands</code> are the result of an <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>.  <a href="#ab80da81dcbeeee5cc76ed25a83f10200">More...</a><br /></td></tr>
<tr class="separator:ab80da81dcbeeee5cc76ed25a83f10200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd391dd6c617912e9c5e70caa5fb513"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0dd391dd6c617912e9c5e70caa5fb513">isForInductionVar</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a0dd391dd6c617912e9c5e70caa5fb513"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns if the provided value is the induction variable of a AffineForOp.  <a href="#a0dd391dd6c617912e9c5e70caa5fb513">More...</a><br /></td></tr>
<tr class="separator:a0dd391dd6c617912e9c5e70caa5fb513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95142edbf4c3eba444c22b6508d9a573"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a95142edbf4c3eba444c22b6508d9a573">getForInductionVarOwner</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="memdesc:a95142edbf4c3eba444c22b6508d9a573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the loop parent of an induction variable.  <a href="#a95142edbf4c3eba444c22b6508d9a573">More...</a><br /></td></tr>
<tr class="separator:a95142edbf4c3eba444c22b6508d9a573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13093ebea6c814674ee1668daf5f81f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a13093ebea6c814674ee1668daf5f81f8">extractForInductionVars</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forInsts, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *ivs)</td></tr>
<tr class="memdesc:a13093ebea6c814674ee1668daf5f81f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extracts the induction variables from a list of AffineForOps and places them in the output argument <code>ivs</code>.  <a href="#a13093ebea6c814674ee1668daf5f81f8">More...</a><br /></td></tr>
<tr class="separator:a13093ebea6c814674ee1668daf5f81f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memTemplParams" colspan="2">template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </td></tr>
<tr class="memitem:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5d3b3bbe9e749975af2eb5358df6f5fe">constFoldBinaryOp</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt; operands, const CalculationT &amp;calculate)</td></tr>
<tr class="memdesc:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible.  <a href="#a5d3b3bbe9e749975af2eb5358df6f5fe">More...</a><br /></td></tr>
<tr class="separator:a5d3b3bbe9e749975af2eb5358df6f5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7173c36d6b113dcdb0599eb672526b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7173c36d6b113dcdb0599eb672526b43">promoteToWorkgroupMemory</a> (gpu::GPUFuncOp op, unsigned arg)</td></tr>
<tr class="memdesc:a7173c36d6b113dcdb0599eb672526b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes a function argument to workgroup memory in the given function.  <a href="#a7173c36d6b113dcdb0599eb672526b43">More...</a><br /></td></tr>
<tr class="separator:a7173c36d6b113dcdb0599eb672526b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5055056389363fae93cf5b46fbca3461"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5055056389363fae93cf5b46fbca3461">createGpuKernelOutliningPass</a> ()</td></tr>
<tr class="separator:a5055056389363fae93cf5b46fbca3461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6199c25bfc092bd63f31f982855e1c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd6199c25bfc092bd63f31f982855e1c">populateGpuRewritePatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:acd6199c25bfc092bd63f31f982855e1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to rewrite ops within the GPU dialect.  <a href="#acd6199c25bfc092bd63f31f982855e1c">More...</a><br /></td></tr>
<tr class="separator:acd6199c25bfc092bd63f31f982855e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778dce592055d7ec8958e1a39f9e2034"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a778dce592055d7ec8958e1a39f9e2034">createLinalgFusionPass</a> ()</td></tr>
<tr class="separator:a778dce592055d7ec8958e1a39f9e2034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3871498529bc481fb04015cbe9a061dd"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3871498529bc481fb04015cbe9a061dd">createLinalgTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; tileSizes={})</td></tr>
<tr class="separator:a3871498529bc481fb04015cbe9a061dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93262dd909c3a67dd9b7729bbdd79df4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a93262dd909c3a67dd9b7729bbdd79df4">createLinalgPromotionPass</a> (bool dynamicBuffers)</td></tr>
<tr class="separator:a93262dd909c3a67dd9b7729bbdd79df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fd26fef5b6a2fadc8bde27aaf33a51"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a90fd26fef5b6a2fadc8bde27aaf33a51">createConvertLinalgToLoopsPass</a> ()</td></tr>
<tr class="memdesc:a90fd26fef5b6a2fadc8bde27aaf33a51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to loop.for loops and std.load/std.store accesses.  <a href="#a90fd26fef5b6a2fadc8bde27aaf33a51">More...</a><br /></td></tr>
<tr class="separator:a90fd26fef5b6a2fadc8bde27aaf33a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc91680386102b634b4bfacf2df8c8cc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afc91680386102b634b4bfacf2df8c8cc">createConvertLinalgToAffineLoopsPass</a> ()</td></tr>
<tr class="memdesc:afc91680386102b634b4bfacf2df8c8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pass to convert Linalg operations to affine.for loops and affine_load/affine_store accesses.  <a href="#afc91680386102b634b4bfacf2df8c8cc">More...</a><br /></td></tr>
<tr class="separator:afc91680386102b634b4bfacf2df8c8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014242a015c4e9c9aa58c829af2fc4d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a014242a015c4e9c9aa58c829af2fc4d4">operator+</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:a014242a015c4e9c9aa58c829af2fc4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5e28263eb0fcf092160b8a9e0f6ce8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f5e28263eb0fcf092160b8a9e0f6ce8">operator&lt;</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:a9f5e28263eb0fcf092160b8a9e0f6ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8491b7c1cf514aa1510eb26fd5003c18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8491b7c1cf514aa1510eb26fd5003c18">operator&lt;=</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:a8491b7c1cf514aa1510eb26fd5003c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a572d4713cebe03e129bef601d1041f0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a572d4713cebe03e129bef601d1041f0f">operator==</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:a572d4713cebe03e129bef601d1041f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d0033d79ef89bd4fe840819c0e5b44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab8d0033d79ef89bd4fe840819c0e5b44">operator!=</a> (<a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> lhs, <a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> rhs)</td></tr>
<tr class="separator:ab8d0033d79ef89bd4fe840819c0e5b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fe385239da2dd1c47fa998533a19f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae6fe385239da2dd1c47fa998533a19f6">populateBuiltinFuncToSPIRVPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;typeConverter, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ae6fe385239da2dd1c47fa998533a19f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect.  <a href="#ae6fe385239da2dd1c47fa998533a19f6">More...</a><br /></td></tr>
<tr class="separator:ae6fe385239da2dd1c47fa998533a19f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f1e788f04c669e931f8fc314d7b597"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a79f1e788f04c669e931f8fc314d7b597">printDimAndSymbolList</a> (<a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a> begin, <a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a> end, unsigned numDims, <a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p)</td></tr>
<tr class="memdesc:a79f1e788f04c669e931f8fc314d7b597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints dimension and symbol list.  <a href="#a79f1e788f04c669e931f8fc314d7b597">More...</a><br /></td></tr>
<tr class="separator:a79f1e788f04c669e931f8fc314d7b597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3d0c425094498fc25bf4856eb029c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc3d0c425094498fc25bf4856eb029c8">parseDimAndSymbolList</a> (<a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;<a class="el" href="classllvm_1_1cl_1_1parser.html">parser</a>, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;operands, unsigned &amp;numDims)</td></tr>
<tr class="memdesc:adc3d0c425094498fc25bf4856eb029c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses dimension and symbol list and returns true if parsing failed.  <a href="#adc3d0c425094498fc25bf4856eb029c8">More...</a><br /></td></tr>
<tr class="separator:adc3d0c425094498fc25bf4856eb029c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76958b05a1a457434e625f4b31594dd3"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76958b05a1a457434e625f4b31594dd3">operator&lt;&lt;</a> (raw_ostream &amp;os, SubViewOp::Range &amp;range)</td></tr>
<tr class="separator:a76958b05a1a457434e625f4b31594dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8832a0e0699c7854b7844ea4a2cb06"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8d8832a0e0699c7854b7844ea4a2cb06">getIndexingMapsAttrName</a> ()</td></tr>
<tr class="memdesc:a8d8832a0e0699c7854b7844ea4a2cb06"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the AffineArrayAttr which encodes the relationship between a structured op iterators' and its operands.  <a href="#a8d8832a0e0699c7854b7844ea4a2cb06">More...</a><br /></td></tr>
<tr class="separator:a8d8832a0e0699c7854b7844ea4a2cb06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd44bf7d517ba785af9e9412c7ca8cc"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0cd44bf7d517ba785af9e9412c7ca8cc">getIteratorTypesAttrName</a> ()</td></tr>
<tr class="memdesc:a0cd44bf7d517ba785af9e9412c7ca8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the StrArrayAttr which encodes the type of a structured op's iterators.  <a href="#a0cd44bf7d517ba785af9e9412c7ca8cc">More...</a><br /></td></tr>
<tr class="separator:a0cd44bf7d517ba785af9e9412c7ca8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6d625c94bde77cc435c01814ceca49"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe6d625c94bde77cc435c01814ceca49">getArgsInAttrName</a> ()</td></tr>
<tr class="memdesc:afe6d625c94bde77cc435c01814ceca49"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the <a class="el" href="classmlir_1_1IntegerAttr.html">IntegerAttr</a> which encodes the number of input buffer arguments.  <a href="#afe6d625c94bde77cc435c01814ceca49">More...</a><br /></td></tr>
<tr class="separator:afe6d625c94bde77cc435c01814ceca49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fed7ca60dd96dc6cb59ac7439d4d6a"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a76fed7ca60dd96dc6cb59ac7439d4d6a">getArgsOutAttrName</a> ()</td></tr>
<tr class="memdesc:a76fed7ca60dd96dc6cb59ac7439d4d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the <a class="el" href="classmlir_1_1IntegerAttr.html">IntegerAttr</a> which encodes the number of input buffer arguments.  <a href="#a76fed7ca60dd96dc6cb59ac7439d4d6a">More...</a><br /></td></tr>
<tr class="separator:a76fed7ca60dd96dc6cb59ac7439d4d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3783be00e80b62134e4a1f6f6fccd376"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3783be00e80b62134e4a1f6f6fccd376">getDocAttrName</a> ()</td></tr>
<tr class="memdesc:a3783be00e80b62134e4a1f6f6fccd376"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the <a class="el" href="classmlir_1_1StringAttr.html">StringAttr</a> which encodes an optional documentation string of the structured op.  <a href="#a3783be00e80b62134e4a1f6f6fccd376">More...</a><br /></td></tr>
<tr class="separator:a3783be00e80b62134e4a1f6f6fccd376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ad4a4f2b9f799fb94f6ed67574a7130"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0ad4a4f2b9f799fb94f6ed67574a7130">getFunAttrName</a> ()</td></tr>
<tr class="memdesc:a0ad4a4f2b9f799fb94f6ed67574a7130"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the StrArrayAttr which encodes the SymbolAttr for the MLIR function that implements the body of the structured op.  <a href="#a0ad4a4f2b9f799fb94f6ed67574a7130">More...</a><br /></td></tr>
<tr class="separator:a0ad4a4f2b9f799fb94f6ed67574a7130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807920d891bec3be4c57bc48ac72591a"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a807920d891bec3be4c57bc48ac72591a">getLibraryCallAttrName</a> ()</td></tr>
<tr class="memdesc:a807920d891bec3be4c57bc48ac72591a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the StrArrayAttr which encodes the external library function that implements the structured op.  <a href="#a807920d891bec3be4c57bc48ac72591a">More...</a><br /></td></tr>
<tr class="separator:a807920d891bec3be4c57bc48ac72591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d505ce9a9e5eb2b9c03ec43cd97458"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a73d505ce9a9e5eb2b9c03ec43cd97458">getParallelIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:a73d505ce9a9e5eb2b9c03ec43cd97458"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has parallel semantics.  <a href="#a73d505ce9a9e5eb2b9c03ec43cd97458">More...</a><br /></td></tr>
<tr class="separator:a73d505ce9a9e5eb2b9c03ec43cd97458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c6c4d23ae5922c768383462ef7982f"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a67c6c4d23ae5922c768383462ef7982f">getReductionIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:a67c6c4d23ae5922c768383462ef7982f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has reduction semantics.  <a href="#a67c6c4d23ae5922c768383462ef7982f">More...</a><br /></td></tr>
<tr class="separator:a67c6c4d23ae5922c768383462ef7982f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1c2592f2447da69c493194bebeef37"><td class="memItemLeft" align="right" valign="top">static constexpr StringLiteral&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9b1c2592f2447da69c493194bebeef37">getWindowIteratorTypeName</a> ()</td></tr>
<tr class="memdesc:a9b1c2592f2447da69c493194bebeef37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has window semantics.  <a href="#a9b1c2592f2447da69c493194bebeef37">More...</a><br /></td></tr>
<tr class="separator:a9b1c2592f2447da69c493194bebeef37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50433d156c440b227ebae0e883d85a3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; StringRef &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad50433d156c440b227ebae0e883d85a3">getAllIteratorTypeNames</a> ()</td></tr>
<tr class="memdesc:ad50433d156c440b227ebae0e883d85a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to encode that a particular iterator type has window semantics.  <a href="#ad50433d156c440b227ebae0e883d85a3">More...</a><br /></td></tr>
<tr class="separator:ad50433d156c440b227ebae0e883d85a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729f6e1552c6df7db231ce20f67947b2"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a729f6e1552c6df7db231ce20f67947b2">getNumIterators</a> (StringRef name, <a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a> iteratorTypes)</td></tr>
<tr class="memdesc:a729f6e1552c6df7db231ce20f67947b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the iterator of a certain type.  <a href="#a729f6e1552c6df7db231ce20f67947b2">More...</a><br /></td></tr>
<tr class="separator:a729f6e1552c6df7db231ce20f67947b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d068f0cba2b5a92fe603c4118664b61"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d068f0cba2b5a92fe603c4118664b61">getNumIterators</a> (<a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a> iteratorTypes)</td></tr>
<tr class="separator:a6d068f0cba2b5a92fe603c4118664b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cc57e028b9dcf6b1d9dc54b6489c58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a32cc57e028b9dcf6b1d9dc54b6489c58">populateVectorToVectorConversionPatterns</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; coarseVectorShape={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; fineVectorShape={})</td></tr>
<tr class="memdesc:a32cc57e028b9dcf6b1d9dc54b6489c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect a set of patterns to convert from the Vector dialect to itself.  <a href="#a32cc57e028b9dcf6b1d9dc54b6489c58">More...</a><br /></td></tr>
<tr class="separator:a32cc57e028b9dcf6b1d9dc54b6489c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3741dc3ccffcfafa71e4540ba59f08c0">shapeRatio</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; superShape, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; subShape)</td></tr>
<tr class="memdesc:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the multi-dimensional ratio of <code>superShape</code> to <code>subShape</code>.  <a href="#a3741dc3ccffcfafa71e4540ba59f08c0">More...</a><br /></td></tr>
<tr class="separator:a3741dc3ccffcfafa71e4540ba59f08c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937430eb9b6e13bfb05e6ecc5649a816"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a937430eb9b6e13bfb05e6ecc5649a816">shapeRatio</a> (<a class="el" href="classmlir_1_1VectorType.html">VectorType</a> superVectorType, <a class="el" href="classmlir_1_1VectorType.html">VectorType</a> subVectorType)</td></tr>
<tr class="memdesc:a937430eb9b6e13bfb05e6ecc5649a816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the multi-dimensional ratio of the shapes of <code>superVector</code> to <code>subVector</code>.  <a href="#a937430eb9b6e13bfb05e6ecc5649a816">More...</a><br /></td></tr>
<tr class="separator:a937430eb9b6e13bfb05e6ecc5649a816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ea257fc0167ade93ef4d07cdd98af8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a51ea257fc0167ade93ef4d07cdd98af8">initializeLLVMPasses</a> ()</td></tr>
<tr class="memdesc:a51ea257fc0167ade93ef4d07cdd98af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> passes that can be when running MLIR code using <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a>.  <a href="#a51ea257fc0167ade93ef4d07cdd98af8">More...</a><br /></td></tr>
<tr class="separator:a51ea257fc0167ade93ef4d07cdd98af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9141d8b586a68549d2ecaccbce99a69"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad9141d8b586a68549d2ecaccbce99a69">hash_value</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> arg)</td></tr>
<tr class="memdesc:ad9141d8b586a68549d2ecaccbce99a69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> hashable.  <a href="#ad9141d8b586a68549d2ecaccbce99a69">More...</a><br /></td></tr>
<tr class="separator:ad9141d8b586a68549d2ecaccbce99a69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8f6f52bcd2d859c9d9a6f393ad5481c1">operator+</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a8f6f52bcd2d859c9d9a6f393ad5481c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9137193b56dc5134c3092273b13e3f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9137193b56dc5134c3092273b13e3f47">operator*</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a9137193b56dc5134c3092273b13e3f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a72aa3fc8e169b33e5d4a63f593172d4e">operator-</a> (int64_t val, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr)</td></tr>
<tr class="separator:a72aa3fc8e169b33e5d4a63f593172d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd4323ef72147332661606b030d04d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#addfd4323ef72147332661606b030d04d">getAffineDimExpr</a> (unsigned position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:addfd4323ef72147332661606b030d04d"><td class="mdescLeft">&#160;</td><td class="mdescRight">These free functions allow clients of the API to not use classes in detail.  <a href="#addfd4323ef72147332661606b030d04d">More...</a><br /></td></tr>
<tr class="separator:addfd4323ef72147332661606b030d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb7ba5a55b4f16631528884d3617a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aefb7ba5a55b4f16631528884d3617a47">getAffineSymbolExpr</a> (unsigned position, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:aefb7ba5a55b4f16631528884d3617a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26cdced424aa629fde4150cc8674d50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab26cdced424aa629fde4150cc8674d50">getAffineConstantExpr</a> (int64_t <a class="el" href="LinalgToLLVM_8cpp.html#a6d6f472e257d29b0c75fa01732f79e44">constant</a>, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="separator:ab26cdced424aa629fde4150cc8674d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8a0f44c623301035b6151ca51cca4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6e8a0f44c623301035b6151ca51cca4d">getAffineBinaryOpExpr</a> (<a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a> kind, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> lhs, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> rhs)</td></tr>
<tr class="separator:a6e8a0f44c623301035b6151ca51cca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99196ca62d2b439656321b2bb00cc309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99196ca62d2b439656321b2bb00cc309">toAffineExpr</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; eq, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; localExprs, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a99196ca62d2b439656321b2bb00cc309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an affine expression from a flat ArrayRef.  <a href="#a99196ca62d2b439656321b2bb00cc309">More...</a><br /></td></tr>
<tr class="separator:a99196ca62d2b439656321b2bb00cc309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee64f56d77f8346c5187e789c587ae9"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abee64f56d77f8346c5187e789c587ae9">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;expr)</td></tr>
<tr class="separator:abee64f56d77f8346c5187e789c587ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe50d78867e8c7b15e7e481f931ca98b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afe50d78867e8c7b15e7e481f931ca98b">getFlattenedAffineExpr</a> (<a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> expr, unsigned numDims, unsigned numSymbols, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *flattenedExpr)</td></tr>
<tr class="memdesc:afe50d78867e8c7b15e7e481f931ca98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens 'expr' into 'flattenedExpr'.  <a href="#afe50d78867e8c7b15e7e481f931ca98b">More...</a><br /></td></tr>
<tr class="separator:afe50d78867e8c7b15e7e481f931ca98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da4e5105fe7664adb2d7c4f34bde6ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6da4e5105fe7664adb2d7c4f34bde6ae">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs)</td></tr>
<tr class="memdesc:a6da4e5105fe7664adb2d7c4f34bde6ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'.  <a href="#a6da4e5105fe7664adb2d7c4f34bde6ae">More...</a><br /></td></tr>
<tr class="separator:a6da4e5105fe7664adb2d7c4f34bde6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319408fd489397df5e58cb8193e5bfcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a319408fd489397df5e58cb8193e5bfcd">getFlattenedAffineExprs</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> set, std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *flattenedExprs)</td></tr>
<tr class="separator:a319408fd489397df5e58cb8193e5bfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97905517c34a363dacccfe12bb2fcc14"><td class="memTemplParams" colspan="2">template&lt;typename... AffineExprTy&gt; </td></tr>
<tr class="memitem:a97905517c34a363dacccfe12bb2fcc14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a97905517c34a363dacccfe12bb2fcc14">bindDims</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, AffineExprTy &amp;... exprs)</td></tr>
<tr class="memdesc:a97905517c34a363dacccfe12bb2fcc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> references to DimExpr at positions: [0 .  <a href="#a97905517c34a363dacccfe12bb2fcc14">More...</a><br /></td></tr>
<tr class="separator:a97905517c34a363dacccfe12bb2fcc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a032c893ca9a2fff3b16e5a7cb6d413cd">hash_value</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> arg)</td></tr>
<tr class="separator:a032c893ca9a2fff3b16e5a7cb6d413cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014d8e82c51794d145267690b2b5bd58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a014d8e82c51794d145267690b2b5bd58">simplifyAffineMap</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a014d8e82c51794d145267690b2b5bd58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> results.  <a href="#a014d8e82c51794d145267690b2b5bd58">More...</a><br /></td></tr>
<tr class="separator:a014d8e82c51794d145267690b2b5bd58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b322818d83a2256d4e4391acbf78a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a52b322818d83a2256d4e4391acbf78a2">inversePermutation</a> (<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="memdesc:a52b322818d83a2256d4e4391acbf78a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected.  <a href="#a52b322818d83a2256d4e4391acbf78a2">More...</a><br /></td></tr>
<tr class="separator:a52b322818d83a2256d4e4391acbf78a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6d24d64d6db077b8d5c88316b0d6c717">concatAffineMaps</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt; maps)</td></tr>
<tr class="memdesc:a6d24d64d6db077b8d5c88316b0d6c717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a>, stepping over potentially empty maps.  <a href="#a6d24d64d6db077b8d5c88316b0d6c717">More...</a><br /></td></tr>
<tr class="separator:a6d24d64d6db077b8d5c88316b0d6c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f93a44db5e2d93372201d5a594e51cd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6f93a44db5e2d93372201d5a594e51cd">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> map)</td></tr>
<tr class="separator:a6f93a44db5e2d93372201d5a594e51cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e8f0e932c305de3ac1584560d1b03d0">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a5e8f0e932c305de3ac1584560d1b03d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bae84b1d7cdba11b048d9af3478a07"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a68bae84b1d7cdba11b048d9af3478a07">hash_value</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> arg)</td></tr>
<tr class="separator:a68bae84b1d7cdba11b048d9af3478a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72e36349258a6b2baeae78188a74550"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae72e36349258a6b2baeae78188a74550">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;arg)</td></tr>
<tr class="separator:ae72e36349258a6b2baeae78188a74550"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a85b9a8e647d5e73b7e107b0669ec9e29">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;<a class="el" href="ConvertFromLLVMIR_8cpp.html#a6d80ed55125bb93b1e2eb58f0827ce39">diag</a>)</td></tr>
<tr class="separator:a85b9a8e647d5e73b7e107b0669ec9e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e96b0c437652eb5a4890734bb6bcee7">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a4e96b0c437652eb5a4890734bb6bcee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit an error message using this location.  <a href="#a4e96b0c437652eb5a4890734bb6bcee7">More...</a><br /></td></tr>
<tr class="separator:a4e96b0c437652eb5a4890734bb6bcee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2dc4e9418ff63ebea20c7f709ebcb0f8">emitError</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a2dc4e9418ff63ebea20c7f709ebcb0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0768c8a572dc71b0b00d57414b56b60d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0768c8a572dc71b0b00d57414b56b60d">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a0768c8a572dc71b0b00d57414b56b60d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a warning message using this location.  <a href="#a0768c8a572dc71b0b00d57414b56b60d">More...</a><br /></td></tr>
<tr class="separator:a0768c8a572dc71b0b00d57414b56b60d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e96e5ea091fb5bea539cef6ea7c5624">emitWarning</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a5e96e5ea091fb5bea539cef6ea7c5624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8a9ca6fe9d5aab498bf090db3e878c87">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc)</td></tr>
<tr class="memdesc:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility method to emit a remark message using this location.  <a href="#a8a9ca6fe9d5aab498bf090db3e878c87">More...</a><br /></td></tr>
<tr class="separator:a8a9ca6fe9d5aab498bf090db3e878c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a391c4b4ea9dc95fbcfbfdab8a49547a3">emitRemark</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> loc, const Twine &amp;message)</td></tr>
<tr class="separator:a391c4b4ea9dc95fbcfbfdab8a49547a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdaf0aee1c1669e8b822bf98297b85f"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:affdaf0aee1c1669e8b822bf98297b85f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#affdaf0aee1c1669e8b822bf98297b85f">emitOptionalError</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:affdaf0aee1c1669e8b822bf98297b85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads of the above emission functions that take an optionally null location.  <a href="#affdaf0aee1c1669e8b822bf98297b85f">More...</a><br /></td></tr>
<tr class="separator:affdaf0aee1c1669e8b822bf98297b85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665c32efa8059ae855341f4946f7497c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a665c32efa8059ae855341f4946f7497c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a665c32efa8059ae855341f4946f7497c">emitOptionalWarning</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a665c32efa8059ae855341f4946f7497c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab27e629384a23b9991e36201d87de462"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab27e629384a23b9991e36201d87de462"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab27e629384a23b9991e36201d87de462">emitOptionalRemark</a> (<a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; loc, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ab27e629384a23b9991e36201d87de462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251e44b317cf2b6a881db05d7c2110cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a251e44b317cf2b6a881db05d7c2110cf">registerDialectAllocator</a> (const <a class="el" href="namespacemlir.html#a94ae7dda0e636afc0a58acb0ed3342b4">DialectAllocatorFunction</a> &amp;function)</td></tr>
<tr class="memdesc:a251e44b317cf2b6a881db05d7c2110cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a specific dialect creation function with the system, typically used through the <a class="el" href="structmlir_1_1DialectRegistration.html" title="DialectRegistration provides a global initializer that registers a Dialect allocation routine...">DialectRegistration</a> template.  <a href="#a251e44b317cf2b6a881db05d7c2110cf">More...</a><br /></td></tr>
<tr class="separator:a251e44b317cf2b6a881db05d7c2110cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570c0f30ef4fa5cf0eadca4bfbe77a85"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a570c0f30ef4fa5cf0eadca4bfbe77a85">registerAllDialects</a> (<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a570c0f30ef4fa5cf0eadca4bfbe77a85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers all dialects with the specified <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a>.  <a href="#a570c0f30ef4fa5cf0eadca4bfbe77a85">More...</a><br /></td></tr>
<tr class="separator:a570c0f30ef4fa5cf0eadca4bfbe77a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f01195b0860006a1eb061e17634963"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteDialect &gt; </td></tr>
<tr class="memitem:a45f01195b0860006a1eb061e17634963"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a45f01195b0860006a1eb061e17634963">registerDialect</a> ()</td></tr>
<tr class="memdesc:a45f01195b0860006a1eb061e17634963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility to register a dialect.  <a href="#a45f01195b0860006a1eb061e17634963">More...</a><br /></td></tr>
<tr class="separator:a45f01195b0860006a1eb061e17634963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc637be7593f7a60dfc71a61256f41ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#adc637be7593f7a60dfc71a61256f41ea">registerDialectHooksSetter</a> (const <a class="el" href="namespacemlir.html#a485453da011e03403b043a915fd368ab">DialectHooksSetter</a> &amp;function)</td></tr>
<tr class="memdesc:adc637be7593f7a60dfc71a61256f41ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a function that will set hooks in the registered dialects based on information coming from <a class="el" href="structmlir_1_1DialectHooksRegistration.html" title="DialectHooksRegistration provides a global initializer that registers a dialect hooks setter routine...">DialectHooksRegistration</a>.  <a href="#adc637be7593f7a60dfc71a61256f41ea">More...</a><br /></td></tr>
<tr class="separator:adc637be7593f7a60dfc71a61256f41ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30603aed1417a20bef2b8efae1167bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a30603aed1417a20bef2b8efae1167bde">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a30603aed1417a20bef2b8efae1167bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649ee8579b14d0897aab47f53b883b29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a649ee8579b14d0897aab47f53b883b29">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, const APFloat &amp;value)</td></tr>
<tr class="separator:a649ee8579b14d0897aab47f53b883b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1afb696ee471be35a4d1f75c64ea1bd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1afb696ee471be35a4d1f75c64ea1bd4">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, float value)</td></tr>
<tr class="separator:a1afb696ee471be35a4d1f75c64ea1bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26a3adac6475f34a40e802331ee10d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae26a3adac6475f34a40e802331ee10d6">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, double value)</td></tr>
<tr class="separator:ae26a3adac6475f34a40e802331ee10d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ffb26ef01caacb04bda28d4501f4fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa2ffb26ef01caacb04bda28d4501f4fd">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:aa2ffb26ef01caacb04bda28d4501f4fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9916cd8c014a3b0a666cc2fe88a6fae"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; !std::is_convertible&lt; T &amp;, Attribute &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp;&gt;::value &amp;&amp;!llvm::is_one_of&lt; T, double, float &gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:af9916cd8c014a3b0a666cc2fe88a6fae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af9916cd8c014a3b0a666cc2fe88a6fae">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;p, const T &amp;other)</td></tr>
<tr class="separator:af9916cd8c014a3b0a666cc2fe88a6fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5b241db4d1de80e4879009596797b6"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f5b241db4d1de80e4879009596797b6">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Identifier.html">Identifier</a> identifier)</td></tr>
<tr class="separator:a9f5b241db4d1de80e4879009596797b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddf739fdaf5a03fdb07ac3b4c672f4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0ddf739fdaf5a03fdb07ac3b4c672f4e">operator==</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> lhs, <a class="el" href="classmlir_1_1Identifier.html">Identifier</a> rhs)</td></tr>
<tr class="separator:a0ddf739fdaf5a03fdb07ac3b4c672f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba1fa005aee40f3f33c8e44097af7377"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aba1fa005aee40f3f33c8e44097af7377">operator!=</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> lhs, <a class="el" href="classmlir_1_1Identifier.html">Identifier</a> rhs)</td></tr>
<tr class="separator:aba1fa005aee40f3f33c8e44097af7377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa492640c61b36ef2ab8565e5015abd1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa492640c61b36ef2ab8565e5015abd1e">operator==</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> lhs, StringRef rhs)</td></tr>
<tr class="separator:aa492640c61b36ef2ab8565e5015abd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec87c8e176e5200de6eabb890d01e96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeec87c8e176e5200de6eabb890d01e96">operator!=</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> lhs, StringRef rhs)</td></tr>
<tr class="separator:aeec87c8e176e5200de6eabb890d01e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b0dcdd7e4c238b039144d7840350f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad6b0dcdd7e4c238b039144d7840350f2">operator==</a> (StringRef lhs, <a class="el" href="classmlir_1_1Identifier.html">Identifier</a> rhs)</td></tr>
<tr class="separator:ad6b0dcdd7e4c238b039144d7840350f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa956129148e25edd5ec7b39b592c6082"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa956129148e25edd5ec7b39b592c6082">operator!=</a> (StringRef lhs, <a class="el" href="classmlir_1_1Identifier.html">Identifier</a> rhs)</td></tr>
<tr class="separator:aa956129148e25edd5ec7b39b592c6082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a060d54dd4c592884f7bb771cbff354e7"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a060d54dd4c592884f7bb771cbff354e7">hash_value</a> (<a class="el" href="classmlir_1_1Identifier.html">Identifier</a> arg)</td></tr>
<tr class="separator:a060d54dd4c592884f7bb771cbff354e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a655bb0e17a21ea2c35194f7c822c9ca5">hash_value</a> (<a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> arg)</td></tr>
<tr class="separator:a655bb0e17a21ea2c35194f7c822c9ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab097ddf5971ea2a3956fc814005f459f"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab097ddf5971ea2a3956fc814005f459f">operator&lt;&lt;</a> (raw_ostream &amp;os, const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;loc)</td></tr>
<tr class="separator:ab097ddf5971ea2a3956fc814005f459f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa6261878bc5197cfcc003e5b3fa735ea">hash_value</a> (<a class="el" href="classmlir_1_1Location.html">Location</a> arg)</td></tr>
<tr class="separator:aa6261878bc5197cfcc003e5b3fa735ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac267882a978b6b3c9d07e8fb3490d659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac267882a978b6b3c9d07e8fb3490d659">m_Constant</a> ()</td></tr>
<tr class="memdesc:ac267882a978b6b3c9d07e8fb3490d659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant foldable operation.  <a href="#ac267882a978b6b3c9d07e8fb3490d659">More...</a><br /></td></tr>
<tr class="separator:ac267882a978b6b3c9d07e8fb3490d659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplParams" colspan="2">template&lt;typename AttrT &gt; </td></tr>
<tr class="memitem:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt; AttrT &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a10b6da5781fbe1b019fcb64dcd6921dd">m_Constant</a> (AttrT *bind_value)</td></tr>
<tr class="memdesc:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a value from a constant foldable operation and writes the value to bind_value.  <a href="#a10b6da5781fbe1b019fcb64dcd6921dd">More...</a><br /></td></tr>
<tr class="separator:a10b6da5781fbe1b019fcb64dcd6921dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4cc1a8746679396a5dfe6e4c7ef8396"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__matcher.html">detail::constant_int_value_matcher</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac4cc1a8746679396a5dfe6e4c7ef8396">m_One</a> ()</td></tr>
<tr class="memdesc:ac4cc1a8746679396a5dfe6e4c7ef8396"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer one.  <a href="#ac4cc1a8746679396a5dfe6e4c7ef8396">More...</a><br /></td></tr>
<tr class="separator:ac4cc1a8746679396a5dfe6e4c7ef8396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplParams" colspan="2">template&lt;typename OpClass &gt; </td></tr>
<tr class="memitem:ac2418532386147bec2ca5aadf5414406"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt; OpClass &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2418532386147bec2ca5aadf5414406">m_Op</a> ()</td></tr>
<tr class="memdesc:ac2418532386147bec2ca5aadf5414406"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches the given OpClass.  <a href="#ac2418532386147bec2ca5aadf5414406">More...</a><br /></td></tr>
<tr class="separator:ac2418532386147bec2ca5aadf5414406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf138ddcdd4a81f4047f2d6bbee3482"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__matcher.html">detail::constant_int_value_matcher</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacf138ddcdd4a81f4047f2d6bbee3482">m_Zero</a> ()</td></tr>
<tr class="memdesc:aacf138ddcdd4a81f4047f2d6bbee3482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer zero.  <a href="#aacf138ddcdd4a81f4047f2d6bbee3482">More...</a><br /></td></tr>
<tr class="separator:aacf138ddcdd4a81f4047f2d6bbee3482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585ff769cbd1cef62ceda90ccd14062a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__not__value__matcher.html">detail::constant_int_not_value_matcher</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a585ff769cbd1cef62ceda90ccd14062a">m_NonZero</a> ()</td></tr>
<tr class="memdesc:a585ff769cbd1cef62ceda90ccd14062a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value.  <a href="#a585ff769cbd1cef62ceda90ccd14062a">More...</a><br /></td></tr>
<tr class="separator:a585ff769cbd1cef62ceda90ccd14062a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a0190228b09e7b51a4bc1e013c01d404c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0190228b09e7b51a4bc1e013c01d404c">matchPattern</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> value, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a0190228b09e7b51a4bc1e013c01d404c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>.  <a href="#a0190228b09e7b51a4bc1e013c01d404c">More...</a><br /></td></tr>
<tr class="separator:a0190228b09e7b51a4bc1e013c01d404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplParams" colspan="2">template&lt;typename Pattern &gt; </td></tr>
<tr class="memitem:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b97d57dcd6c08b495fbd3ef22aeda6f">matchPattern</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;pattern)</td></tr>
<tr class="memdesc:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a>.  <a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">More...</a><br /></td></tr>
<tr class="separator:a1b97d57dcd6c08b495fbd3ef22aeda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930dbe1d176d999aec049a4581838974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">detail::constant_int_op_binder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a930dbe1d176d999aec049a4581838974">m_ConstantInt</a> (<a class="el" href="classmlir_1_1IntegerAttr.html#a338d41710c0bd77a572190b8d552c754">IntegerAttr::ValueType</a> *bind_value)</td></tr>
<tr class="memdesc:a930dbe1d176d999aec049a4581838974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value.  <a href="#a930dbe1d176d999aec049a4581838974">More...</a><br /></td></tr>
<tr class="separator:a930dbe1d176d999aec049a4581838974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplParams" colspan="2">template&lt;typename OpType , typename... Matchers&gt; </td></tr>
<tr class="memitem:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7ecde76b07cd295bae0d6ef10d1c45d8">m_Op</a> (Matchers... matchers)</td></tr>
<tr class="separator:a7ecde76b07cd295bae0d6ef10d1c45d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f129dda2c412845b5ec66a77325a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abc4f129dda2c412845b5ec66a77325a3">operator==</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:abc4f129dda2c412845b5ec66a77325a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee326f96469cd288efb48265e173295e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aee326f96469cd288efb48265e173295e">operator!=</a> (<a class="el" href="classmlir_1_1OpState.html">OpState</a> lhs, <a class="el" href="classmlir_1_1OpState.html">OpState</a> rhs)</td></tr>
<tr class="separator:aee326f96469cd288efb48265e173295e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253b4a2344293dfbeab47ede8971fb29"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a253b4a2344293dfbeab47ede8971fb29">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;op)</td></tr>
<tr class="separator:a253b4a2344293dfbeab47ede8971fb29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff09e0657f1f97508b409ac5f6e4e5b8"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aff09e0657f1f97508b409ac5f6e4e5b8">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> identifier)</td></tr>
<tr class="separator:aff09e0657f1f97508b409ac5f6e4e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c6a127d8f1fa12d3c7405b9d51a695"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a14c6a127d8f1fa12d3c7405b9d51a695">operator==</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> lhs, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> rhs)</td></tr>
<tr class="separator:a14c6a127d8f1fa12d3c7405b9d51a695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5da97a01717dee2c2fa7ad551de8dc46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5da97a01717dee2c2fa7ad551de8dc46">operator!=</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> lhs, <a class="el" href="classmlir_1_1OperationName.html">OperationName</a> rhs)</td></tr>
<tr class="separator:a5da97a01717dee2c2fa7ad551de8dc46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93109842c1b05424c5052d9bd9a4394"><td class="memItemLeft" align="right" valign="top">llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad93109842c1b05424c5052d9bd9a4394">hash_value</a> (<a class="el" href="classmlir_1_1OperationName.html">OperationName</a> arg)</td></tr>
<tr class="separator:ad93109842c1b05424c5052d9bd9a4394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acabdc4e9d44aae13942c9ea9b41b9a33">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:acabdc4e9d44aae13942c9ea9b41b9a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0454cf763cf2a4bab30345a05f174fe6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename std::enable_if&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp;&gt;::value, T &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:a0454cf763cf2a4bab30345a05f174fe6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0454cf763cf2a4bab30345a05f174fe6">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const T &amp;values)</td></tr>
<tr class="separator:a0454cf763cf2a4bab30345a05f174fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b198f57489cfde31dc674cca18d6e9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9b198f57489cfde31dc674cca18d6e9d">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:a9b198f57489cfde31dc674cca18d6e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6974d43c0e2f0e03e5ffe739237dcae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6974d43c0e2f0e03e5ffe739237dcae4">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="separator:a6974d43c0e2f0e03e5ffe739237dcae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05b62a76688ea80f262ea5b69665ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af05b62a76688ea80f262ea5b69665ae4">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, bool value)</td></tr>
<tr class="separator:af05b62a76688ea80f262ea5b69665ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb66d612704fc6cbd310158b9458545"><td class="memTemplParams" colspan="2">template&lt;typename IteratorT &gt; </td></tr>
<tr class="memitem:a2cb66d612704fc6cbd310158b9458545"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2cb66d612704fc6cbd310158b9458545">operator&lt;&lt;</a> (<a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;p, const <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1ValueTypeIterator.html">ValueTypeIterator</a>&lt; IteratorT &gt;&gt; &amp;types)</td></tr>
<tr class="separator:a2cb66d612704fc6cbd310158b9458545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab790599e761a4417fba233542b93a654"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab790599e761a4417fba233542b93a654">applyPatternsGreedily</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:ab790599e761a4417fba233542b93a654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the regions of the specified operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy work-list driven manner.  <a href="#ab790599e761a4417fba233542b93a654">More...</a><br /></td></tr>
<tr class="separator:ab790599e761a4417fba233542b93a654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909c445a02cac083be999a1dbb578939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a909c445a02cac083be999a1dbb578939">applyPatternsGreedily</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns)</td></tr>
<tr class="memdesc:a909c445a02cac083be999a1dbb578939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrite the given regions, which must be isolated from above.  <a href="#a909c445a02cac083be999a1dbb578939">More...</a><br /></td></tr>
<tr class="separator:a909c445a02cac083be999a1dbb578939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506c478f802ab2f874c0b34a18bc091b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a506c478f802ab2f874c0b34a18bc091b">getStridesAndOffset</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;strides, int64_t &amp;offset)</td></tr>
<tr class="memdesc:a506c478f802ab2f874c0b34a18bc091b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the strides of the MemRef if the layout map is in strided form.  <a href="#a506c478f802ab2f874c0b34a18bc091b">More...</a><br /></td></tr>
<tr class="separator:a506c478f802ab2f874c0b34a18bc091b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d8af8a280cbdd7ffbf4629ee82ccc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab9d8af8a280cbdd7ffbf4629ee82ccc4">getStridesAndOffset</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;strides, <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;offset)</td></tr>
<tr class="separator:ab9d8af8a280cbdd7ffbf4629ee82ccc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923fafcbdcfdcb3b735fab2ab293a1ad">makeStridedLinearLayoutMap</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; strides, int64_t offset, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a list of strides (in which <a class="el" href="classmlir_1_1MemRefType.html#acbdbbe58df49b67438c3c03507d0c8b3">MemRefType::getDynamicStrideOrOffset()</a> represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> which represents the linearized strided layout map.  <a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">More...</a><br /></td></tr>
<tr class="separator:a923fafcbdcfdcb3b735fab2ab293a1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80dcfbd64b4c5038926d874e46edeea2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a80dcfbd64b4c5038926d874e46edeea2">canonicalizeStridedLayout</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t)</td></tr>
<tr class="memdesc:a80dcfbd64b4c5038926d874e46edeea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout.  <a href="#a80dcfbd64b4c5038926d874e46edeea2">More...</a><br /></td></tr>
<tr class="separator:a80dcfbd64b4c5038926d874e46edeea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c26bcf64137533f38f2cda9abd75af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad0c26bcf64137533f38f2cda9abd75af">isStrided</a> (<a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> t)</td></tr>
<tr class="memdesc:ad0c26bcf64137533f38f2cda9abd75af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the layout for <code>t</code> is compatible with strided semantics.  <a href="#ad0c26bcf64137533f38f2cda9abd75af">More...</a><br /></td></tr>
<tr class="separator:ad0c26bcf64137533f38f2cda9abd75af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5bfd80339235fbb32a685ff75f4e16"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acd5bfd80339235fbb32a685ff75f4e16">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:acd5bfd80339235fbb32a685ff75f4e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eede9183d3fdae566e18d94a5ef51b"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a31eede9183d3fdae566e18d94a5ef51b">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a31eede9183d3fdae566e18d94a5ef51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a82686ceb29eb0f78b59e29021f1b2cdd">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="memdesc:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="#a82686ceb29eb0f78b59e29021f1b2cdd">More...</a><br /></td></tr>
<tr class="separator:a82686ceb29eb0f78b59e29021f1b2cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252aee27751e05d584d0b1a8e793ecf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a252aee27751e05d584d0b1a8e793ecf0">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Attribute.html">Attribute</a> attr)</td></tr>
<tr class="memdesc:a252aee27751e05d584d0b1a8e793ecf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element type or return the type itself.  <a href="#a252aee27751e05d584d0b1a8e793ecf0">More...</a><br /></td></tr>
<tr class="separator:a252aee27751e05d584d0b1a8e793ecf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae81d443c449b61825fb2c2ec6aa90d35">getElementTypeOrSelf</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> val)</td></tr>
<tr class="separator:ae81d443c449b61825fb2c2ec6aa90d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46bbb7497276c5ea7e8ed4ad1315bf40">getFlattenedTypes</a> (<a class="el" href="classmlir_1_1TupleType.html">TupleType</a> t)</td></tr>
<tr class="memdesc:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the types within a nested Tuple.  <a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">More...</a><br /></td></tr>
<tr class="separator:a46bbb7497276c5ea7e8ed4ad1315bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4bd6b581b08699ce79d3e9f820c1ade9">isOpaqueTypeWithName</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type, StringRef dialect, StringRef typeData)</td></tr>
<tr class="memdesc:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified type is an opaque type with the specified dialect and typeData.  <a href="#a4bd6b581b08699ce79d3e9f820c1ade9">More...</a><br /></td></tr>
<tr class="separator:a4bd6b581b08699ce79d3e9f820c1ade9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb414ad1d507c2ab841305c273f4deb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#acb414ad1d507c2ab841305c273f4deb8">verifyCompatibleShape</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape1, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; shape2)</td></tr>
<tr class="memdesc:acb414ad1d507c2ab841305c273f4deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two shapes are compatible.  <a href="#acb414ad1d507c2ab841305c273f4deb8">More...</a><br /></td></tr>
<tr class="separator:acb414ad1d507c2ab841305c273f4deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac54e5e6c31f51ef648f7c03652a29ce6">verifyCompatibleShape</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> type1, <a class="el" href="classmlir_1_1Type.html">Type</a> type2)</td></tr>
<tr class="memdesc:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns success if the given two types have compatible shape.  <a href="#ac54e5e6c31f51ef648f7c03652a29ce6">More...</a><br /></td></tr>
<tr class="separator:ac54e5e6c31f51ef648f7c03652a29ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3df16c49c963cdc57cf6f9e7c3e9f822">operator&lt;&lt;</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Value.html">Value</a> value)</td></tr>
<tr class="separator:a3df16c49c963cdc57cf6f9e7c3e9f822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab710b1f6f21f3f35197575b609aae4b4"><td class="memItemLeft" align="right" valign="top">inline ::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab710b1f6f21f3f35197575b609aae4b4">hash_value</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> arg)</td></tr>
<tr class="memdesc:ab710b1f6f21f3f35197575b609aae4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable.  <a href="#ab710b1f6f21f3f35197575b609aae4b4">More...</a><br /></td></tr>
<tr class="separator:ab710b1f6f21f3f35197575b609aae4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58242edc66b5abcd9ee83a1ba8eeef9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a58242edc66b5abcd9ee83a1ba8eeef9a">parseSourceFile</a> (const llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a58242edc66b5abcd9ee83a1ba8eeef9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated SourceMgr and returns an MLIR module if it was valid.  <a href="#a58242edc66b5abcd9ee83a1ba8eeef9a">More...</a><br /></td></tr>
<tr class="separator:a58242edc66b5abcd9ee83a1ba8eeef9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62f251042b70003de696c34e9d6ef21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af62f251042b70003de696c34e9d6ef21">parseSourceFile</a> (llvm::StringRef filename, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:af62f251042b70003de696c34e9d6ef21"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename and returns an MLIR module if it was valid.  <a href="#af62f251042b70003de696c34e9d6ef21">More...</a><br /></td></tr>
<tr class="separator:af62f251042b70003de696c34e9d6ef21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0223a06797244d877e547544d49b7cad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0223a06797244d877e547544d49b7cad">parseSourceFile</a> (llvm::StringRef filename, llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a0223a06797244d877e547544d49b7cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the file specified by the indicated filename using the provided SourceMgr and returns an MLIR module if it was valid.  <a href="#a0223a06797244d877e547544d49b7cad">More...</a><br /></td></tr>
<tr class="separator:a0223a06797244d877e547544d49b7cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35164c0dafdbc75ec99d61670e14f4fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a35164c0dafdbc75ec99d61670e14f4fa">parseSourceString</a> (llvm::StringRef moduleStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:a35164c0dafdbc75ec99d61670e14f4fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses the module string to a MLIR module if it was valid.  <a href="#a35164c0dafdbc75ec99d61670e14f4fa">More...</a><br /></td></tr>
<tr class="separator:a35164c0dafdbc75ec99d61670e14f4fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1aa182f707b3cb6a071cf1a9937578d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#af1aa182f707b3cb6a071cf1a9937578d">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:af1aa182f707b3cb6a071cf1a9937578d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <a href="#af1aa182f707b3cb6a071cf1a9937578d">More...</a><br /></td></tr>
<tr class="separator:af1aa182f707b3cb6a071cf1a9937578d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34310a5d6e4690062af470064089068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae34310a5d6e4690062af470064089068">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1Type.html">Type</a> type)</td></tr>
<tr class="separator:ae34310a5d6e4690062af470064089068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2bd19a863e2bf8969c4bae3ecaa84a16">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t &amp;numRead)</td></tr>
<tr class="memdesc:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR attribute to an MLIR context if it was valid.  <a href="#a2bd19a863e2bf8969c4bae3ecaa84a16">More...</a><br /></td></tr>
<tr class="separator:a2bd19a863e2bf8969c4bae3ecaa84a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61d149703ad4537629141fab7417075"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae61d149703ad4537629141fab7417075">parseAttribute</a> (llvm::StringRef attrStr, <a class="el" href="classmlir_1_1Type.html">Type</a> type, size_t &amp;numRead)</td></tr>
<tr class="separator:ae61d149703ad4537629141fab7417075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ffe10560be9caf3b9e8de592c20e93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac5ffe10560be9caf3b9e8de592c20e93">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ac5ffe10560be9caf3b9e8de592c20e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <a href="#ac5ffe10560be9caf3b9e8de592c20e93">More...</a><br /></td></tr>
<tr class="separator:ac5ffe10560be9caf3b9e8de592c20e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafaf30c94bd5327a769f9fd691cd42a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afafaf30c94bd5327a769f9fd691cd42a">parseType</a> (llvm::StringRef typeStr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context, size_t &amp;numRead)</td></tr>
<tr class="memdesc:afafaf30c94bd5327a769f9fd691cd42a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This parses a single MLIR type to an MLIR context if it was valid.  <a href="#afafaf30c94bd5327a769f9fd691cd42a">More...</a><br /></td></tr>
<tr class="separator:afafaf30c94bd5327a769f9fd691cd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5c4edce10b597637635af55bb162477"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa5c4edce10b597637635af55bb162477">registerPassManagerCLOptions</a> ()</td></tr>
<tr class="memdesc:aa5c4edce10b597637635af55bb162477"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a set of useful command-line options that can be used to configure a pass manager.  <a href="#aa5c4edce10b597637635af55bb162477">More...</a><br /></td></tr>
<tr class="separator:aa5c4edce10b597637635af55bb162477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706b943c7bb07b96e86234204b79b3d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a706b943c7bb07b96e86234204b79b3d4">applyPassManagerCLOptions</a> (<a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;pm)</td></tr>
<tr class="memdesc:a706b943c7bb07b96e86234204b79b3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'.  <a href="#a706b943c7bb07b96e86234204b79b3d4">More...</a><br /></td></tr>
<tr class="separator:a706b943c7bb07b96e86234204b79b3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff481c2677a398dcb9c3aacebebc42c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aff481c2677a398dcb9c3aacebebc42c3">registerPassPipeline</a> (StringRef arg, StringRef description, const <a class="el" href="namespacemlir.html#a9d158c94373a029243fd7006eb79cc87">PassRegistryFunction</a> &amp;function)</td></tr>
<tr class="memdesc:aff481c2677a398dcb9c3aacebebc42c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template.  <a href="#aff481c2677a398dcb9c3aacebebc42c3">More...</a><br /></td></tr>
<tr class="separator:aff481c2677a398dcb9c3aacebebc42c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0664e453602a0a69ceb9bad705d4ac10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0664e453602a0a69ceb9bad705d4ac10">registerPass</a> (StringRef arg, StringRef description, const <a class="el" href="namespacemlir.html#a3bf899dff597a809a700779b46dc4972">PassID</a> *passID, const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;function)</td></tr>
<tr class="memdesc:a0664e453602a0a69ceb9bad705d4ac10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template.  <a href="#a0664e453602a0a69ceb9bad705d4ac10">More...</a><br /></td></tr>
<tr class="separator:a0664e453602a0a69ceb9bad705d4ac10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d10077c7edf58c1152a1170257d739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad8d10077c7edf58c1152a1170257d739">parsePassPipeline</a> (StringRef pipeline, <a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;pm, raw_ostream &amp;errorStream=llvm::errs())</td></tr>
<tr class="memdesc:ad8d10077c7edf58c1152a1170257d739"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function parses the textual representation of a pass pipeline, and adds the result to 'pm' on success.  <a href="#ad8d10077c7edf58c1152a1170257d739">More...</a><br /></td></tr>
<tr class="separator:ad8d10077c7edf58c1152a1170257d739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc84cc9baea1d755e04cc705616c9b1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6bc84cc9baea1d755e04cc705616c9b1"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6bc84cc9baea1d755e04cc705616c9b1">debugString</a> (T &amp;op)</td></tr>
<tr class="separator:a6bc84cc9baea1d755e04cc705616c9b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">openInputFile</a> (llvm::StringRef <a class="el" href="JitRunner_8cpp.html#afad94d877701daad7b5ccfe3ed9ecc23">inputFilename</a>, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for reading.  <a href="#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">More...</a><br /></td></tr>
<tr class="separator:a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::ToolOutputFile &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4c8c9750d9c8efdbcc7542f3b1564d8d">openOutputFile</a> (llvm::StringRef outputFilename, std::string *errorMessage=nullptr)</td></tr>
<tr class="memdesc:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open the file specified by its name for writing.  <a href="#a4c8c9750d9c8efdbcc7542f3b1564d8d">More...</a><br /></td></tr>
<tr class="separator:a4c8c9750d9c8efdbcc7542f3b1564d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d1b07f83032b4bccf115a648e0f907"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a75d1b07f83032b4bccf115a648e0f907">JitRunnerMain</a> (int argc, char **argv, <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1ModuleOp.html">mlir::ModuleOp</a>)&gt; mlirTransformer)</td></tr>
<tr class="separator:a75d1b07f83032b4bccf115a648e0f907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed">success</a> (bool isSuccess=true)</td></tr>
<tr class="memdesc:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>.  <a href="#a5f55c06c7c4aeace3f6824dd68f8b1ed">More...</a><br /></td></tr>
<tr class="separator:a5f55c06c7c4aeace3f6824dd68f8b1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">failure</a> (bool isFailure=true)</td></tr>
<tr class="memdesc:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>.  <a href="#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">More...</a><br /></td></tr>
<tr class="separator:a07367c8c4a3d4a47a32bc2b9b7d8a3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a1cb2e1046f84d6328600b92c99e52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a57a1cb2e1046f84d6328600b92c99e52">succeeded</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> result)</td></tr>
<tr class="memdesc:a57a1cb2e1046f84d6328600b92c99e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> corresponds to a success value.  <a href="#a57a1cb2e1046f84d6328600b92c99e52">More...</a><br /></td></tr>
<tr class="separator:a57a1cb2e1046f84d6328600b92c99e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec13ab4fb753865cdfd2699aa01c23b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeec13ab4fb753865cdfd2699aa01c23b">failed</a> (<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> result)</td></tr>
<tr class="memdesc:aeec13ab4fb753865cdfd2699aa01c23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> corresponds to a failure value.  <a href="#aeec13ab4fb753865cdfd2699aa01c23b">More...</a><br /></td></tr>
<tr class="separator:aeec13ab4fb753865cdfd2699aa01c23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a3d17c70f67aa2d18203667acaf114"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a46a3d17c70f67aa2d18203667acaf114">ceilDiv</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:a46a3d17c70f67aa2d18203667acaf114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of MLIR's ceildiv operation on constants.  <a href="#a46a3d17c70f67aa2d18203667acaf114">More...</a><br /></td></tr>
<tr class="separator:a46a3d17c70f67aa2d18203667acaf114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3983eab6c9a05efd28747c0e79dd9d44"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3983eab6c9a05efd28747c0e79dd9d44">floorDiv</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:a3983eab6c9a05efd28747c0e79dd9d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the result of MLIR's floordiv operation on constants.  <a href="#a3983eab6c9a05efd28747c0e79dd9d44">More...</a><br /></td></tr>
<tr class="separator:a3983eab6c9a05efd28747c0e79dd9d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca33cad5b0cd935568ea0fc0a439abd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afca33cad5b0cd935568ea0fc0a439abd">mod</a> (int64_t lhs, int64_t rhs)</td></tr>
<tr class="memdesc:afca33cad5b0cd935568ea0fc0a439abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns MLIR's mod operation on constants.  <a href="#afca33cad5b0cd935568ea0fc0a439abd">More...</a><br /></td></tr>
<tr class="separator:afca33cad5b0cd935568ea0fc0a439abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5f7a5c72c1e0e867f3aac796b26ec2aa">lcm</a> (int64_t a, int64_t b)</td></tr>
<tr class="memdesc:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the least common multiple of 'a' and 'b'.  <a href="#a5f7a5c72c1e0e867f3aac796b26ec2aa">More...</a><br /></td></tr>
<tr class="separator:a5f7a5c72c1e0e867f3aac796b26ec2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9bf0a43f6ae7b00a5dd777d74d65b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac9bf0a43f6ae7b00a5dd777d74d65b58">MlirOptMain</a> (llvm::raw_ostream &amp;os, std::unique_ptr&lt; llvm::MemoryBuffer &gt; buffer, const <a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a> &amp;passPipeline, bool splitInputFile, bool verifyDiagnostics, bool verifyPasses)</td></tr>
<tr class="separator:ac9bf0a43f6ae7b00a5dd777d74d65b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8a8aef862a81d9299c1444038b3e67f"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename UnaryFunctor , typename NullaryFunctor , typename  = typename std::enable_if&lt;              !std::is_constructible&lt;StringRef, UnaryFunctor&gt;::value &amp;&amp;              !std::is_constructible&lt;StringRef, NullaryFunctor&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae8a8aef862a81d9299c1444038b3e67f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae8a8aef862a81d9299c1444038b3e67f">interleave</a> (ForwardIterator begin, ForwardIterator end, UnaryFunctor each_fn, NullaryFunctor between_fn)</td></tr>
<tr class="memdesc:ae8a8aef862a81d9299c1444038b3e67f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An STL-style algorithm similar to std::for_each that applies a second functor between every pair of elements.  <a href="#ae8a8aef862a81d9299c1444038b3e67f">More...</a><br /></td></tr>
<tr class="separator:ae8a8aef862a81d9299c1444038b3e67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705fe42a16585f4416744194cf20ca3b"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunctor , typename NullaryFunctor , typename  = typename std::enable_if&lt;              !std::is_constructible&lt;StringRef, UnaryFunctor&gt;::value &amp;&amp;              !std::is_constructible&lt;StringRef, NullaryFunctor&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a705fe42a16585f4416744194cf20ca3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a705fe42a16585f4416744194cf20ca3b">interleave</a> (const Container &amp;c, UnaryFunctor each_fn, NullaryFunctor between_fn)</td></tr>
<tr class="separator:a705fe42a16585f4416744194cf20ca3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f58a9799d63ae7c61ebc3e7826b27d8"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunctor , typename raw_ostream , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a8f58a9799d63ae7c61ebc3e7826b27d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8f58a9799d63ae7c61ebc3e7826b27d8">interleave</a> (const Container &amp;c, raw_ostream &amp;os, UnaryFunctor each_fn, const StringRef &amp;separator)</td></tr>
<tr class="memdesc:a8f58a9799d63ae7c61ebc3e7826b27d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of interleave for the common case of string separator.  <a href="#a8f58a9799d63ae7c61ebc3e7826b27d8">More...</a><br /></td></tr>
<tr class="separator:a8f58a9799d63ae7c61ebc3e7826b27d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fdcfac89fcbf9f678d791ad9897b29"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename raw_ostream , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:ad3fdcfac89fcbf9f678d791ad9897b29"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad3fdcfac89fcbf9f678d791ad9897b29">interleave</a> (const Container &amp;c, raw_ostream &amp;os, const StringRef &amp;separator)</td></tr>
<tr class="separator:ad3fdcfac89fcbf9f678d791ad9897b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201521de2339762c1c50305ae2aaa245"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename UnaryFunctor , typename raw_ostream , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:a201521de2339762c1c50305ae2aaa245"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a201521de2339762c1c50305ae2aaa245">interleaveComma</a> (const Container &amp;c, raw_ostream &amp;os, UnaryFunctor each_fn)</td></tr>
<tr class="separator:a201521de2339762c1c50305ae2aaa245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab948853b9cc4777456a793ee58eed635"><td class="memTemplParams" colspan="2">template&lt;typename Container , typename raw_ostream , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </td></tr>
<tr class="memitem:ab948853b9cc4777456a793ee58eed635"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab948853b9cc4777456a793ee58eed635">interleaveComma</a> (const Container &amp;c, raw_ostream &amp;os)</td></tr>
<tr class="separator:ab948853b9cc4777456a793ee58eed635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac48118e62e44dabf4e8cf759a87daf6"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:aac48118e62e44dabf4e8cf759a87daf6"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aac48118e62e44dabf4e8cf759a87daf6">make_second_range</a> (ContainerTy &amp;&amp;c)</td></tr>
<tr class="memdesc:aac48118e62e44dabf4e8cf759a87daf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a container of pairs, return a range over the second elements.  <a href="#aac48118e62e44dabf4e8cf759a87daf6">More...</a><br /></td></tr>
<tr class="separator:aac48118e62e44dabf4e8cf759a87daf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e57462dce07886d882db84bbe3aa9f1"><td class="memTemplParams" colspan="2">template&lt;typename ContainerTy &gt; </td></tr>
<tr class="memitem:a3e57462dce07886d882db84bbe3aa9f1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3e57462dce07886d882db84bbe3aa9f1">has_single_element</a> (ContainerTy &amp;&amp;c)</td></tr>
<tr class="memdesc:a3e57462dce07886d882db84bbe3aa9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true of the given range only contains a single element.  <a href="#a3e57462dce07886d882db84bbe3aa9f1">More...</a><br /></td></tr>
<tr class="separator:a3e57462dce07886d882db84bbe3aa9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4be4316ece2a64d363670801d7c64555"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4be4316ece2a64d363670801d7c64555">convertToSnakeCase</a> (llvm::StringRef input)</td></tr>
<tr class="memdesc:a4be4316ece2a64d363670801d7c64555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string to snake-case from camel-case by replacing all uppercase letters with '_' followed by the letter in lowercase, except if the uppercase letter is the first character of the string.  <a href="#a4be4316ece2a64d363670801d7c64555">More...</a><br /></td></tr>
<tr class="separator:a4be4316ece2a64d363670801d7c64555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf77fbf5a0ed9246f9754a542730b4d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aaf77fbf5a0ed9246f9754a542730b4d5">convertToCamelCase</a> (llvm::StringRef input, bool capitalizeFirst=false)</td></tr>
<tr class="memdesc:aaf77fbf5a0ed9246f9754a542730b4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a string from camel-case to snake_case by replacing all occurrences of '_' followed by a lowercase letter with the letter in uppercase.  <a href="#aaf77fbf5a0ed9246f9754a542730b4d5">More...</a><br /></td></tr>
<tr class="separator:aaf77fbf5a0ed9246f9754a542730b4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2320d5e3423bb76edf4048a5674f8f8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2320d5e3423bb76edf4048a5674f8f8e">splitAndProcessBuffer</a> (std::unique_ptr&lt; llvm::MemoryBuffer &gt; originalBuffer, <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a> processChunkBuffer, raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a2320d5e3423bb76edf4048a5674f8f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits the specified buffer on a marker (<code>// -----</code>), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>.  <a href="#a2320d5e3423bb76edf4048a5674f8f8e">More...</a><br /></td></tr>
<tr class="separator:a2320d5e3423bb76edf4048a5674f8f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4058138ab0e09ce0f2a5feb8914d96"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0e4058138ab0e09ce0f2a5feb8914d96">translateModuleToLLVMIR</a> (<a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> m)</td></tr>
<tr class="memdesc:a0e4058138ab0e09ce0f2a5feb8914d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given MLIR module into <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR.  <a href="#a0e4058138ab0e09ce0f2a5feb8914d96">More...</a><br /></td></tr>
<tr class="separator:a0e4058138ab0e09ce0f2a5feb8914d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41497963c69c44476e78ff2043d4651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae41497963c69c44476e78ff2043d4651">translateLLVMIRToModule</a> (std::unique_ptr&lt; llvm::Module &gt; llvmModule, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *context)</td></tr>
<tr class="memdesc:ae41497963c69c44476e78ff2043d4651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into MLIR's <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect.  <a href="#ae41497963c69c44476e78ff2043d4651">More...</a><br /></td></tr>
<tr class="separator:ae41497963c69c44476e78ff2043d4651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3441a2171191be8197234c816fa275d6"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3441a2171191be8197234c816fa275d6">translateModuleToNVVMIR</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *m)</td></tr>
<tr class="memdesc:a3441a2171191be8197234c816fa275d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given LLVM-module-like operation into <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> IR.  <a href="#a3441a2171191be8197234c816fa275d6">More...</a><br /></td></tr>
<tr class="separator:a3441a2171191be8197234c816fa275d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc65d8bfacc95e54f8bf534fb66b8db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; llvm::Module &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1bc65d8bfacc95e54f8bf534fb66b8db">translateModuleToROCDLIR</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *m)</td></tr>
<tr class="memdesc:a1bc65d8bfacc95e54f8bf534fb66b8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the given LLVM-module-like operation into <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> IR.  <a href="#a1bc65d8bfacc95e54f8bf534fb66b8db">More...</a><br /></td></tr>
<tr class="separator:a1bc65d8bfacc95e54f8bf534fb66b8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923f103c236da2f1bb3afc9ceff7ac13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a923f103c236da2f1bb3afc9ceff7ac13">populateFuncOpTypeConversionPattern</a> (<a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *ctx, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;converter)</td></tr>
<tr class="memdesc:a923f103c236da2f1bb3afc9ceff7ac13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a pattern to the given pattern list to convert the signature of a <a class="el" href="classmlir_1_1FuncOp.html" title="FuncOp represents a function, or an operation containing one region that forms a CFG(Control Flow Gra...">FuncOp</a> with the given type converter.  <a href="#a923f103c236da2f1bb3afc9ceff7ac13">More...</a><br /></td></tr>
<tr class="separator:a923f103c236da2f1bb3afc9ceff7ac13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb5e2289856e1f55dda26449decb01f"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8fb5e2289856e1f55dda26449decb01f">applyPartialConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *converter=nullptr)</td></tr>
<tr class="memdesc:a8fb5e2289856e1f55dda26449decb01f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Below we define several entry points for operation conversion.  <a href="#a8fb5e2289856e1f55dda26449decb01f">More...</a><br /></td></tr>
<tr class="separator:a8fb5e2289856e1f55dda26449decb01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48db022f7a07df86a486209a5ddd3917"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a48db022f7a07df86a486209a5ddd3917">applyPartialConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *converter=nullptr)</td></tr>
<tr class="separator:a48db022f7a07df86a486209a5ddd3917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5c4de80f0f4b1da1d303c0d578e193"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aef5c4de80f0f4b1da1d303c0d578e193">applyFullConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *converter=nullptr)</td></tr>
<tr class="memdesc:aef5c4de80f0f4b1da1d303c0d578e193"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a complete conversion on the given operations, and all nested operations.  <a href="#aef5c4de80f0f4b1da1d303c0d578e193">More...</a><br /></td></tr>
<tr class="separator:aef5c4de80f0f4b1da1d303c0d578e193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe5735cbbe82b381ee6dee730c0135c"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1fe5735cbbe82b381ee6dee730c0135c">applyFullConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *converter=nullptr)</td></tr>
<tr class="separator:a1fe5735cbbe82b381ee6dee730c0135c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab988b7a1c1e3c8a7d795e8dcdeb53f45"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab988b7a1c1e3c8a7d795e8dcdeb53f45">applyAnalysisConversion</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; ops, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;convertedOps, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *converter=nullptr)</td></tr>
<tr class="memdesc:ab988b7a1c1e3c8a7d795e8dcdeb53f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply an analysis conversion on the given operations, and all nested operations.  <a href="#ab988b7a1c1e3c8a7d795e8dcdeb53f45">More...</a><br /></td></tr>
<tr class="separator:ab988b7a1c1e3c8a7d795e8dcdeb53f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fd732394cac1c65af0e08be0d83070"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa7fd732394cac1c65af0e08be0d83070">applyAnalysisConversion</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;target, const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;patterns, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;convertedOps, <a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *converter=nullptr)</td></tr>
<tr class="separator:aa7fd732394cac1c65af0e08be0d83070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0711a5bd6d0958ffd8e120249018415a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a0711a5bd6d0958ffd8e120249018415a">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;mapper, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; resultsToReplace, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=llvm::None, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a0711a5bd6d0958ffd8e120249018415a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a region, 'src', into another.  <a href="#a0711a5bd6d0958ffd8e120249018415a">More...</a><br /></td></tr>
<tr class="separator:a0711a5bd6d0958ffd8e120249018415a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e80dbab8ac36c2184b88ca5a9ebe0ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e80dbab8ac36c2184b88ca5a9ebe0ae">inlineRegion</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *inlinePoint, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; inlinedOperands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; resultsToReplace, <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt; inlineLoc=llvm::None, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:a5e80dbab8ac36c2184b88ca5a9ebe0ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining.  <a href="#a5e80dbab8ac36c2184b88ca5a9ebe0ae">More...</a><br /></td></tr>
<tr class="separator:a5e80dbab8ac36c2184b88ca5a9ebe0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa82b2f82348c0eacc76f1c4a862a796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afa82b2f82348c0eacc76f1c4a862a796">inlineCall</a> (<a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;interface, CallOpInterface call, CallableOpInterface callable, <a class="el" href="classmlir_1_1Region.html">Region</a> *src, bool shouldCloneInlinedRegion=true)</td></tr>
<tr class="memdesc:afa82b2f82348c0eacc76f1c4a862a796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation.  <a href="#afa82b2f82348c0eacc76f1c4a862a796">More...</a><br /></td></tr>
<tr class="separator:afa82b2f82348c0eacc76f1c4a862a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bd2296bf14909ca8aa0730535cdd3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a55bd2296bf14909ca8aa0730535cdd3a">canFuseLoops</a> (AffineForOp srcForOp, AffineForOp dstForOp, unsigned dstLoopDepth, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *srcSlice)</td></tr>
<tr class="memdesc:a55bd2296bf14909ca8aa0730535cdd3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'.  <a href="#a55bd2296bf14909ca8aa0730535cdd3a">More...</a><br /></td></tr>
<tr class="separator:a55bd2296bf14909ca8aa0730535cdd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8c56a4421761c1f8658aa16c292463"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a1b8c56a4421761c1f8658aa16c292463">getLoopNestStats</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> *stats)</td></tr>
<tr class="memdesc:a1b8c56a4421761c1f8658aa16c292463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect loop nest statistics (eg.  <a href="#a1b8c56a4421761c1f8658aa16c292463">More...</a><br /></td></tr>
<tr class="separator:a1b8c56a4421761c1f8658aa16c292463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61eaf936f054b483e983fa6be1cb27f3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a61eaf936f054b483e983fa6be1cb27f3">getComputeCost</a> (AffineForOp forOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;stats)</td></tr>
<tr class="memdesc:a61eaf936f054b483e983fa6be1cb27f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the total cost of the loop nest rooted at 'forOp' using 'stats'.  <a href="#a61eaf936f054b483e983fa6be1cb27f3">More...</a><br /></td></tr>
<tr class="separator:a61eaf936f054b483e983fa6be1cb27f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9370f018bc06e196d615cf7669d727fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9370f018bc06e196d615cf7669d727fe">getFusionComputeCost</a> (AffineForOp srcForOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;srcStats, AffineForOp dstForOp, <a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;dstStats, <a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *slice, int64_t *computeCost)</td></tr>
<tr class="memdesc:a9370f018bc06e196d615cf7669d727fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'.  <a href="#a9370f018bc06e196d615cf7669d727fe">More...</a><br /></td></tr>
<tr class="separator:a9370f018bc06e196d615cf7669d727fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ab9a5f6331a28a90f85a2d8498fd6f801">loopUnrollFull</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation completely if the trip count is known to be constant.  <a href="#ab9a5f6331a28a90f85a2d8498fd6f801">More...</a><br /></td></tr>
<tr class="separator:ab9a5f6331a28a90f85a2d8498fd6f801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f3012781c34e4c455dcb89956d7983"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a69f3012781c34e4c455dcb89956d7983">loopUnrollByFactor</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a69f3012781c34e4c455dcb89956d7983"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this for operation by the specified unroll factor.  <a href="#a69f3012781c34e4c455dcb89956d7983">More...</a><br /></td></tr>
<tr class="separator:a69f3012781c34e4c455dcb89956d7983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4a6ed1cfcc6232ad7dae507d67db6462">loopUnrollUpToFactor</a> (AffineForOp forOp, uint64_t unrollFactor)</td></tr>
<tr class="memdesc:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls this loop by the specified unroll factor or its trip count, whichever is lower.  <a href="#a4a6ed1cfcc6232ad7dae507d67db6462">More...</a><br /></td></tr>
<tr class="separator:a4a6ed1cfcc6232ad7dae507d67db6462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd53e808ea039aa9738dfab187468f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7cd53e808ea039aa9738dfab187468f8">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;nestedLoops, AffineForOp root)</td></tr>
<tr class="memdesc:a7cd53e808ea039aa9738dfab187468f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator).  <a href="#a7cd53e808ea039aa9738dfab187468f8">More...</a><br /></td></tr>
<tr class="separator:a7cd53e808ea039aa9738dfab187468f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb4801ba13af1fb78fe2894414fbb49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8fb4801ba13af1fb78fe2894414fbb49">getPerfectlyNestedLoops</a> (<a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; loop::ForOp &gt; &amp;nestedLoops, loop::ForOp root)</td></tr>
<tr class="separator:a8fb4801ba13af1fb78fe2894414fbb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67a63b71c0fe3f345278eab205e10a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad67a63b71c0fe3f345278eab205e10a3">loopUnrollJamByFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:ad67a63b71c0fe3f345278eab205e10a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor.  <a href="#ad67a63b71c0fe3f345278eab205e10a3">More...</a><br /></td></tr>
<tr class="separator:ad67a63b71c0fe3f345278eab205e10a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac918847951e0d20706fe61380e119adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac918847951e0d20706fe61380e119adb">loopUnrollJamUpToFactor</a> (AffineForOp forOp, uint64_t unrollJamFactor)</td></tr>
<tr class="memdesc:ac918847951e0d20706fe61380e119adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower.  <a href="#ac918847951e0d20706fe61380e119adb">More...</a><br /></td></tr>
<tr class="separator:ac918847951e0d20706fe61380e119adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f574bfd0dab3a0967cf1e3c77780fd4">promoteIfSingleIteration</a> (AffineForOp forOp)</td></tr>
<tr class="memdesc:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes the loop body of a AffineForOp to its containing block if the AffineForOp was known to have a single iteration.  <a href="#a9f574bfd0dab3a0967cf1e3c77780fd4">More...</a><br /></td></tr>
<tr class="separator:a9f574bfd0dab3a0967cf1e3c77780fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b3888bdf62ec2761952b4cd27770ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a30b3888bdf62ec2761952b4cd27770ef">promoteSingleIterationLoops</a> (<a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> f)</td></tr>
<tr class="memdesc:a30b3888bdf62ec2761952b4cd27770ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.  <a href="#a30b3888bdf62ec2761952b4cd27770ef">More...</a><br /></td></tr>
<tr class="separator:a30b3888bdf62ec2761952b4cd27770ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e86ef5d27ed3a0aeb9895984c059de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a99e86ef5d27ed3a0aeb9895984c059de">getCleanupLoopLowerBound</a> (AffineForOp forOp, unsigned unrollFactor, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *map, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *operands, <a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder)</td></tr>
<tr class="memdesc:a99e86ef5d27ed3a0aeb9895984c059de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the cleanup loop lower bound of the loop being unrolled with the specified unroll factor; this bound will also be upper bound of the main part of the unrolled loop.  <a href="#a99e86ef5d27ed3a0aeb9895984c059de">More...</a><br /></td></tr>
<tr class="separator:a99e86ef5d27ed3a0aeb9895984c059de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16773aefb2757e351bd51059c6bcbfe0"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a16773aefb2757e351bd51059c6bcbfe0">instBodySkew</a> (AffineForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; shifts, bool unrollPrologueEpilogue=false)</td></tr>
<tr class="memdesc:a16773aefb2757e351bd51059c6bcbfe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skew the operations in the body of a 'affine.for' operation with the specified operation-wise shifts.  <a href="#a16773aefb2757e351bd51059c6bcbfe0">More...</a><br /></td></tr>
<tr class="separator:a16773aefb2757e351bd51059c6bcbfe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4c74fa5976a79f6dacf4b212513c86"><td class="memItemLeft" align="right" valign="top">LLVM_NODISCARD <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afd4c74fa5976a79f6dacf4b212513c86">tileCodeGen</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt; band, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; tileSizes)</td></tr>
<tr class="memdesc:afd4c74fa5976a79f6dacf4b212513c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops.  <a href="#afd4c74fa5976a79f6dacf4b212513c86">More...</a><br /></td></tr>
<tr class="separator:afd4c74fa5976a79f6dacf4b212513c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff3713bf5c6762b9f8239a980ded85a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9ff3713bf5c6762b9f8239a980ded85a">interchangeLoops</a> (AffineForOp forOpA, AffineForOp forOpB)</td></tr>
<tr class="memdesc:a9ff3713bf5c6762b9f8239a980ded85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs loop interchange on 'forOpA' and 'forOpB'.  <a href="#a9ff3713bf5c6762b9f8239a980ded85a">More...</a><br /></td></tr>
<tr class="separator:a9ff3713bf5c6762b9f8239a980ded85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd689ef70c61ee029b443673c78a04e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aacd689ef70c61ee029b443673c78a04e">isValidLoopInterchangePermutation</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; loopPermMap)</td></tr>
<tr class="memdesc:aacd689ef70c61ee029b443673c78a04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange).  <a href="#aacd689ef70c61ee029b443673c78a04e">More...</a><br /></td></tr>
<tr class="separator:aacd689ef70c61ee029b443673c78a04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dee404eb41233de0e84a82c7082f67"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac8dee404eb41233de0e84a82c7082f67">interchangeLoops</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; loops, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt; loopPermMap)</td></tr>
<tr class="memdesc:ac8dee404eb41233de0e84a82c7082f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a sequence of loop interchanges on perfectly nested 'loops', as specified by permutation 'loopPermMap' (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' after the loop interchange).  <a href="#ac8dee404eb41233de0e84a82c7082f67">More...</a><br /></td></tr>
<tr class="separator:ac8dee404eb41233de0e84a82c7082f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e57efabe41ec9f1d263ed7a42c7f15"><td class="memItemLeft" align="right" valign="top">AffineForOp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad4e57efabe41ec9f1d263ed7a42c7f15">sinkSequentialLoops</a> (AffineForOp forOp)</td></tr>
<tr class="separator:ad4e57efabe41ec9f1d263ed7a42c7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a23242fc1efaad4c85fb8f421d2d72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac2a23242fc1efaad4c85fb8f421d2d72">sinkLoop</a> (AffineForOp forOp, unsigned loopDepth)</td></tr>
<tr class="memdesc:ac2a23242fc1efaad4c85fb8f421d2d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sinks 'forOp' by 'loopDepth' levels by performing a series of loop interchanges.  <a href="#ac2a23242fc1efaad4c85fb8f421d2d72">More...</a><br /></td></tr>
<tr class="separator:ac2a23242fc1efaad4c85fb8f421d2d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623f987acfe618f9aa4823d6c7aec9d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a623f987acfe618f9aa4823d6c7aec9d6">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; targets)</td></tr>
<tr class="separator:a623f987acfe618f9aa4823d6c7aec9d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9494b926a631ef97a52df05ffb305c00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a>, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9494b926a631ef97a52df05ffb305c00">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; loop::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; loop::ForOp &gt; targets)</td></tr>
<tr class="separator:a9494b926a631ef97a52df05ffb305c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8605009295454f6ebebbbaed546f7963"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8605009295454f6ebebbbaed546f7963">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt; sizes, AffineForOp target)</td></tr>
<tr class="memdesc:a8605009295454f6ebebbbaed546f7963"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>.  <a href="#a8605009295454f6ebebbbaed546f7963">More...</a><br /></td></tr>
<tr class="separator:a8605009295454f6ebebbbaed546f7963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc1b7fa275766e04e6ba0ae46fdf181"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4cc1b7fa275766e04e6ba0ae46fdf181">tile</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; loop::ForOp &gt; forOps, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes, loop::ForOp target)</td></tr>
<tr class="separator:a4cc1b7fa275766e04e6ba0ae46fdf181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ea72c4e80474afe62e5e8fcbf4bbc75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a8ea72c4e80474afe62e5e8fcbf4bbc75">tilePerfectlyNested</a> (loop::ForOp rootForOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; sizes)</td></tr>
<tr class="memdesc:a8ea72c4e80474afe62e5e8fcbf4bbc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of loop::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes.  <a href="#a8ea72c4e80474afe62e5e8fcbf4bbc75">More...</a><br /></td></tr>
<tr class="separator:a8ea72c4e80474afe62e5e8fcbf4bbc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7e21be21731f5958cbe1b0dbc79c684"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad7e21be21731f5958cbe1b0dbc79c684">affineDataCopyGenerate</a> (<a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> begin, <a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a> end, const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;copyOptions, <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;copyNests)</td></tr>
<tr class="memdesc:ad7e21be21731f5958cbe1b0dbc79c684"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs explicit copying for the contiguous sequence of operations in the block iterator range [`begin', `end'), where `end' can't be past the terminator of the block (since additional operations are potentially inserted right before <code>end</code>.  <a href="#ad7e21be21731f5958cbe1b0dbc79c684">More...</a><br /></td></tr>
<tr class="separator:ad7e21be21731f5958cbe1b0dbc79c684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8c4b79892c7f2e59f2d7dd8b562b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9e8c4b79892c7f2e59f2d7dd8b562b9a">extractFixedOuterLoops</a> (loop::ForOp rootFOrOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; sizes)</td></tr>
<tr class="memdesc:a9e8c4b79892c7f2e59f2d7dd8b562b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>.  <a href="#a9e8c4b79892c7f2e59f2d7dd8b562b9a">More...</a><br /></td></tr>
<tr class="separator:a9e8c4b79892c7f2e59f2d7dd8b562b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9a2ddfbe72ba156ffb258a781693a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5a9a2ddfbe72ba156ffb258a781693a0">coalesceLoops</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; loop::ForOp &gt; loops)</td></tr>
<tr class="memdesc:a5a9a2ddfbe72ba156ffb258a781693a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a perfect nest of "for" loops with a single linearized loop.  <a href="#a5a9a2ddfbe72ba156ffb258a781693a0">More...</a><br /></td></tr>
<tr class="separator:a5a9a2ddfbe72ba156ffb258a781693a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945dcb325575f8843205517f1647a096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a945dcb325575f8843205517f1647a096">mapLoopToProcessorIds</a> (loop::ForOp forOp, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; processorId, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; numProcessors)</td></tr>
<tr class="memdesc:a945dcb325575f8843205517f1647a096"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps <code>forOp</code> for execution on a parallel grid of virtual <code>processorIds</code> of size given by <code>numProcessors</code>.  <a href="#a945dcb325575f8843205517f1647a096">More...</a><br /></td></tr>
<tr class="separator:a945dcb325575f8843205517f1647a096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0069355214b578476e81bc909f7f13"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aab0069355214b578476e81bc909f7f13">createCanonicalizerPass</a> ()</td></tr>
<tr class="memdesc:aab0069355214b578476e81bc909f7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an instance of the Canonicalizer pass.  <a href="#aab0069355214b578476e81bc909f7f13">More...</a><br /></td></tr>
<tr class="separator:aab0069355214b578476e81bc909f7f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14895da9723acd9c7f910c2694ff9f65"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a14895da9723acd9c7f910c2694ff9f65">createCSEPass</a> ()</td></tr>
<tr class="memdesc:a14895da9723acd9c7f910c2694ff9f65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform common sub expression elimination.  <a href="#a14895da9723acd9c7f910c2694ff9f65">More...</a><br /></td></tr>
<tr class="separator:a14895da9723acd9c7f910c2694ff9f65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68232bc7e405404d5af982388420703"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac68232bc7e405404d5af982388420703">createVectorizePass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; virtualVectorSize)</td></tr>
<tr class="memdesc:ac68232bc7e405404d5af982388420703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to vectorize loops, operations and data types using a target-independent, n-D super-vector abstraction.  <a href="#ac68232bc7e405404d5af982388420703">More...</a><br /></td></tr>
<tr class="separator:ac68232bc7e405404d5af982388420703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a642298e3d87f1699172c886060e7f2f1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a642298e3d87f1699172c886060e7f2f1">createVectorizerTestPass</a> ()</td></tr>
<tr class="memdesc:a642298e3d87f1699172c886060e7f2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to allow independent testing of vectorizer functionality with FileCheck.  <a href="#a642298e3d87f1699172c886060e7f2f1">More...</a><br /></td></tr>
<tr class="separator:a642298e3d87f1699172c886060e7f2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539dbb1cb2575bb342b0bb6d8e0637dc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a539dbb1cb2575bb342b0bb6d8e0637dc">createMaterializeVectorsPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; vectorSize)</td></tr>
<tr class="memdesc:a539dbb1cb2575bb342b0bb6d8e0637dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to lower super-vectors to target-dependent HW vectors.  <a href="#a539dbb1cb2575bb342b0bb6d8e0637dc">More...</a><br /></td></tr>
<tr class="separator:a539dbb1cb2575bb342b0bb6d8e0637dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff9a255aa02976b7a6c87ef31bb8bb1"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6ff9a255aa02976b7a6c87ef31bb8bb1">createLoopUnrollPass</a> (int unrollFactor=-1, int unrollFull=-1, const std::function&lt; unsigned(AffineForOp)&gt; &amp;getUnrollFactor=nullptr)</td></tr>
<tr class="memdesc:a6ff9a255aa02976b7a6c87ef31bb8bb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unrolling pass with the provided parameters.  <a href="#a6ff9a255aa02976b7a6c87ef31bb8bb1">More...</a><br /></td></tr>
<tr class="separator:a6ff9a255aa02976b7a6c87ef31bb8bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dcc0952274a0c08c8d6ea76641b2cd2"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4dcc0952274a0c08c8d6ea76641b2cd2">createLoopUnrollAndJamPass</a> (int unrollJamFactor=-1)</td></tr>
<tr class="memdesc:a4dcc0952274a0c08c8d6ea76641b2cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop unroll jam pass to unroll jam by the specified factor.  <a href="#a4dcc0952274a0c08c8d6ea76641b2cd2">More...</a><br /></td></tr>
<tr class="separator:a4dcc0952274a0c08c8d6ea76641b2cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4583061063ad5f5c6a88c2d8e3f0ca73"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4583061063ad5f5c6a88c2d8e3f0ca73">createSimplifyAffineStructuresPass</a> ()</td></tr>
<tr class="memdesc:a4583061063ad5f5c6a88c2d8e3f0ca73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a simplification pass for affine structures (maps and sets).  <a href="#a4583061063ad5f5c6a88c2d8e3f0ca73">More...</a><br /></td></tr>
<tr class="separator:a4583061063ad5f5c6a88c2d8e3f0ca73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb36b083f70902a9546407beee0fa50"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5bb36b083f70902a9546407beee0fa50">createLoopFusionPass</a> (unsigned fastMemorySpace=0, uint64_t localBufSizeThreshold=0, bool maximalFusion=false)</td></tr>
<tr class="memdesc:a5bb36b083f70902a9546407beee0fa50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop fusion pass which fuses loops.  <a href="#a5bb36b083f70902a9546407beee0fa50">More...</a><br /></td></tr>
<tr class="separator:a5bb36b083f70902a9546407beee0fa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319fde65e573dbc3a947d58196cb2b3a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a319fde65e573dbc3a947d58196cb2b3a">createLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:a319fde65e573dbc3a947d58196cb2b3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop.  <a href="#a319fde65e573dbc3a947d58196cb2b3a">More...</a><br /></td></tr>
<tr class="separator:a319fde65e573dbc3a947d58196cb2b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb99f776bb27d84686308adc69cff56"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abfb99f776bb27d84686308adc69cff56">createAffineLoopInvariantCodeMotionPass</a> ()</td></tr>
<tr class="memdesc:abfb99f776bb27d84686308adc69cff56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a loop invariant code motion pass that hoists loop invariant instructions out of affine loop.  <a href="#abfb99f776bb27d84686308adc69cff56">More...</a><br /></td></tr>
<tr class="separator:abfb99f776bb27d84686308adc69cff56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c956d85f15888a0d54ab0242a225db"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a06c956d85f15888a0d54ab0242a225db">createPipelineDataTransferPass</a> ()</td></tr>
<tr class="memdesc:a06c956d85f15888a0d54ab0242a225db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy.  <a href="#a06c956d85f15888a0d54ab0242a225db">More...</a><br /></td></tr>
<tr class="separator:a06c956d85f15888a0d54ab0242a225db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a200b8cbaeac5d7e3924c9cdd2003b9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6a200b8cbaeac5d7e3924c9cdd2003b9">createLowerAffinePass</a> ()</td></tr>
<tr class="memdesc:a6a200b8cbaeac5d7e3924c9cdd2003b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lowers affine control flow operations (ForStmt, IfStmt and <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives).  <a href="#a6a200b8cbaeac5d7e3924c9cdd2003b9">More...</a><br /></td></tr>
<tr class="separator:a6a200b8cbaeac5d7e3924c9cdd2003b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2249f16df21768223748892a65b003"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a5e2249f16df21768223748892a65b003">createLoopTilingPass</a> (uint64_t cacheSizeBytes)</td></tr>
<tr class="memdesc:a5e2249f16df21768223748892a65b003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform tiling on loop nests.  <a href="#a5e2249f16df21768223748892a65b003">More...</a><br /></td></tr>
<tr class="separator:a5e2249f16df21768223748892a65b003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a358dc09e947c8db396c37ad2fd2f5091"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a358dc09e947c8db396c37ad2fd2f5091">createSimpleParametricTilingPass</a> (<a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt; outerLoopSizes)</td></tr>
<tr class="memdesc:a358dc09e947c8db396c37ad2fd2f5091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that performs parametric tiling so that the outermost loops have the given fixed number of iterations.  <a href="#a358dc09e947c8db396c37ad2fd2f5091">More...</a><br /></td></tr>
<tr class="separator:a358dc09e947c8db396c37ad2fd2f5091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ea711e3f9b9ce6bda6e8bd2258990a"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae3ea711e3f9b9ce6bda6e8bd2258990a">createLoopCoalescingPass</a> ()</td></tr>
<tr class="memdesc:ae3ea711e3f9b9ce6bda6e8bd2258990a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass that transforms perfectly nested loops with independent bounds into a single loop.  <a href="#ae3ea711e3f9b9ce6bda6e8bd2258990a">More...</a><br /></td></tr>
<tr class="separator:ae3ea711e3f9b9ce6bda6e8bd2258990a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cb9c0e49f5bb8619655882e718b399"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98cb9c0e49f5bb8619655882e718b399">createAffineDataCopyGenerationPass</a> (unsigned slowMemorySpace, unsigned fastMemorySpace, unsigned tagMemorySpace=0, int minDmaTransferSize=1024, uint64_t fastMemCapacityBytes=std::numeric_limits&lt; uint64_t &gt;::max())</td></tr>
<tr class="memdesc:a98cb9c0e49f5bb8619655882e718b399"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations.  <a href="#a98cb9c0e49f5bb8619655882e718b399">More...</a><br /></td></tr>
<tr class="separator:a98cb9c0e49f5bb8619655882e718b399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac178054e409e714ae2909b390da1791c"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac178054e409e714ae2909b390da1791c">createMemRefDataFlowOptPass</a> ()</td></tr>
<tr class="memdesc:ac178054e409e714ae2909b390da1791c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to perform optimizations relying on memref dataflow such as store to load forwarding, elimination of dead stores, and dead allocs.  <a href="#ac178054e409e714ae2909b390da1791c">More...</a><br /></td></tr>
<tr class="separator:ac178054e409e714ae2909b390da1791c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad742e91af4a7dfad42c161671f99455d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ad742e91af4a7dfad42c161671f99455d">createStripDebugInfoPass</a> ()</td></tr>
<tr class="memdesc:ad742e91af4a7dfad42c161671f99455d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to strip debug information from a function.  <a href="#ad742e91af4a7dfad42c161671f99455d">More...</a><br /></td></tr>
<tr class="separator:ad742e91af4a7dfad42c161671f99455d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf83469154149385949bf86f4c3bbde"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afaf83469154149385949bf86f4c3bbde">createTestLoopFusionPass</a> ()</td></tr>
<tr class="memdesc:afaf83469154149385949bf86f4c3bbde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which tests loop fusion utilities.  <a href="#afaf83469154149385949bf86f4c3bbde">More...</a><br /></td></tr>
<tr class="separator:afaf83469154149385949bf86f4c3bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6c6ad0644a283c257d1fbc15be6adc18">createInlinerPass</a> ()</td></tr>
<tr class="memdesc:a6c6ad0644a283c257d1fbc15be6adc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>.  <a href="#a6c6ad0644a283c257d1fbc15be6adc18">More...</a><br /></td></tr>
<tr class="separator:a6c6ad0644a283c257d1fbc15be6adc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ac680df79552c596c048cd9cb27638c5f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ac680df79552c596c048cd9cb27638c5f">areValuesDefinedAbove</a> (Range values, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit)</td></tr>
<tr class="memdesc:ac680df79552c596c048cd9cb27638c5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if all values in the provided range are defined above the <code>limit</code> region.  <a href="#ac680df79552c596c048cd9cb27638c5f">More...</a><br /></td></tr>
<tr class="separator:ac680df79552c596c048cd9cb27638c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a5d204dd78ac563241168e6b2e40eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a15a5d204dd78ac563241168e6b2e40eb">replaceAllUsesInRegionWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> orig, <a class="el" href="classmlir_1_1Value.html">Value</a> replacement, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region)</td></tr>
<tr class="memdesc:a15a5d204dd78ac563241168e6b2e40eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all uses of <code>orig</code> within the given region with <code>replacement</code>.  <a href="#a15a5d204dd78ac563241168e6b2e40eb">More...</a><br /></td></tr>
<tr class="separator:a15a5d204dd78ac563241168e6b2e40eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae644ec0854505ef60f12c23b96de595b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae644ec0854505ef60f12c23b96de595b">visitUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:ae644ec0854505ef60f12c23b96de595b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>.  <a href="#ae644ec0854505ef60f12c23b96de595b">More...</a><br /></td></tr>
<tr class="separator:ae644ec0854505ef60f12c23b96de595b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a036e7ce3c7c3bf73fc0a653cd98bb7c0">visitUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt; callback)</td></tr>
<tr class="memdesc:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors.  <a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">More...</a><br /></td></tr>
<tr class="separator:a036e7ce3c7c3bf73fc0a653cd98bb7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f633b099c2b8b42235818ba7bb70bc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a9f633b099c2b8b42235818ba7bb70bc0">getUsedValuesDefinedAbove</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;limit, llvm::SetVector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a9f633b099c2b8b42235818ba7bb70bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants.  <a href="#a9f633b099c2b8b42235818ba7bb70bc0">More...</a><br /></td></tr>
<tr class="separator:a9f633b099c2b8b42235818ba7bb70bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdabf77e050b8d684e39d2e5c760a2f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#afdabf77e050b8d684e39d2e5c760a2f0">getUsedValuesDefinedAbove</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions, llvm::SetVector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:afdabf77e050b8d684e39d2e5c760a2f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors.  <a href="#afdabf77e050b8d684e39d2e5c760a2f0">More...</a><br /></td></tr>
<tr class="separator:afdabf77e050b8d684e39d2e5c760a2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303077ea0260053bc46cb584abb7767f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a303077ea0260053bc46cb584abb7767f">simplifyRegions</a> (<a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt; regions)</td></tr>
<tr class="memdesc:a303077ea0260053bc46cb584abb7767f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run a set of structural simplifications over the given regions.  <a href="#a303077ea0260053bc46cb584abb7767f">More...</a><br /></td></tr>
<tr class="separator:a303077ea0260053bc46cb584abb7767f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a383f580b17a936443f42d199484926da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a383f580b17a936443f42d199484926da">replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={}, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *domInstFilter=nullptr, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *postDomInstFilter=nullptr)</td></tr>
<tr class="memdesc:a383f580b17a936443f42d199484926da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>.  <a href="#a383f580b17a936443f42d199484926da">More...</a><br /></td></tr>
<tr class="separator:a383f580b17a936443f42d199484926da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaafdc3b50b593f1156dfd34bfac0833"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeaafdc3b50b593f1156dfd34bfac0833">replaceAllMemRefUsesWith</a> (<a class="el" href="classmlir_1_1Value.html">Value</a> oldMemRef, <a class="el" href="classmlir_1_1Value.html">Value</a> newMemRef, <a class="el" href="classmlir_1_1Operation.html">Operation</a> *op, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraIndices={}, <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> indexRemap=<a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>(), <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; extraOperands={}, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; symbolOperands={})</td></tr>
<tr class="memdesc:aeaafdc3b50b593f1156dfd34bfac0833"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>.  <a href="#aeaafdc3b50b593f1156dfd34bfac0833">More...</a><br /></td></tr>
<tr class="separator:aeaafdc3b50b593f1156dfd34bfac0833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f3ffb3d4089a4a62f1b01ef2cc80df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#ae4f3ffb3d4089a4a62f1b01ef2cc80df">normalizeMemRef</a> (AllocOp op)</td></tr>
<tr class="memdesc:ae4f3ffb3d4089a4a62f1b01ef2cc80df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rewrites the memref defined by this alloc op to have an identity layout map and updates all its indexing uses.  <a href="#ae4f3ffb3d4089a4a62f1b01ef2cc80df">More...</a><br /></td></tr>
<tr class="separator:ae4f3ffb3d4089a4a62f1b01ef2cc80df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e839c359226fcf9fc26cb51ba6c3282"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a4e839c359226fcf9fc26cb51ba6c3282">createComposedAffineApplyOp</a> (<a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;builder, <a class="el" href="classmlir_1_1Location.html">Location</a> loc, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; operands, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; affineApplyOps, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *results)</td></tr>
<tr class="memdesc:a4e839c359226fcf9fc26cb51ba6c3282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and inserts into 'builder' a new <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>, with the number of its results equal to the number of operands, as a composition of all other AffineApplyOps reachable from input parameter 'operands'.  <a href="#a4e839c359226fcf9fc26cb51ba6c3282">More...</a><br /></td></tr>
<tr class="separator:a4e839c359226fcf9fc26cb51ba6c3282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf452ef02d7d46f5c0f409ebb373b92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aebf452ef02d7d46f5c0f409ebb373b92">createAffineComputationSlice</a> (<a class="el" href="classmlir_1_1Operation.html">Operation</a> *opInst, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineApplyOp.html">AffineApplyOp</a> &gt; *sliceOps)</td></tr>
<tr class="memdesc:aebf452ef02d7d46f5c0f409ebb373b92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation.  <a href="#aebf452ef02d7d46f5c0f409ebb373b92">More...</a><br /></td></tr>
<tr class="separator:aebf452ef02d7d46f5c0f409ebb373b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6bf62f92ba677b78bd16aa0f34fd07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a6b6bf62f92ba677b78bd16aa0f34fd07">viewGraph</a> (<a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block, const Twine &amp;name, bool shortNames=false, const Twine &amp;title=&quot;&quot;, llvm::GraphProgram::Name program=llvm::GraphProgram::DOT)</td></tr>
<tr class="memdesc:a6b6bf62f92ba677b78bd16aa0f34fd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the graph in a window.  <a href="#a6b6bf62f92ba677b78bd16aa0f34fd07">More...</a><br /></td></tr>
<tr class="separator:a6b6bf62f92ba677b78bd16aa0f34fd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9dab397b212cccb9be9497581485293"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aa9dab397b212cccb9be9497581485293">writeGraph</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Block.html">Block</a> &amp;block, bool shortNames=false, const Twine &amp;title=&quot;&quot;)</td></tr>
<tr class="separator:aa9dab397b212cccb9be9497581485293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95636a6bbea919685fd7df7ad79eb871"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a95636a6bbea919685fd7df7ad79eb871">createPrintOpGraphPass</a> (raw_ostream &amp;os=llvm::errs(), bool shortNames=false, const Twine &amp;title=&quot;&quot;)</td></tr>
<tr class="memdesc:a95636a6bbea919685fd7df7ad79eb871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print op graphs.  <a href="#a95636a6bbea919685fd7df7ad79eb871">More...</a><br /></td></tr>
<tr class="separator:a95636a6bbea919685fd7df7ad79eb871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeb01423a036ce7642b34f08a4d39e8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#aeeb01423a036ce7642b34f08a4d39e8b">viewGraph</a> (<a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, const Twine &amp;name, bool shortNames=false, const Twine &amp;title=&quot;&quot;, llvm::GraphProgram::Name program=llvm::GraphProgram::DOT)</td></tr>
<tr class="memdesc:aeeb01423a036ce7642b34f08a4d39e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Displays the CFG in a window.  <a href="#aeeb01423a036ce7642b34f08a4d39e8b">More...</a><br /></td></tr>
<tr class="separator:aeeb01423a036ce7642b34f08a4d39e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3637269c766005364583ba36db13bacd"><td class="memItemLeft" align="right" valign="top">raw_ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a3637269c766005364583ba36db13bacd">writeGraph</a> (raw_ostream &amp;os, <a class="el" href="classmlir_1_1Region.html">Region</a> &amp;region, bool shortNames=false, const Twine &amp;title=&quot;&quot;)</td></tr>
<tr class="separator:a3637269c766005364583ba36db13bacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db213aeba7a0131ac371f600c7eafb4"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">mlir::OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">mlir::FuncOp</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a7db213aeba7a0131ac371f600c7eafb4">createPrintCFGGraphPass</a> (raw_ostream &amp;os=llvm::errs(), bool shortNames=false, const Twine &amp;title=&quot;&quot;)</td></tr>
<tr class="memdesc:a7db213aeba7a0131ac371f600c7eafb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a pass to print CFG graphs.  <a href="#a7db213aeba7a0131ac371f600c7eafb4">More...</a><br /></td></tr>
<tr class="separator:a7db213aeba7a0131ac371f600c7eafb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631cb71a57000b8e9448317986781aa4"><td class="memItemLeft" align="right" valign="top">const llvm::StringMap&lt; <a class="el" href="namespacemlir.html#a16773901a5b8781f9be66507fad3c5b4">TranslateSourceMgrToMLIRFunction</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a631cb71a57000b8e9448317986781aa4">getTranslationToMLIRRegistry</a> ()</td></tr>
<tr class="memdesc:a631cb71a57000b8e9448317986781aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a read-only reference to the translator registry.  <a href="#a631cb71a57000b8e9448317986781aa4">More...</a><br /></td></tr>
<tr class="separator:a631cb71a57000b8e9448317986781aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9b11fe741d1b8ed149d9b7c88ee1a2"><td class="memItemLeft" align="right" valign="top">const llvm::StringMap&lt; <a class="el" href="namespacemlir.html#a13b54e61e2491e2bc91c54f8ef429cfa">TranslateFromMLIRFunction</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#abb9b11fe741d1b8ed149d9b7c88ee1a2">getTranslationFromMLIRRegistry</a> ()</td></tr>
<tr class="separator:abb9b11fe741d1b8ed149d9b7c88ee1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cc980616f787ceaef19159104ac419"><td class="memItemLeft" align="right" valign="top">const llvm::StringMap&lt; <a class="el" href="namespacemlir.html#addbb54b5d484b1a53b08f04871fb0da8">TranslateFunction</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a98cc980616f787ceaef19159104ac419">getTranslationRegistry</a> ()</td></tr>
<tr class="separator:a98cc980616f787ceaef19159104ac419"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a159f88d87b78c353731e1661c65a0b98"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a159f88d87b78c353731e1661c65a0b98">makeOptimizingTransformer</a> (unsigned optLevel, unsigned sizeLevel, llvm::TargetMachine *targetMachine)</td></tr>
<tr class="memdesc:a159f88d87b78c353731e1661c65a0b98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g.  <a href="#a159f88d87b78c353731e1661c65a0b98">More...</a><br /></td></tr>
<tr class="separator:a159f88d87b78c353731e1661c65a0b98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aeb0828d77d6958e5bc1fabe03734b5"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemlir.html#a2aeb0828d77d6958e5bc1fabe03734b5">makeLLVMPassesTransformer</a> (<a class="el" href="classllvm_1_1ArrayRef.html">llvm::ArrayRef</a>&lt; const llvm::PassInfo *&gt; <a class="el" href="JitRunner_8cpp.html#ab0531989ee328b93b3d8c769beae9054">llvmPasses</a>, <a class="el" href="classllvm_1_1Optional.html">llvm::Optional</a>&lt; unsigned &gt; mbOptLevel, llvm::TargetMachine *targetMachine, unsigned optPassesInsertPos=0)</td></tr>
<tr class="memdesc:a2aeb0828d77d6958e5bc1fabe03734b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes explicitly specified, plus an optional optimization level, Any optimization passes, if present, will be inserted before the pass at position optPassesInsertPos.  <a href="#a2aeb0828d77d6958e5bc1fabe03734b5">More...</a><br /></td></tr>
<tr class="separator:a2aeb0828d77d6958e5bc1fabe03734b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file provides some simple template functional-style sugar to operate on <b>value</b> types. </p>
<p>Make sure when using that the stored type is cheap to copy!</p>
<p>TODO(ntv): add some static_assert but we need proper traits for this. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aaa9cda38190c43a3ddb40fb8ca0112b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa9cda38190c43a3ddb40fb8ca0112b6">&#9670;&nbsp;</a></span>AnalysisID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structmlir_1_1ClassID.html">ClassID</a> <a class="el" href="namespacemlir.html#aaa9cda38190c43a3ddb40fb8ca0112b6">mlir::AnalysisID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A special type used by analyses to provide an address that identifies a particular analysis set or a concrete analysis type. </p>

<p class="definition">Definition at line <a class="el" href="AnalysisManager_8h_source.html#l00022">22</a> of file <a class="el" href="AnalysisManager_8h_source.html">AnalysisManager.h</a>.</p>

</div>
</div>
<a id="aad8f5011648c4f698028afb8a96b31ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8f5011648c4f698028afb8a96b31ce">&#9670;&nbsp;</a></span>AttributeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aad8f5011648c4f698028afb8a96b31ce">mlir::AttributeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00081">81</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="aafb0c2458571cd80ebb876d979e24346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafb0c2458571cd80ebb876d979e24346">&#9670;&nbsp;</a></span>ChunkBufferHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">mlir::ChunkBufferHandler</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( std::unique_ptr&lt;llvm::MemoryBuffer&gt; chunkBuffer, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8h_source.html#l00028">28</a> of file <a class="el" href="ToolUtilities_8h_source.html">ToolUtilities.h</a>.</p>

</div>
</div>
<a id="ac778e98bba4a5f7b76ead3e1d37c6892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac778e98bba4a5f7b76ead3e1d37c6892">&#9670;&nbsp;</a></span>CubinGenerator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ac778e98bba4a5f7b76ead3e1d37c6892">mlir::CubinGenerator</a> = typedef std::function&lt;<a class="el" href="namespacemlir.html#a49966a7e55b91f74977c5e65a1ce9b48">OwnedCubin</a>(const std::string &amp;, <a class="el" href="classmlir_1_1Location.html">Location</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUToCUDAPass_8h_source.html#l00034">34</a> of file <a class="el" href="GPUToCUDAPass_8h_source.html">GPUToCUDAPass.h</a>.</p>

</div>
</div>
<a id="a759bdae349015b16ce375bdd46c1e16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759bdae349015b16ce375bdd46c1e16c">&#9670;&nbsp;</a></span>DefaultAttributeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a759bdae349015b16ce375bdd46c1e16c">mlir::DefaultAttributeStorage</a> = typedef <a class="el" href="classmlir_1_1AttributeStorage.html">AttributeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for attributes that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="AttributeSupport_8h_source.html#l00073">73</a> of file <a class="el" href="AttributeSupport_8h_source.html">AttributeSupport.h</a>.</p>

</div>
</div>
<a id="a8b36f0e85767ed4e793d86f40bd8fe55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b36f0e85767ed4e793d86f40bd8fe55">&#9670;&nbsp;</a></span>DefaultTypeStorage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a8b36f0e85767ed4e793d86f40bd8fe55">mlir::DefaultTypeStorage</a> = typedef <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default storage type for types that require no additional initialization or storage. </p>

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00070">70</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="ad7f731697783a754f6f0e3821d1264b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f731697783a754f6f0e3821d1264b2">&#9670;&nbsp;</a></span>DenseMap</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT , typename KeyInfoT  = DenseMapInfo&lt;KeyT&gt;, typename BucketT  = llvm::detail::DenseMapPair&lt;KeyT, ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ad7f731697783a754f6f0e3821d1264b2">mlir::DenseMap</a> = typedef <a class="el" href="classllvm_1_1DenseMap.html">llvm::DenseMap</a>&lt;KeyT, ValueT, KeyInfoT, BucketT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00073">73</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a59d6aae8a616cd9d13c8b1edb1095948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d6aae8a616cd9d13c8b1edb1095948">&#9670;&nbsp;</a></span>DenseSet</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ValueT , typename ValueInfoT  = DenseMapInfo&lt;ValueT&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">mlir::DenseSet</a> = typedef <a class="el" href="classllvm_1_1DenseSet.html">llvm::DenseSet</a>&lt;ValueT, ValueInfoT&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00075">75</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a94ae7dda0e636afc0a58acb0ed3342b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ae7dda0e636afc0a58acb0ed3342b4">&#9670;&nbsp;</a></span>DialectAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a94ae7dda0e636afc0a58acb0ed3342b4">mlir::DialectAllocatorFunction</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8h_source.html#l00284">284</a> of file <a class="el" href="IR_2Dialect_8h_source.html">Dialect.h</a>.</p>

</div>
</div>
<a id="a9632a07fcad8faa7c654d03748218864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9632a07fcad8faa7c654d03748218864">&#9670;&nbsp;</a></span>DialectConstantDecodeHook</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9632a07fcad8faa7c654d03748218864">mlir::DialectConstantDecodeHook</a> = typedef std::function&lt;bool(const <a class="el" href="classmlir_1_1OpaqueElementsAttr.html">OpaqueElementsAttr</a>, <a class="el" href="classmlir_1_1ElementsAttr.html">ElementsAttr</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8h_source.html#l00026">26</a> of file <a class="el" href="IR_2Dialect_8h_source.html">Dialect.h</a>.</p>

</div>
</div>
<a id="abb3c2070dfa94ad02acc17bed0273d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3c2070dfa94ad02acc17bed0273d64">&#9670;&nbsp;</a></span>DialectConstantFoldHook</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#abb3c2070dfa94ad02acc17bed0273d64">mlir::DialectConstantFoldHook</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( <a class="el" href="classmlir_1_1Operation.html">Operation</a> *, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt;, <a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt; &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8h_source.html#l00028">28</a> of file <a class="el" href="IR_2Dialect_8h_source.html">Dialect.h</a>.</p>

</div>
</div>
<a id="a6c219ce87441d381c0ec080f4ba5b439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c219ce87441d381c0ec080f4ba5b439">&#9670;&nbsp;</a></span>DialectExtractElementHook</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a6c219ce87441d381c0ec080f4ba5b439">mlir::DialectExtractElementHook</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>(const <a class="el" href="classmlir_1_1OpaqueElementsAttr.html">OpaqueElementsAttr</a>, <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;uint64_t&gt;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8h_source.html#l00030">30</a> of file <a class="el" href="IR_2Dialect_8h_source.html">Dialect.h</a>.</p>

</div>
</div>
<a id="a485453da011e03403b043a915fd368ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485453da011e03403b043a915fd368ab">&#9670;&nbsp;</a></span>DialectHooksSetter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a485453da011e03403b043a915fd368ab">mlir::DialectHooksSetter</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectHooks_8h_source.html#l00020">20</a> of file <a class="el" href="DialectHooks_8h_source.html">DialectHooks.h</a>.</p>

</div>
</div>
<a id="aedbc3d0362a57c5175f05dd95fb59641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbc3d0362a57c5175f05dd95fb59641">&#9670;&nbsp;</a></span>DominanceInfoNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aedbc3d0362a57c5175f05dd95fb59641">mlir::DominanceInfoNode</a> = typedef llvm::DomTreeNodeBase&lt;<a class="el" href="classmlir_1_1Block.html">Block</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Dominance_8h_source.html#l00019">19</a> of file <a class="el" href="Dominance_8h_source.html">Dominance.h</a>.</p>

</div>
</div>
<a id="a899fdaa9e41cd3d5abb2b4cc44dba232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899fdaa9e41cd3d5abb2b4cc44dba232">&#9670;&nbsp;</a></span>FilterFunctionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a899fdaa9e41cd3d5abb2b4cc44dba232">mlir::FilterFunctionType</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A <a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> is a nested operation walker that: </p>
<ol type="1">
<li>recursively matches a substructure in the tree;</li>
<li>uses a filter function to refine matches with extra semantic constraints (passed via a lambda of type FilterFunctionType);</li>
<li>TODO(ntv) optionally applies actions (lambda).</li>
</ol>
<p>Nested patterns are meant to capture imperfectly nested loops while matching properties over the whole loop nest. For instance, in vectorization we are interested in capturing all the imperfectly nested loops of a certain type and such that all the load and stores have certain access patterns along the loops' induction variables). Such NestedMatches are first captured using the <code>match</code> function and are later processed to analyze properties and apply transformations in a non-greedy way.</p>
<p>The NestedMatches captured in the IR can grow large, especially after aggressive unrolling. As experience has shown, it is generally better to use a plain walk over operations to match flat patterns but the current implementation is competitive nonetheless. </p>

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00090">90</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="a0bff6226b7c81b6134b8c1130403a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bff6226b7c81b6134b8c1130403a172">&#9670;&nbsp;</a></span>function_ref</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Fn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">mlir::function_ref</a> = typedef <a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt;Fn&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LLVM_8h_source.html#l00076">76</a> of file <a class="el" href="LLVM_8h_source.html">LLVM.h</a>.</p>

</div>
</div>
<a id="a4ddb6704fdaa06a1d6d81b12d73eac94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ddb6704fdaa06a1d6d81b12d73eac94">&#9670;&nbsp;</a></span>GenFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a4ddb6704fdaa06a1d6d81b12d73eac94">mlir::GenFunction</a> = typedef std::function&lt;bool(const llvm::RecordKeeper &amp;recordKeeper, raw_ostream &amp;os)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generator function to invoke. </p>

<p class="definition">Definition at line <a class="el" href="GenInfo_8h_source.html#l00024">24</a> of file <a class="el" href="GenInfo_8h_source.html">GenInfo.h</a>.</p>

</div>
</div>
<a id="a084549cd18226f1b294a368dfcd7cdce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084549cd18226f1b294a368dfcd7cdce">&#9670;&nbsp;</a></span>is_detected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class... &gt; class Op, class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a084549cd18226f1b294a368dfcd7cdce">mlir::is_detected</a> = typedef typename <a class="el" href="structmlir_1_1detail_1_1detector.html">detail::detector</a>&lt;void, <a class="el" href="classmlir_1_1Op.html">Op</a>, Args...&gt;::value_t</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00125">125</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

</div>
</div>
<a id="a5485eeb23e06cd22ad2ac521edffa100"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5485eeb23e06cd22ad2ac521edffa100">&#9670;&nbsp;</a></span>is_invocable</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Callable , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a5485eeb23e06cd22ad2ac521edffa100">mlir::is_invocable</a> = typedef <a class="el" href="namespacemlir.html#a084549cd18226f1b294a368dfcd7cdce">is_detected</a>&lt;<a class="el" href="namespacemlir_1_1detail.html#a3db85740fd43b571f247cd8ae5d627f5">detail::is_invocable</a>, Callable, Args...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00135">135</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

</div>
</div>
<a id="a021ec11591c1abe2294a6c0a9e5caa29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a021ec11591c1abe2294a6c0a9e5caa29">&#9670;&nbsp;</a></span>LLVMPatternListFiller</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a021ec11591c1abe2294a6c0a9e5caa29">mlir::LLVMPatternListFiller</a> = typedef std::function&lt;void(<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;, <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> for a callback constructing the owning list of patterns for the conversion to the LLVMIR dialect. </p>
<p>The callback is expected to append patterns to the owning list provided as the second argument. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00038">38</a> of file <a class="el" href="ConvertStandardToLLVMPass_8h_source.html">ConvertStandardToLLVMPass.h</a>.</p>

</div>
</div>
<a id="ab4a624defb326870761dd5923452a374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a624defb326870761dd5923452a374">&#9670;&nbsp;</a></span>LLVMTypeConverterMaker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab4a624defb326870761dd5923452a374">mlir::LLVMTypeConverterMaker</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a>&gt;(<a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> for a callback constructing the type converter for the conversion to the LLVMIR dialect. </p>
<p>The callback is expected to return an instance of the converter. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00044">44</a> of file <a class="el" href="ConvertStandardToLLVMPass_8h_source.html">ConvertStandardToLLVMPass.h</a>.</p>

</div>
</div>
<a id="abb10c37aa0b69dce04cbdf7a84e64228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb10c37aa0b69dce04cbdf7a84e64228">&#9670;&nbsp;</a></span>Loops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">mlir::Loops</a> = typedef <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt;loop::ForOp, 8&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling fo imperfectly nested loops (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under each of the <code>targets</code>. </p>
<p>Returns the new AffineForOps, one per each of (<code>forOps</code>, <code>targets</code>) pair, nested immediately under each of <code>targets</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8h_source.html#l00127">127</a> of file <a class="el" href="LoopUtils_8h_source.html">LoopUtils.h</a>.</p>

</div>
</div>
<a id="a2bd440a077557b4421b2cfd06d48956a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd440a077557b4421b2cfd06d48956a">&#9670;&nbsp;</a></span>NamedAttribute</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a2bd440a077557b4421b2cfd06d48956a">mlir::NamedAttribute</a> = typedef std::pair&lt;<a class="el" href="classmlir_1_1Identifier.html">Identifier</a>, <a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NamedAttribute is used for dictionary attributes, it holds an identifier for the name and a value for the attribute. </p>
<p>The attribute pointer should always be non-null. </p>

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00265">265</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

</div>
</div>
<a id="ab0887111bf825d1f766ef9e0911394d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0887111bf825d1f766ef9e0911394d5">&#9670;&nbsp;</a></span>OpAsmSetValueNameFn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#ab0887111bf825d1f766ef9e0911394d5">mlir::OpAsmSetValueNameFn</a> = typedef <a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt;void(<a class="el" href="classmlir_1_1Value.html">Value</a>, StringRef)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A functor used to set the name of the start of a result group of an operation. </p>
<p>See 'getAsmResultNames' below for more details. </p>

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00629">629</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="addfe54a0bc784b7267e1455fa16ea891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfe54a0bc784b7267e1455fa16ea891">&#9670;&nbsp;</a></span>OperandAdaptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#addfe54a0bc784b7267e1455fa16ea891">mlir::OperandAdaptor</a> = typedef typename OpTy::OperandAdaptor</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an adaptor from a list of values to named operands of OpTy. </p>
<p>In a generic operation context, e.g., in dialect conversions, an ordered array of <code><a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a></code>s is treated as operands of <code>OpTy</code>. This adaptor takes a reference to the array and provides accessors with the same names as <code>OpTy</code> for operands. This makes possible to create function templates that operate on either OpTy or OperandAdaptor&lt;OpTy&gt; seamlessly. </p>

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00050">50</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

</div>
</div>
<a id="a3789e28c54bcaf5d2c3baf5f99eb615f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3789e28c54bcaf5d2c3baf5f99eb615f">&#9670;&nbsp;</a></span>OperandElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3789e28c54bcaf5d2c3baf5f99eb615f">mlir::OperandElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1OperandElementTypeIterator.html">OperandElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00077">77</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="a49966a7e55b91f74977c5e65a1ce9b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49966a7e55b91f74977c5e65a1ce9b48">&#9670;&nbsp;</a></span>OwnedCubin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a49966a7e55b91f74977c5e65a1ce9b48">mlir::OwnedCubin</a> = typedef std::unique_ptr&lt;std::vector&lt;char&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUToCUDAPass_8h_source.html#l00032">32</a> of file <a class="el" href="GPUToCUDAPass_8h_source.html">GPUToCUDAPass.h</a>.</p>

</div>
</div>
<a id="a48db7fd5d49bfa7ca8c81e5a6a058683"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48db7fd5d49bfa7ca8c81e5a6a058683">&#9670;&nbsp;</a></span>PassAllocatorFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">mlir::PassAllocatorFunction</a> = typedef std::function&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1Pass.html">Pass</a>&gt;()&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00028">28</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="a3bf899dff597a809a700779b46dc4972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bf899dff597a809a700779b46dc4972">&#9670;&nbsp;</a></span>PassID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3bf899dff597a809a700779b46dc4972">mlir::PassID</a> = typedef <a class="el" href="structmlir_1_1ClassID.html">ClassID</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A special type used by transformation passes to provide an address that can act as a unique identifier during pass registration. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00032">32</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="a9d158c94373a029243fd7006eb79cc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d158c94373a029243fd7006eb79cc87">&#9670;&nbsp;</a></span>PassRegistryFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a9d158c94373a029243fd7006eb79cc87">mlir::PassRegistryFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;, StringRef <a class="el" href="PassManagerOptions_8cpp.html#a708ec942a8188388392fb8fa522c3d35">options</a>)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A registry function that adds passes to the given pass manager. </p>
<p>This should also parse options and return <a class="el" href="namespacemlir.html#a5f55c06c7c4aeace3f6824dd68f8b1ed" title="Utility function to generate a LogicalResult. ">success()</a> if parsing succeeded. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8h_source.html#l00027">27</a> of file <a class="el" href="PassRegistry_8h_source.html">PassRegistry.h</a>.</p>

</div>
</div>
<a id="a748507dc3cf99476f7a1b9ec7430bd65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a748507dc3cf99476f7a1b9ec7430bd65">&#9670;&nbsp;</a></span>PatternMatchResult</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a748507dc3cf99476f7a1b9ec7430bd65">mlir::PatternMatchResult</a> = typedef <a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt;std::unique_ptr&lt;<a class="el" href="classmlir_1_1PatternState.html">PatternState</a>&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type returned by a pattern match. </p>
<p>A match failure returns a None value. A match success returns a Some value with any state the pattern may need to maintain (but may also be null). </p>

<p class="definition">Definition at line <a class="el" href="PatternMatch_8h_source.html#l00072">72</a> of file <a class="el" href="PatternMatch_8h_source.html">PatternMatch.h</a>.</p>

</div>
</div>
<a id="a253b95ef2aaf79bdc612ae40fddc0732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b95ef2aaf79bdc612ae40fddc0732">&#9670;&nbsp;</a></span>ResultElementTypeRange</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a253b95ef2aaf79bdc612ae40fddc0732">mlir::ResultElementTypeRange</a> = typedef <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt;<a class="el" href="classmlir_1_1ResultElementTypeIterator.html">ResultElementTypeIterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8h_source.html#l00094">94</a> of file <a class="el" href="TypeUtilities_8h_source.html">TypeUtilities.h</a>.</p>

</div>
</div>
<a id="a3f0d45d0562d47acc2c42934ccbfea19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0d45d0562d47acc2c42934ccbfea19">&#9670;&nbsp;</a></span>TileLoops</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">mlir::TileLoops</a> = typedef std::pair&lt;<a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a>, <a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8h_source.html#l00128">128</a> of file <a class="el" href="LoopUtils_8h_source.html">LoopUtils.h</a>.</p>

</div>
</div>
<a id="a389845a5dc285d746b24f6012a0ca2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389845a5dc285d746b24f6012a0ca2e3">&#9670;&nbsp;</a></span>TransitiveFilter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">mlir::TransitiveFilter</a> = typedef std::function&lt;bool(<a class="el" href="classmlir_1_1Operation.html">Operation</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> of the condition to limit the propagation of transitive use-defs. </p>
<p>This can be used in particular to limit the propagation to a given Scope or to avoid passing through certain types of operation in a configurable manner. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8h_source.html#l00027">27</a> of file <a class="el" href="SliceAnalysis_8h_source.html">SliceAnalysis.h</a>.</p>

</div>
</div>
<a id="a13b54e61e2491e2bc91c54f8ef429cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b54e61e2491e2bc91c54f8ef429cfa">&#9670;&nbsp;</a></span>TranslateFromMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a13b54e61e2491e2bc91c54f8ef429cfa">mlir::TranslateFromMLIRFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a>, llvm::raw_ostream &amp;output)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates MLIR to a different format and outputs the result to a stream. </p>
<p>It is allowed to modify the module. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00048">48</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="addbb54b5d484b1a53b08f04871fb0da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbb54b5d484b1a53b08f04871fb0da8">&#9670;&nbsp;</a></span>TranslateFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#addbb54b5d484b1a53b08f04871fb0da8">mlir::TranslateFunction</a> = typedef std::function&lt;<a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>( llvm::SourceMgr &amp;sourceMgr, llvm::raw_ostream &amp;output, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that performs file-to-file translation involving MLIR. </p>
<p>The input file is held in the given MemoryBuffer; the output file should be written to the given raw_ostream. The implementation should create all MLIR constructs needed during the process inside the given context. This can be used for round-tripping external formats through the MLIR system. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00056">56</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a16773901a5b8781f9be66507fad3c5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16773901a5b8781f9be66507fad3c5b4">&#9670;&nbsp;</a></span>TranslateSourceMgrToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a16773901a5b8781f9be66507fad3c5b4">mlir::TranslateSourceMgrToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>(llvm::SourceMgr &amp;sourceMgr, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the sources managed by <code>sourceMgr</code> to MLIR. </p>
<p>The source manager has at least one buffer. The implementation should create a new MLIR <a class="el" href="classmlir_1_1ModuleOp.html" title="ModuleOp represents a module, or an operation containing one region with a single block containing op...">ModuleOp</a> in the given context and return a pointer to it, or a nullptr in case of any error. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00036">36</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a995eefe8643c3770dfe42925733c17f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995eefe8643c3770dfe42925733c17f8">&#9670;&nbsp;</a></span>TranslateStringRefToMLIRFunction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a995eefe8643c3770dfe42925733c17f8">mlir::TranslateStringRefToMLIRFunction</a> = typedef std::function&lt;<a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a>(llvm::StringRef, <a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface of the function that translates the given string to MLIR. </p>
<p>The implementation should create a new MLIR <a class="el" href="classmlir_1_1ModuleOp.html" title="ModuleOp represents a module, or an operation containing one region with a single block containing op...">ModuleOp</a> in the given context. If source-related error reporting is required from within the function, use TranslateSourceMgrToMLIRFunction instead. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8h_source.html#l00043">43</a> of file <a class="el" href="Translation_8h_source.html">Translation.h</a>.</p>

</div>
</div>
<a id="a01e9069ef9040ccc727d541c02d49ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e9069ef9040ccc727d541c02d49ecd">&#9670;&nbsp;</a></span>TypeStorageAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#a01e9069ef9040ccc727d541c02d49ecd">mlir::TypeStorageAllocator</a> = typedef <a class="el" href="classmlir_1_1StorageUniquer_1_1StorageAllocator.html">StorageUniquer::StorageAllocator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeSupport_8h_source.html#l00078">78</a> of file <a class="el" href="TypeSupport_8h_source.html">TypeSupport.h</a>.</p>

</div>
</div>
<a id="aa10a637dbeb6e0d2178032f95fb5ea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10a637dbeb6e0d2178032f95fb5ea1b">&#9670;&nbsp;</a></span>VectorizableLoopFun</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemlir.html#aa10a637dbeb6e0d2178032f95fb5ea1b">mlir::VectorizableLoopFun</a> = typedef std::function&lt;bool(AffineForOp)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8h_source.html#l00063">63</a> of file <a class="el" href="LoopAnalysis_8h_source.html">LoopAnalysis.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a6d3b7fd763c24274db6c115579084133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d3b7fd763c24274db6c115579084133">&#9670;&nbsp;</a></span>AffineExprKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">mlir::AffineExprKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2"></a>Mul&#160;</td><td class="fielddoc"><p>RHS of mul is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942"></a>Mod&#160;</td><td class="fielddoc"><p>RHS of mod is always a constant or a symbolic expression with a positive value. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a"></a>FloorDiv&#160;</td><td class="fielddoc"><p>RHS of floordiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a"></a>CeilDiv&#160;</td><td class="fielddoc"><p>RHS of ceildiv is always a constant or a symbolic expression. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133a4be6ccd8c4af006587a76a5fd3e7dc24"></a>LAST_AFFINE_BINARY_OP&#160;</td><td class="fielddoc"><p>This is a marker for the last affine binary op. </p>
<p>The range of binary op's is expected to be this element and earlier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133acb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"><p>Constant integer. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133ab49b848e4bb608f4d5650e4b2817c641"></a>DimId&#160;</td><td class="fielddoc"><p>Dimensional identifier. </p>
</td></tr>
<tr><td class="fieldname"><a id="a6d3b7fd763c24274db6c115579084133aea00d3c6059a4ff11d351696747fc7ff"></a>SymbolId&#160;</td><td class="fielddoc"><p>Symbolic identifier. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="AffineExpr_8h_source.html#l00038">38</a> of file <a class="el" href="AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a6eec030e79134e91fb05b8292b926ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eec030e79134e91fb05b8292b926ced">&#9670;&nbsp;</a></span>CmpFPredicate</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a6eec030e79134e91fb05b8292b926ced">mlir::CmpFPredicate</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The predicate indicates the type of the comparison to perform: (un)orderedness, (in)equality and less/greater than (or equal to) as well as predicates that are always true or false. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda16bc26a24d0ab96c13eb2b9e978e4cd9"></a>FirstValidValue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda8cec5cec7e1bd101eefe8dde47c99289"></a>AlwaysFalse&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda9e55d7c6936a06336f631f412cf5da92"></a>OEQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedad7bc4f60747e9364d82cffe507605303"></a>OGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedaf36752024f8d66ec77bdf0516130c5fc"></a>OGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedabab6f0ecb8f89999407a1001a52791c6"></a>OLT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda4702e1e1f9db3a2ae4da4e8d63c5944d"></a>OLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedabc21e6484530fc9d0313cb816b733396"></a>ONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedac23431d0209648a6b31fa837dd56d681"></a>ORD&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedae38e4eeca7782ab6c251c9619df3152e"></a>UEQ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda7efc25ec6c881b13261c1a6d88762483"></a>UGT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedada0d6078de3703b5680eb9361f2d68fd"></a>UGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda2b4652512a6c88f5a39c3288081b6e13"></a>ULT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedae29e365fd3b5e59c86218486a0c1c7c1"></a>ULE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926cedab57b8eb662c518fa21051312319f6270"></a>UNE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda59f822bcaa8e119bde63eb00919b367a"></a>UNO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda65db12e33585aff2007aad58b62b7bcd"></a>AlwaysTrue&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a6eec030e79134e91fb05b8292b926ceda6d38e67a05ce973a273ab1f8e84d1b6a"></a>NumPredicates&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Ops_8h_source.html#l00046">46</a> of file <a class="el" href="Ops_8h_source.html">Ops.h</a>.</p>

</div>
</div>
<a id="a247bc9a6d1f1577f2d876cb55e2ea752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247bc9a6d1f1577f2d876cb55e2ea752">&#9670;&nbsp;</a></span>DiagnosticSeverity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752">mlir::DiagnosticSeverity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Defines the different supported severity of a diagnostic. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a3b0649c72650c313a357338dcdfb64ec"></a>Note&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa"></a>Warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd"></a>Error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6"></a>Remark&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Diagnostics_8h_source.html#l00040">40</a> of file <a class="el" href="Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

</div>
</div>
<a id="a583774594e92d8af2d0884e3262d7e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583774594e92d8af2d0884e3262d7e24">&#9670;&nbsp;</a></span>OperationProperty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#a583774594e92d8af2d0884e3262d7e24">mlir::OperationProperty</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a583774594e92d8af2d0884e3262d7e24ac9f87f9079df3ae77c58b9258f497dfb"></a>Commutative&#160;</td><td class="fielddoc"><p>This bit is set for an operation if it is a commutative operation: that is a binary operator (two inputs) where "a op b" and "b op a" produce the same results. </p>
</td></tr>
<tr><td class="fieldname"><a id="a583774594e92d8af2d0884e3262d7e24adf103a49f1843ddea54be10b182ef456"></a>NoSideEffect&#160;</td><td class="fielddoc"><p>This bit is set for operations that have no side effects: that means that they do not read or write memory, or access any hidden state. </p>
</td></tr>
<tr><td class="fieldname"><a id="a583774594e92d8af2d0884e3262d7e24ab420c1d31e69a823fbc30a434907c9c0"></a>Terminator&#160;</td><td class="fielddoc"><p>This bit is set for an operation if it is a terminator: that means an operation at the end of a block. </p>
</td></tr>
<tr><td class="fieldname"><a id="a583774594e92d8af2d0884e3262d7e24aee504cc3a721fbb8c7898dcc0798d273"></a>IsolatedFromAbove&#160;</td><td class="fielddoc"><p>This bit is set for operations that are completely isolated from above. </p>
<p>This is used for operations whose regions are explicit capture only, i.e. they are never allowed to implicitly reference values defined above the parent operation. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00058">58</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

</div>
</div>
<a id="ab64460ede39d8480e398fd2e6810d95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64460ede39d8480e398fd2e6810d95b">&#9670;&nbsp;</a></span>PassDisplayMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ab64460ede39d8480e398fd2e6810d95b">mlir::PassDisplayMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An enum describing the different display modes for the information within the pass manager. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95ba4ee29ca12c7d126654bd0e5275de6135"></a>List&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab64460ede39d8480e398fd2e6810d95baaeaeaec51b4e6b88122f10ad96a8de72"></a>Pipeline&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="PassManager_8h_source.html#l00116">116</a> of file <a class="el" href="PassManager_8h_source.html">PassManager.h</a>.</p>

</div>
</div>
<a id="ae0a5f1311f5db69741663dd9e28a3c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a5f1311f5db69741663dd9e28a3c9b">&#9670;&nbsp;</a></span>SDBMExprKind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9b">mlir::SDBMExprKind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9baec211f7c20af43e742bf2570c3cb84f9"></a>Add&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9bace7566d1d08cc094b74cf283cf9c56a5"></a>Stripe&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9ba49630f5d7723e9b41474bd1cb1887b9d"></a>Diff&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9bacb17869fe51048b5a5c4c6106551a255"></a>Constant&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9bab49b848e4bb608f4d5650e4b2817c641"></a>DimId&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9baea00d3c6059a4ff11d351696747fc7ff"></a>SymbolId&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae0a5f1311f5db69741663dd9e28a3c9bafb278fa5defd7e699fcbc930c3e76ccd"></a>Neg&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="SDBMExpr_8h_source.html#l00026">26</a> of file <a class="el" href="SDBMExpr_8h_source.html">SDBMExpr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad7e21be21731f5958cbe1b0dbc79c684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e21be21731f5958cbe1b0dbc79c684">&#9670;&nbsp;</a></span>affineDataCopyGenerate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::affineDataCopyGenerate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html#a0ea87a88ccca470d216809e2a162d909">Block::iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1AffineCopyOptions.html">AffineCopyOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>copyOptions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>copyNests</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs explicit copying for the contiguous sequence of operations in the block iterator range [`begin', `end'), where `end' can't be past the terminator of the block (since additional operations are potentially inserted right before <code>end</code>. </p>
<p>Generates copies for a contiguous sequence of operations in <code>block</code> in the iterator range [`begin', `end'), where `end' can't be past the terminator of the block (since additional operations are potentially inserted right before `end'.</p>
<p>Returns the total size of fast memory space buffers used. <code>copyOptions</code> provides various parameters, and the output argument <code>copyNests</code> is the set of all copy nests inserted, each represented by its root affine.for. Since we generate alloc's and dealloc's for all fast buffers (before and after the range of operations resp. or at a hoisted position), all of the fast memory capacity is assumed to be available for processing this block range.</p>
<p>Returns the total size of the fast buffers used. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01595">1595</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00300">mlir::Operation::emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LoopUtils_8h_source.html#l00162">mlir::AffineCopyOptions::fastMemCapacityBytes</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01124">findHighestBlockForPlacement()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01547">getFullMemRefAsRegion()</a>, <a class="el" href="Operation_8h_source.html#l00107">mlir::Operation::getLoc()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00864">getNestingDepth()</a>, <a class="el" href="LoopUtils_8h_source.html#l00156">mlir::AffineCopyOptions::slowMemorySpace</a>, and <a class="el" href="LogicalResult_8h_source.html#l00039">succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00133">createAffineDataCopyGenerationPass()</a>.</p>

</div>
</div>
<a id="ab988b7a1c1e3c8a7d795e8dcdeb53f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab988b7a1c1e3c8a7d795e8dcdeb53f45">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>convertedOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply an analysis conversion on the given operations, and all nested operations. </p>
<p>This method analyzes which operations would be successfully converted to the target if a conversion was applied. All operations that were found to be legalizable to the given 'target' are placed within the provided 'convertedOps' set; note that no actual rewrites are applied to the operations on success and only pre-existing operations are added to the set. This method only returns failure if there are unreachable blocks in any of the regions nested within 'ops', or if a type conversion failed. If 'converter' is provided, the signatures of blocks and regions are also considered for conversion.</p>
<p>This method analyzes which operations would be successfully converted to the target if a conversion was applied. All operations that were found to be legalizable to the given 'target' are placed within the provided 'convertedOps' set; note that no actual rewrites are applied to the operations on success and only pre-existing operations are added to the set. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01829">1829</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l01838">applyAnalysisConversion()</a>, and <a class="el" href="DialectConversion_8h_source.html#l00562">mlir::ConversionTarget::isDynamicallyLegal()</a>.</p>

</div>
</div>
<a id="aa7fd732394cac1c65af0e08be0d83070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7fd732394cac1c65af0e08be0d83070">&#9670;&nbsp;</a></span>applyAnalysisConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyAnalysisConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>convertedOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01838">1838</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l01829">applyAnalysisConversion()</a>.</p>

</div>
</div>
<a id="aef5c4de80f0f4b1da1d303c0d578e193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5c4de80f0f4b1da1d303c0d578e193">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a complete conversion on the given operations, and all nested operations. </p>
<p>This method returns failure if the conversion of any operation fails, or if there are unreachable blocks in any of the regions nested within 'ops'. If 'converter' is provided, the signatures of blocks and regions are also converted.</p>
<p>This method will return failure if the conversion of any operation fails. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01809">1809</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l01816">applyFullConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00562">mlir::ConversionTarget::isDynamicallyLegal()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00559">populateLinalgToLLVMConversionPatterns()</a>, and <a class="el" href="DecorateSPIRVCompositeTypeLayoutPass_8cpp_source.html#l00075">populateSPIRVLayoutInfoPatterns()</a>.</p>

</div>
</div>
<a id="a1fe5735cbbe82b381ee6dee730c0135c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fe5735cbbe82b381ee6dee730c0135c">&#9670;&nbsp;</a></span>applyFullConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyFullConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01816">1816</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l01809">applyFullConversion()</a>.</p>

</div>
</div>
<a id="a8fb5e2289856e1f55dda26449decb01f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb5e2289856e1f55dda26449decb01f">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Below we define several entry points for operation conversion. </p>
<p>Apply a partial conversion on the given operations, and all nested operations.</p>
<p>It is important to note that the patterns provided to the conversion framework may have additional constraints. See the <code><a class="el" href="classmlir_1_1PatternRewriter.html" title="This class coordinates the application of a pattern to the current function, providing a way to creat...">PatternRewriter</a> Hooks</code> section of the <a class="el" href="classmlir_1_1ConversionPatternRewriter.html" title="This class implements a pattern rewriter for use with ConversionPatterns. ">ConversionPatternRewriter</a>, to see what additional constraints are imposed on the use of the <a class="el" href="classmlir_1_1PatternRewriter.html" title="This class coordinates the application of a pattern to the current function, providing a way to creat...">PatternRewriter</a>. Apply a partial conversion on the given operations, and all nested operations. This method converts as many operations to the target as possible, ignoring operations that failed to legalize. This method only returns failure if there are unreachable blocks in any of the regions nested within 'ops'. If 'converter' is provided, the signatures of blocks and regions are also converted.</p>
<p>This method converts as many operations to the target as possible, ignoring operations that failed to legalize. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01791">1791</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8cpp_source.html#l01798">applyPartialConversion()</a>, <a class="el" href="DialectConversion_8h_source.html#l00562">mlir::ConversionTarget::isDynamicallyLegal()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00100">lowerEntryPointABIAttr()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02209">makeStandardToLLVMTypeConverter()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00542">populateAffineToStdConversionPatterns()</a>, <a class="el" href="ConvertLoopToStandard_8cpp_source.html#l00249">populateLoopToStdConversionPatterns()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00955">populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a48db022f7a07df86a486209a5ddd3917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48db022f7a07df86a486209a5ddd3917">&#9670;&nbsp;</a></span>applyPartialConversion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::applyPartialConversion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ConversionTarget.html">ConversionTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01798">1798</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8cpp_source.html#l01791">applyPartialConversion()</a>.</p>

</div>
</div>
<a id="a706b943c7bb07b96e86234204b79b3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706b943c7bb07b96e86234204b79b3d4">&#9670;&nbsp;</a></span>applyPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::applyPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1PassManager.html">PassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply any values provided to the pass manager options that were registered with 'registerPassManagerOptions'. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00153">153</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">References <a class="el" href="Pass_8cpp_source.html#l00596">mlir::PassManager::disableMultithreading()</a>, <a class="el" href="Pass_8cpp_source.html#l00603">mlir::PassManager::enableCrashReproducerGeneration()</a>, and <a class="el" href="PassStatistics_8cpp_source.html#l00247">mlir::PassManager::enableStatistics()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00040">performActions()</a>, and <a class="el" href="PassManager_8h_source.html#l00193">mlir::PassManager::IRPrinterConfig::shouldPrintAfterOnlyOnChange()</a>.</p>

</div>
</div>
<a id="ab790599e761a4417fba233542b93a654"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab790599e761a4417fba233542b93a654">&#9670;&nbsp;</a></span>applyPatternsGreedily() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::applyPatternsGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the regions of the specified operation, which must be isolated from above, by repeatedly applying the highest benefit patterns in a greedy work-list driven manner. </p>
<p>Return true if no more patterns can be matched in the result operation regions. Note: This does not apply patterns to the top-level operation itself. Note: These methods also perform folding and simple dead-code elimination before attempting to match any of the provided patterns.</p>
<p>Return true if no more patterns can be matched in the result operation regions. Note: This does not apply patterns to the top-level operation itself. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00218">218</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00365">mlir::Operation::getRegions()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00202">canonicalizeSCC()</a>, <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00367">mlir::fxpmath::createLowerUniformRealMathPass()</a>, <a class="el" href="LinalgToLoops_8cpp_source.html#l00071">emitLoopRanges()</a>, <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00153">populateStdLegalizationPatternsForSPIRVLowering()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00955">populateVectorToLLVMConversionPatterns()</a>, and <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00216">tryRewriteAffineMulEwSigned()</a>.</p>

</div>
</div>
<a id="a909c445a02cac083be999a1dbb578939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909c445a02cac083be999a1dbb578939">&#9670;&nbsp;</a></span>applyPatternsGreedily() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::applyPatternsGreedily </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrite the given regions, which must be isolated from above. </p>

<p class="definition">Definition at line <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00224">224</a> of file <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html">GreedyPatternRewriteDriver.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp.html#abc93c6e6423ccac6a485da1d68cc6dd7">maxPatternMatchIterations()</a>.</p>

</div>
</div>
<a id="ac680df79552c596c048cd9cb27638c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac680df79552c596c048cd9cb27638c5f">&#9670;&nbsp;</a></span>areValuesDefinedAbove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::areValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype">Range&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if all values in the provided range are defined above the <code>limit</code> region. </p>
<p>That is, if they are defined in a region that is a proper ancestor of <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8h_source.html#l00023">23</a> of file <a class="el" href="RegionUtils_8h_source.html">RegionUtils.h</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00056">getUsedValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00021">replaceAllUsesInRegionWith()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00342">simplifyRegions()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00029">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopsToGPU_8cpp_source.html#l00101">checkLoopNestMappableImpl()</a>.</p>

</div>
</div>
<a id="a97905517c34a363dacccfe12bb2fcc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97905517c34a363dacccfe12bb2fcc14">&#9670;&nbsp;</a></span>bindDims()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... AffineExprTy&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::bindDims </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineExprTy &amp;...&#160;</td>
          <td class="paramname"><em>exprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind a list of <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> references to DimExpr at positions: [0 . </p>
<p>. sizeof...(exprs)] </p>

<p class="definition">Definition at line <a class="el" href="AffineExpr_8h_source.html#l00286">286</a> of file <a class="el" href="AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00301">mlir::edsc::ops::linalg_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00335">mlir::edsc::ops::linalg_dilated_conv_nhwc()</a>, and <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00287">mlir::edsc::ops::linalg_matmul()</a>.</p>

</div>
</div>
<a id="afdb92b40e131a0a6bd17fc39f1f3e371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb92b40e131a0a6bd17fc39f1f3e371">&#9670;&nbsp;</a></span>boundCheckLoadOrStoreOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LoadOrStoreOpPointer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::boundCheckLoadOrStoreOp </td>
          <td>(</td>
          <td class="paramtype">LoadOrStoreOpPointer&#160;</td>
          <td class="paramname"><em>loadOrStoreOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>emitError</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks a load or store op for an out of bound access; returns failure if the access is out of bounds along any of the dimensions, success otherwise. </p>
<p>Emits a diagnostic error (with location information) if emitError is true. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00371">371</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01904">mlir::FlatAffineConstraints::addConstantUpperBound()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00301">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="Operation_8h_source.html#l00107">mlir::Operation::getLoc()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MemRefBoundCheck_8cpp_source.html#l00038">createMemRefBoundCheckPass()</a>.</p>

</div>
</div>
<a id="a90d90e917cd6d91240a86ce6e3c9a9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d90e917cd6d91240a86ce6e3c9a9c6">&#9670;&nbsp;</a></span>buildTripCountMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::buildTripCountMapAndOperands </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>tripCountMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>tripCountOperands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop as an affine map with its corresponding operands if the latter is expressible as an affine expression, and nullptr otherwise. </p>
<p>Returns the trip count of the loop as an affine expression if the latter is expressible as an affine expression, and nullptr otherwise.</p>
<p>This method always succeeds as long as the lower bound is not a multi-result map. The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions</p>
<p>The trip count expression is simplified before returning. This method only utilizes map composition to construct lower and upper bounds before computing the trip count expressions. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">35</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00129">mlir::StandardAttributes::AffineMap</a>, <a class="el" href="MathExtras_8h_source.html#l00023">ceilDiv()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00520">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00294">mlir::AffineValueMap::getAffineMap()</a>, <a class="el" href="AffineStructures_8h_source.html#l00154">mlir::AffineValueMap::getNumResults()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00290">mlir::AffineValueMap::getOperands()</a>, <a class="el" href="AffineStructures_8h_source.html#l00150">mlir::AffineValueMap::getResult()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00149">mlir::AffineValueMap::setResult()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00044">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00117">getLargestDivisorOfTripCount()</a>.</p>

</div>
</div>
<a id="a55bd2296bf14909ca8aa0730535cdd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bd2296bf14909ca8aa0730535cdd3a">&#9670;&nbsp;</a></span>canFuseLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> mlir::canFuseLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>srcSlice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the feasibility of fusing the loop nest rooted at 'srcForOp' into the loop nest rooted at 'dstForOp' at 'dstLoopDepth'. </p>
<p>Returns <a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> 'Success' if fusion of the src/dst loop nests is feasible (i.e. they are in the same block and dependences would not be violated). Otherwise returns a <a class="el" href="structmlir_1_1FusionResult.html">FusionResult</a> explaining why fusion is not feasible. NOTE: This function is not feature complete and should only be used in testing. TODO(andydavis) Update comments when this function is fully implemented. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00191">191</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">computeSliceUnion()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00035">mlir::FusionResult::FailBlockDependence</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00034">mlir::FusionResult::FailPrecondition</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00178">gatherLoadsAndStores()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00137">getFusedLoopNestInsertionPoint()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00894">getNumCommonSurroundingLoops()</a>, and <a class="el" href="LoopFusionUtils_8h_source.html#l00033">mlir::FusionResult::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8h_source.html#l00039">mlir::FusionResult::FusionResult()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="ad8bde50e2368b8864c8bc070a11fdd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bde50e2368b8864c8bc070a11fdd71">&#9670;&nbsp;</a></span>canonicalizeMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::canonicalizeMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modifies both <code>map</code> and <code>operands</code> in-place so as to: </p>
<ol type="1">
<li>drop duplicate operands</li>
<li>drop unused dims and symbols from map</li>
<li>promote valid symbols to symbolic operands in case they appeared as dimensional operands</li>
<li>propagate constant operands and drop them </li>
</ol>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00731">731</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01751">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00662">augmentMapAndBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">canonicalizeLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00578">composeAffineMapAndOperands()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00032">emitOrFoldComposedAffineApply()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00663">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00044">getCleanupLoopLowerBound()</a>, <a class="el" href="AffineOps_8h_source.html#l00505">mlir::AffineStoreOp::getOperationName()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>, <a class="el" href="LinalgToLoops_8cpp_source.html#l00041">makeCanonicalAffineApplies()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">replaceAllMemRefUsesWith()</a>.</p>

</div>
</div>
<a id="a02d761b15655cb81ff4b40dbf49445db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d761b15655cb81ff4b40dbf49445db">&#9670;&nbsp;</a></span>canonicalizeSetAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::canonicalizeSetAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a> *&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Canonicalizes an integer set the same way canonicalizeMapAndOperands does for affine maps. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00736">736</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Functional_8h_source.html#l00067">mlir::functional::apply()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00578">composeAffineMapAndOperands()</a>, <a class="el" href="AffineOps_8h_source.html#l00411">mlir::AffineLoadOp::getMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00481">mlir::AffineStoreOp::getMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00475">mlir::AffineStoreOp::getValueToStore()</a>, <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00327">mlir::PatternRewriter::replaceOpWithNewOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00505">mlir::AffineStoreOp::getOperationName()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01672">print()</a>.</p>

</div>
</div>
<a id="a80dcfbd64b4c5038926d874e46edeea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80dcfbd64b4c5038926d874e46edeea2">&#9670;&nbsp;</a></span>canonicalizeStridedLayout()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a> mlir::canonicalizeStridedLayout </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a version of <code>t</code> with identity layout if it can be determined statically that the layout is the canonical contiguous strided layout. </p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout.</p>
<p>Otherwise pass <code>t</code>'s layout into <code>simplifyAffineMap</code> and return a copy of <code>t</code> with simplified layout. If <code>t</code> has multiple layout maps or a multi-result layout, just return <code>t</code>. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00707">707</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00303">mlir::MemRefType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00382">mlir::MemRefType::getAffineMaps()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00380">mlir::MemRefType::getShape()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00430">makeCanonicalStridedLayoutExpr()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00839">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l00387">computeReshapeCollapsedType()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00528">mlir::NoneType::kindof()</a>.</p>

</div>
</div>
<a id="a46a3d17c70f67aa2d18203667acaf114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a3d17c70f67aa2d18203667acaf114">&#9670;&nbsp;</a></span>ceilDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::ceilDiv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of MLIR's ceildiv operation on constants. </p>
<p>The RHS is expected to be positive. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00023">23</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">buildTripCountMapAndOperands()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00493">generateTransferOpSlices()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">mlir::FlatAffineConstraints::getConstantBoundOnDimSize()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00509">isValidExtractOrInsertSlicesType()</a>, and <a class="el" href="AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="af210ccb9e9409d8494b8998f50b6d274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af210ccb9e9409d8494b8998f50b6d274">&#9670;&nbsp;</a></span>checkMemrefAccessDependence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a> mlir::checkMemrefAccessDependence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>srcAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmlir_1_1MemRefAccess.html">MemRefAccess</a> &amp;&#160;</td>
          <td class="paramname"><em>dstAccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>dependenceConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt; *&#160;</td>
          <td class="paramname"><em>dependenceComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowRAR</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">764</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00306">addDomainConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00584">addOrderingConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00210">buildDimAndSymbolPositionMaps()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00610">computeDirectionVector()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l02233">mlir::Operation::dump()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02348">mlir::FlatAffineConstraints::dump()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00105">mlir::DependenceResult::Failure</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00663">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00111">getInstIndexSet()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00515">getNumCommonLoops()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">mlir::FlatAffineConstraints::getNumDimIds()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00103">mlir::DependenceResult::HasDependence</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01130">mlir::FlatAffineConstraints::isEmpty()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00047">mlir::MemRefAccess::memref</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00104">mlir::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00048">mlir::MemRefAccess::opInst</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00560">srcAppearsBeforeDstInAncestralBlock()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TestMemRefDependenceCheck_8cpp_source.html#l00076">checkDependences()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">computeSliceUnion()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00082">createMemRefDataFlowOptPass()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00107">mlir::DependenceResult::DependenceResult()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00857">getDependenceComponents()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00814">getMaxLoopDepth()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00973">isLoopParallel()</a>.</p>

</div>
</div>
<a id="a5a9a2ddfbe72ba156ffb258a781693a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9a2ddfbe72ba156ffb258a781693a0">&#9670;&nbsp;</a></span>coalesceLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::coalesceLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; loop::ForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a perfect nest of "for" loops with a single linearized loop. </p>
<p>Assumes <code>loops</code> contains a list of perfectly nested loops with bounds and steps independent of any loop induction variable involved in the nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01041">1041</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00985">normalizeLoop()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00021">replaceAllUsesInRegionWith()</a>, and <a class="el" href="IR_2Builders_8h_source.html#l00259">mlir::OpBuilder::setInsertionPointToStart()</a>.</p>

</div>
</div>
<a id="aa68a5a18c2ea856568b0fbfb272e2b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa68a5a18c2ea856568b0fbfb272e2b0d">&#9670;&nbsp;</a></span>computeSliceUnion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::computeSliceUnion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>opsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>opsB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numCommonLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceUnion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes in 'sliceUnion' the union of all slice bounds computed at 'loopDepth' between all dependent pairs of ops in 'opsA' and 'opsB'. </p>
<p>The parameter 'numCommonLoops' is the number of loops common to the operations in 'opsA' and 'opsB'. If 'isBackwardSlice' is true, computes slice bounds for loop nest surrounding ops in 'opsA', as a function of IVs and symbols of loop nest surrounding ops in 'opsB' at 'loopDepth'. If 'isBackwardSlice' is false, computes slice bounds for loop nest surrounding ops in 'opsB', as a function of IVs and symbols of loop nest surrounding ops in 'opsA' at 'loopDepth'. Returns 'success' if union was computed, 'failure' otherwise.</p>
<p>Returns 'Success' if union was computed, 'failure' otherwise. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">520</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="Attributes_8h_source.html#l00129">mlir::StandardAttributes::AffineMap</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00513">mlir::FlatAffineConstraints::areIdsAlignedWithOther()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">checkMemrefAccessDependence()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00083">mlir::ComputationSliceState::clearBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00798">mlir::FlatAffineConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00105">mlir::DependenceResult::Failure</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">getComputationSliceState()</a>, <a class="el" href="AffineStructures_8h_source.html#l00584">mlir::FlatAffineConstraints::getIdValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00591">mlir::FlatAffineConstraints::getIdValues()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00491">getInnermostCommonLoopDepth()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00864">getNestingDepth()</a>, <a class="el" href="AffineStructures_8h_source.html#l00566">mlir::FlatAffineConstraints::getNumDimAndSymbolIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00564">mlir::FlatAffineConstraints::getNumDimIds()</a>, <a class="el" href="AffineStructures_8h_source.html#l00567">mlir::FlatAffineConstraints::getNumLocalIds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00068">mlir::ComputationSliceState::insertPoint</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00058">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00064">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00060">mlir::ComputationSliceState::lbs</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00047">mlir::MemRefAccess::memref</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00633">mlir::FlatAffineConstraints::mergeAndAlignIdsWithOther()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00104">mlir::DependenceResult::NoDependence</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00048">mlir::MemRefAccess::opInst</a>, <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00066">mlir::ComputationSliceState::ubOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00062">mlir::ComputationSliceState::ubs</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02744">mlir::FlatAffineConstraints::unionBoundingBox()</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00191">canFuseLoops()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a6d24d64d6db077b8d5c88316b0d6c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d24d64d6db077b8d5c88316b0d6c717">&#9670;&nbsp;</a></span>concatAffineMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::concatAffineMaps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> &gt;&#160;</td>
          <td class="paramname"><em>maps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates a list of <code>maps</code> into a single <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a>, stepping over potentially empty maps. </p>
<p>Assumes each of the underlying map has 0 symbols. The resulting map has a number of dims equal to the max of <code>maps</code>' dims and the concatenated results as its results. Returns an empty map if all input <code>maps</code> are empty.</p>
<p>Example: When applied to the following list of 3 affine maps,</p>
<div class="fragment"><div class="line">{</div><div class="line">  (i, j, k) -&gt; (i, k),</div><div class="line">  (i, j, k) -&gt; (k, j),</div><div class="line">  (i, j, k) -&gt; (i, j)</div><div class="line">}</div></div><!-- fragment --><p>Returns the map:</p>
<div class="fragment"><div class="line">(i, j, k) -&gt; (i, k, k, j, i, j)</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AffineMap_8cpp_source.html#l00313">313</a> of file <a class="el" href="AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00129">mlir::StandardAttributes::AffineMap</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLoops_8cpp_source.html#l00071">emitLoopRanges()</a>, <a class="el" href="AffineMap_8h_source.html#l00154">hash_value()</a>, <a class="el" href="Tiling_8cpp_source.html#l00311">mlir::linalg::tileLinalgOp()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00231">verifyGenericOp()</a>.</p>

</div>
</div>
<a id="a5d3b3bbe9e749975af2eb5358df6f5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3b3bbe9e749975af2eb5358df6f5fe">&#9670;&nbsp;</a></span>constFoldBinaryOp()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AttrElementT , class ElementValueT  = typename AttrElementT::ValueType, class CalculationT  = function_ref&lt;ElementValueT(ElementValueT, ElementValueT)&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::constFoldBinaryOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Attribute.html">Attribute</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalculationT &amp;&#160;</td>
          <td class="paramname"><em>calculate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs constant folding <code>calculate</code> with element-wise behavior on the two attributes in <code>operands</code> and returns the result if possible. </p>

<p class="definition">Definition at line <a class="el" href="CommonFolders_8h_source.html#l00030">30</a> of file <a class="el" href="CommonFolders_8h_source.html">CommonFolders.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8cpp_source.html#l00572">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Attributes_8h_source.html#l00821">mlir::DenseElementsAttr::getSplatValue()</a>, and <a class="el" href="classmlir_1_1ElementsAttr.html#adf4ac010890b03caf951f8e0c59364b6">mlir::ElementsAttr::getValues()</a>.</p>

</div>
</div>
<a id="addbe63747d3d90805543a5697ca8aca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbe63747d3d90805543a5697ca8aca9">&#9670;&nbsp;</a></span>convertAffineLoopNestToGPULaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertAffineLoopNestToGPULaunch </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a perfect affine loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation. </p>
<p>Map <code>numBlockDims</code> outer loops to GPU blocks and <code>numThreadDims</code> to GPU threads. The bounds of the loops that are mapped should be independent of the induction variables of the other mapped loops.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="definition">Definition at line <a class="el" href="LoopsToGPU_8cpp_source.html#l00514">514</a> of file <a class="el" href="LoopsToGPU_8cpp_source.html">LoopsToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a9ba4e422d65880a2c3356017568b7df9">convertLoopNestToGPULaunch()</a>, and <a class="el" href="LoopsToGPU_8cpp_source.html#l00485">convertLoopNestToGPULaunch()</a>.</p>

</div>
</div>
<a id="a9ba4e422d65880a2c3356017568b7df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba4e422d65880a2c3356017568b7df9">&#9670;&nbsp;</a></span>convertLoopNestToGPULaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertLoopNestToGPULaunch </td>
          <td>(</td>
          <td class="paramtype">loop::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a perfect linalg loop nest with the outermost loop identified by <code>forOp</code> into a gpu::Launch operation. </p>
<p>Map <code>numBlockDims</code> outer loops to GPU blocks and <code>numThreadDims</code> to GPU threads. The bounds of the loops that are mapped should be independent of the induction variables of the other mapped loops.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="reference">Referenced by <a class="el" href="LoopsToGPU_8cpp_source.html#l00514">convertAffineLoopNestToGPULaunch()</a>.</p>

</div>
</div>
<a id="a6c080f43260d9c1211bd2da15ee3ab1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c080f43260d9c1211bd2da15ee3ab1e">&#9670;&nbsp;</a></span>convertLoopToGPULaunch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::convertLoopToGPULaunch </td>
          <td>(</td>
          <td class="paramtype">loop::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>numWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>workGroupSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a loop operation into a GPU launch with the values provided in <code>numWorkGroups</code> as the grid size and the values provided in <code>workGroupSizes</code> as the block size. </p>
<p>Size of <code>numWorkGroups</code> and workGroupSizes` must be less than or equal to 3. The loop operation can be an imperfectly nested computation with the following restrictions: 1) The loop nest must contain as many perfectly nested loops as the number of values passed in through <code>numWorkGroups</code>. This corresponds to the number of grid dimensions of the launch. All loops within the loop nest must be parallel. 2) The body of the innermost loop of the above perfectly nested loops, must contain statements that satisfy one of the two conditions below: a) A perfect loop nest of depth greater than or equal to the number of values passed in through <code>workGroupSizes</code>, i.e. the number of thread dimensions of the launch. Loops at depth less than or equal to size of <code>workGroupSizes</code> must be parallel. Loops nested deeper can be sequential and are retained as such in the generated GPU launch code. b) Statements that are safe to be executed by all threads within the workgroup. No checks are performed that this is indeed the case. TODO(ravishankarm) : Add checks that verify 2(b) above. The above conditions are assumed to be satisfied by the computation rooted at <code>forOp</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopsToGPU_8cpp_source.html#l00526">526</a> of file <a class="el" href="LoopsToGPU_8cpp_source.html">LoopsToGPU.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopsToGPU_8cpp_source.html#l00504">convertLoopToGPULaunch()</a>.</p>

</div>
</div>
<a id="aaf77fbf5a0ed9246f9754a542730b4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf77fbf5a0ed9246f9754a542730b4d5">&#9670;&nbsp;</a></span>convertToCamelCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::convertToCamelCase </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>capitalizeFirst</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string from camel-case to snake_case by replacing all occurrences of '_' followed by a lowercase letter with the letter in uppercase. </p>
<p>Optionally allow capitalization of the first letter (if it is a lowercase letter) </p>

<p class="definition">Definition at line <a class="el" href="StringExtras_8h_source.html#l00044">44</a> of file <a class="el" href="StringExtras_8h_source.html">StringExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>.</p>

</div>
</div>
<a id="a4be4316ece2a64d363670801d7c64555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4be4316ece2a64d363670801d7c64555">&#9670;&nbsp;</a></span>convertToSnakeCase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string mlir::convertToSnakeCase </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a string to snake-case from camel-case by replacing all uppercase letters with '_' followed by the letter in lowercase, except if the uppercase letter is the first character of the string. </p>

<p class="definition">Definition at line <a class="el" href="StringExtras_8h_source.html#l00024">24</a> of file <a class="el" href="StringExtras_8h_source.html">StringExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVDialect_8cpp_source.html#l00132">mlir::spirv::SPIRVDialect::getAttributeName()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00050">isFnEntryBlock()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00300">parseVariableDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00337">printVariableDecorations()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l03146">verify()</a>.</p>

</div>
</div>
<a id="aebf452ef02d7d46f5c0f409ebb373b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf452ef02d7d46f5c0f409ebb373b92">&#9670;&nbsp;</a></span>createAffineComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::createAffineComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>opInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineApplyOp.html">AffineApplyOp</a> &gt; *&#160;</td>
          <td class="paramname"><em>sliceOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation. </p>
<p>Given an operation, inserts one or more single result affine apply operations, results of which are exclusively used by this operation operation.</p>
<p>The operands of these newly created affine apply ops are guaranteed to be loop iterators or terminal symbols of a function.</p>
<p>Before</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) send A[idx], ... v = "compute"(idx, ...)</p>
<p>After</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) send A[idx], ... idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) v = "compute"(idx_, ...) This allows the application of different transformations on send and compute (for eg. different shifts/delays)</p>
<p>Fills <code>sliceOps</code> with the list of affine.apply operations. In the following cases, <code>sliceOps</code> remains empty:</p><ol type="1">
<li>If none of opInst's operands were the result of an affine.apply (i.e., there was no affine computation slice to create).</li>
<li>If all the affine.apply op's supplying operands to this opInst did not have any uses other than those in this opInst.</li>
</ol>
<p>The operands of these newly created affine apply ops are guaranteed to be loop iterators or terminal symbols of a function.</p>
<p>Before</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) "send"(idx, A, ...) "compute"(idx)</p>
<p>After</p>
<p>affine.for i = 0 to #map(N) idx = affine.apply (d0) -&gt; (d0 mod 2) (i) "send"(idx, A, ...) idx_ = affine.apply (d0) -&gt; (d0 mod 2) (i) "compute"(idx_)</p>
<p>This allows applying different transformations on send and compute (for eg. different shifts/delays).</p>
<p>Returns nullptr either if none of opInst's operands were the result of an affine.apply and thus there was no affine computation slice to create, or if all the affine.apply op's supplying operands to this opInst did not have any uses besides this opInst; otherwise returns the list of affine.apply operations created in output argument <code>sliceOps</code>. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00322">322</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00589">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="Operation_8h_source.html#l00107">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00268">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="Operation_8h_source.html#l00207">mlir::Operation::getNumOperands()</a>, <a class="el" href="Operation_8h_source.html#l00222">mlir::Operation::getOperands()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00041">getReachableAffineApplyOps()</a>, and <a class="el" href="Operation_8h_source.html#l00210">mlir::Operation::setOperand()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00166">findMatchingStartFinishInsts()</a>.</p>

</div>
</div>
<a id="a98cb9c0e49f5bb8619655882e718b399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cb9c0e49f5bb8619655882e718b399">&#9670;&nbsp;</a></span>createAffineDataCopyGenerationPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createAffineDataCopyGenerationPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>slowMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>tagMemorySpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>minDmaTransferSize</em> = <code>1024</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>fastMemCapacityBytes</em> = <code>std::numeric_limits&lt;uint64_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs packing (or explicit copying) of accessed memref regions into buffers in the specified faster memory space through either pointwise copies or DMA operations. </p>
<p>Generates copies for memref's living in 'slowMemorySpace' into newly created buffers in 'fastMemorySpace', and replaces memory operations to the former by the latter.</p>
<p>Only load op's handled for now. TODO(bondhugula): extend this to store op's. </p>

<p class="definition">Definition at line <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00133">133</a> of file <a class="el" href="AffineDataCopyGeneration_8cpp_source.html">AffineDataCopyGeneration.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l01595">affineDataCopyGenerate()</a>, <a class="el" href="Block_8h_source.html#l00113">mlir::Block::begin()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="Block_8h_source.html#l00118">mlir::Block::empty()</a>, <a class="el" href="Block_8h_source.html#l00114">mlir::Block::end()</a>, <a class="el" href="OpDefinition_8h_source.html#l00134">mlir::OpState::getLoc()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00953">getMemoryFootprintBytes()</a>, <a class="el" href="AffineDataCopyGeneration_8cpp.html#a8ed4f1676584ff3d3c46a622046e76b4">pass</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00110">promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

</div>
</div>
<a id="abfb99f776bb27d84686308adc69cff56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb99f776bb27d84686308adc69cff56">&#9670;&nbsp;</a></span>createAffineLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createAffineLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant instructions out of affine loop. </p>

<p class="definition">Definition at line <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00233">233</a> of file <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html">AffineLoopInvariantCodeMotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineLoopInvariantCodeMotion_8cpp.html#ac6c3921a9e0966117407de00c41ae899">pass</a>.</p>

</div>
</div>
<a id="aab0069355214b578476e81bc909f7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0069355214b578476e81bc909f7f13">&#9670;&nbsp;</a></span>createCanonicalizerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCanonicalizerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an instance of the Canonicalizer pass. </p>
<p>Create a Canonicalizer pass. </p>

<p class="definition">Definition at line <a class="el" href="Canonicalizer_8cpp_source.html#l00040">40</a> of file <a class="el" href="Canonicalizer_8cpp_source.html">Canonicalizer.cpp</a>.</p>

<p class="reference">References <a class="el" href="Canonicalizer_8cpp.html#aee74fef1a689f2d04928b24394a52a35">pass</a>.</p>

</div>
</div>
<a id="a4e839c359226fcf9fc26cb51ba6c3282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e839c359226fcf9fc26cb51ba6c3282">&#9670;&nbsp;</a></span>createComposedAffineApplyOp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Operation.html">Operation</a>* mlir::createComposedAffineApplyOp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt;&#160;</td>
          <td class="paramname"><em>affineApplyOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and inserts into 'builder' a new <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>, with the number of its results equal to the number of operands, as a composition of all other AffineApplyOps reachable from input parameter 'operands'. </p>
<p>If different operands were drawing results from multiple affine apply ops, these will also be collected into a single (multi-result) affine apply op. The final results of the composed <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> are returned in output parameter 'results'. Returns the affine apply op created. </p>

</div>
</div>
<a id="a812eaea183edd3a043221352c421d456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a812eaea183edd3a043221352c421d456">&#9670;&nbsp;</a></span>createConvertGPUKernelToCubinPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createConvertGPUKernelToCubinPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ac778e98bba4a5f7b76ead3e1d37c6892">CubinGenerator</a>&#160;</td>
          <td class="paramname"><em>cubinGenerator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert kernel functions into CUBIN blobs. </p>
<p>This transformation takes the body of each function that is annotated with the 'nvvm.kernel' attribute, copies it to a new <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module, compiles the module with help of the nvptx backend to PTX and then invokes the provided cubinGenerator to produce a binary blob (the cubin). Such blob is then attached as a string attribute named 'nvvm.cubin' to the kernel function. After the transformation, the body of the kernel function is removed (i.e., it is turned into a declaration). </p>

<p class="definition">Definition at line <a class="el" href="ConvertKernelFuncToCubin_8cpp_source.html#l00158">158</a> of file <a class="el" href="ConvertKernelFuncToCubin_8cpp_source.html">ConvertKernelFuncToCubin.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertKernelFuncToCubin_8cpp.html#ae6a2c3fab8f6b38835c30af47175688e">pass</a>.</p>

</div>
</div>
<a id="ac6f00f1726e12db17c287b1d465a788f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f00f1726e12db17c287b1d465a788f">&#9670;&nbsp;</a></span>createConvertGpuLaunchFuncToCudaCallsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">mlir::OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">mlir::ModuleOp</a> &gt; &gt; mlir::createConvertGpuLaunchFuncToCudaCallsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert a gpu.launch_func operation into a sequence of CUDA calls. </p>
<p>This pass does not generate code to call CUDA directly but instead uses a small wrapper library that exports a stable and conveniently typed ABI on top of CUDA. </p>

<p class="definition">Definition at line <a class="el" href="ConvertLaunchFuncToCudaCalls_8cpp_source.html#l00417">417</a> of file <a class="el" href="ConvertLaunchFuncToCudaCalls_8cpp_source.html">ConvertLaunchFuncToCudaCalls.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLaunchFuncToCudaCalls_8cpp.html#a8c0a01db67c707f46f8870e22ba168ca">pass</a>.</p>

</div>
</div>
<a id="a69b936baa53d3e2755b359b551fa87aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b936baa53d3e2755b359b551fa87aa">&#9670;&nbsp;</a></span>createConvertGPUToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertGPUToSPIRVPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>workGroupSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert GPU Ops to SPIR-V ops. </p>
<p>Needs the workgroup size as input since SPIR-V/Vulkan requires the workgroup size to be statically specified. </p>

<p class="definition">Definition at line <a class="el" href="ConvertGPUToSPIRVPass_8cpp_source.html#l00088">88</a> of file <a class="el" href="ConvertGPUToSPIRVPass_8cpp_source.html">ConvertGPUToSPIRVPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertGPUToSPIRVPass_8cpp.html#a1e2a7b72c76bcb0a2c631ed3b1cebff7">pass</a>.</p>

</div>
</div>
<a id="afc91680386102b634b4bfacf2df8c8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc91680386102b634b4bfacf2df8c8cc">&#9670;&nbsp;</a></span>createConvertLinalgToAffineLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createConvertLinalgToAffineLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to affine.for loops and affine_load/affine_store accesses. </p>
<p>Placeholder for now, this is NYI. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLoops_8cpp_source.html#l00572">572</a> of file <a class="el" href="LinalgToLoops_8cpp_source.html">LinalgToLoops.cpp</a>.</p>

</div>
</div>
<a id="ad7217579d47066ee187bc2a14081ecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7217579d47066ee187bc2a14081ecd4">&#9670;&nbsp;</a></span>createConvertLinalgToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertLinalgToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLLVM_8cpp_source.html#l00594">594</a> of file <a class="el" href="LinalgToLLVM_8cpp_source.html">LinalgToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="LinalgToLLVM_8cpp.html#a329a1ab26fba1535e8c1bb5ad4f75cc1">pass</a>.</p>

</div>
</div>
<a id="a90fd26fef5b6a2fadc8bde27aaf33a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fd26fef5b6a2fadc8bde27aaf33a51">&#9670;&nbsp;</a></span>createConvertLinalgToLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createConvertLinalgToLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert Linalg operations to loop.for loops and std.load/std.store accesses. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLoops_8cpp_source.html#l00563">563</a> of file <a class="el" href="LinalgToLoops_8cpp_source.html">LinalgToLoops.cpp</a>.</p>

</div>
</div>
<a id="af42feeffcca4b155ef99c1ef00c1629a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af42feeffcca4b155ef99c1ef00c1629a">&#9670;&nbsp;</a></span>createConvertStandardToSPIRVPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createConvertStandardToSPIRVPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to convert StandardOps to SPIR-V ops. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToSPIRVPass_8cpp_source.html#l00049">49</a> of file <a class="el" href="ConvertStandardToSPIRVPass_8cpp_source.html">ConvertStandardToSPIRVPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToSPIRVPass_8cpp.html#a8f61aeac37ef79fa4b70448e31d6343e">pass</a>.</p>

</div>
</div>
<a id="a14895da9723acd9c7f910c2694ff9f65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14895da9723acd9c7f910c2694ff9f65">&#9670;&nbsp;</a></span>createCSEPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createCSEPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform common sub expression elimination. </p>

<p class="definition">Definition at line <a class="el" href="CSE_8cpp_source.html#l00261">261</a> of file <a class="el" href="CSE_8cpp_source.html">CSE.cpp</a>.</p>

<p class="reference">References <a class="el" href="CSE_8cpp.html#a82d08b1fea198256a354bfcbf81cc98f">pass</a>.</p>

</div>
</div>
<a id="a5055056389363fae93cf5b46fbca3461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5055056389363fae93cf5b46fbca3461">&#9670;&nbsp;</a></span>createGpuKernelOutliningPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createGpuKernelOutliningPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="KernelOutlining_8cpp_source.html#l00217">217</a> of file <a class="el" href="KernelOutlining_8cpp_source.html">KernelOutlining.cpp</a>.</p>

<p class="reference">References <a class="el" href="KernelOutlining_8cpp.html#ae00a107c4676d005ba89d5b686686b09">pass</a>.</p>

</div>
</div>
<a id="a6c6ad0644a283c257d1fbc15be6adc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6ad0644a283c257d1fbc15be6adc18">&#9670;&nbsp;</a></span>createInlinerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createInlinerPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which inlines calls and callable operations as defined by the <a class="el" href="classmlir_1_1CallGraph.html">CallGraph</a>. </p>

<p class="definition">Definition at line <a class="el" href="Inliner_8cpp_source.html#l00308">308</a> of file <a class="el" href="Inliner_8cpp_source.html">Inliner.cpp</a>.</p>

<p class="reference">References <a class="el" href="Inliner_8cpp.html#aebce9ad99b9be19254150478f5a7f0c7">pass</a>.</p>

</div>
</div>
<a id="a8665adb3fa2ac64504cfff30192ecb5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8665adb3fa2ac64504cfff30192ecb5e">&#9670;&nbsp;</a></span>createLegalizeStdOpsForSPIRVLoweringPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLegalizeStdOpsForSPIRVLoweringPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Pass.html" title="The abstract base pass class. ">Pass</a> to legalize ops that are not directly lowered to SPIR-V. </p>

<p class="definition">Definition at line <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00175">175</a> of file <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html">LegalizeStandardForSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="LegalizeStandardForSPIRV_8cpp.html#adb60e8d5f531b7e1ebdd8ab83bb068c8">pass</a>.</p>

</div>
</div>
<a id="a778dce592055d7ec8958e1a39f9e2034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778dce592055d7ec8958e1a39f9e2034">&#9670;&nbsp;</a></span>createLinalgFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLinalgFusionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Fusion_8cpp_source.html#l00361">361</a> of file <a class="el" href="Fusion_8cpp_source.html">Fusion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Fusion_8cpp.html#ad0819f564fa270da73ae13c1aef9cfd5">pass</a>.</p>

</div>
</div>
<a id="a93262dd909c3a67dd9b7729bbdd79df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93262dd909c3a67dd9b7729bbdd79df4">&#9670;&nbsp;</a></span>createLinalgPromotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLinalgPromotionPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamicBuffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Promotion_8cpp_source.html#l00243">243</a> of file <a class="el" href="Promotion_8cpp_source.html">Promotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="Promotion_8cpp.html#a40d3c3357ac6284e343b6882d3516dd4">clPromoteDynamic()</a>, and <a class="el" href="Promotion_8cpp.html#a2e9f48a6a24df2ebc002ee9c891eb894">pass</a>.</p>

</div>
</div>
<a id="a3871498529bc481fb04015cbe9a061dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3871498529bc481fb04015cbe9a061dd">&#9670;&nbsp;</a></span>createLinalgTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLinalgTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Tiling_8cpp_source.html#l00458">458</a> of file <a class="el" href="Tiling_8cpp_source.html">Tiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="Tiling_8cpp.html#ad19ff369d56ad3c73b1f33ffbf842744">clTileSizes()</a>, and <a class="el" href="Tiling_8cpp.html#a464ef588a6881f0d8dda99c8f6df198d">pass</a>.</p>

</div>
</div>
<a id="ae3ea711e3f9b9ce6bda6e8bd2258990a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ea711e3f9b9ce6bda6e8bd2258990a">&#9670;&nbsp;</a></span>createLoopCoalescingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLoopCoalescingPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that transforms perfectly nested loops with independent bounds into a single loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopCoalescing_8cpp_source.html#l00090">90</a> of file <a class="el" href="LoopCoalescing_8cpp_source.html">LoopCoalescing.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopCoalescing_8cpp_source.html#l00017">PASS_NAME</a>, and <a class="el" href="LoopCoalescing_8cpp.html#a330ef62cae576796f141c733ef3db249">reg</a>.</p>

</div>
</div>
<a id="a5bb36b083f70902a9546407beee0fa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb36b083f70902a9546407beee0fa50">&#9670;&nbsp;</a></span>createLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLoopFusionPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>fastMemorySpace</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>localBufSizeThreshold</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>maximalFusion</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop fusion pass which fuses loops. </p>
<p>Buffers of size less than or equal to <code>localBufSizeThreshold</code> are promoted to memory space `fastMemorySpace'. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusion_8cpp_source.html#l00106">106</a> of file <a class="el" href="LoopFusion_8cpp_source.html">LoopFusion.cpp</a>.</p>

</div>
</div>
<a id="a319fde65e573dbc3a947d58196cb2b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319fde65e573dbc3a947d58196cb2b3a">&#9670;&nbsp;</a></span>createLoopInvariantCodeMotionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLoopInvariantCodeMotionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop invariant code motion pass that hoists loop invariant instructions out of the loop. </p>

<p class="definition">Definition at line <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html#l00134">134</a> of file <a class="el" href="LoopInvariantCodeMotion_8cpp_source.html">LoopInvariantCodeMotion.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopInvariantCodeMotion_8cpp.html#ab27f3990a04ff0441e860f50e790fb54">pass</a>.</p>

</div>
</div>
<a id="a5e2249f16df21768223748892a65b003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2249f16df21768223748892a65b003">&#9670;&nbsp;</a></span>createLoopTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLoopTilingPass </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>cacheSizeBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform tiling on loop nests. </p>
<p>Creates a pass to perform loop tiling on all suitable loop nests of a Function.</p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00076">76</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

</div>
</div>
<a id="a13e5cd2cdbeaef2fc1810b52ce012b24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e5cd2cdbeaef2fc1810b52ce012b24">&#9670;&nbsp;</a></span>createLoopToGPUPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLoopToGPUPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>numWorkGroups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>workGroupSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that converts every loop operation within the body of the <a class="el" href="classmlir_1_1FuncOp.html" title="FuncOp represents a function, or an operation containing one region that forms a CFG(Control Flow Gra...">FuncOp</a> into a GPU launch. </p>
<p>The number of workgroups and workgroup size for the implementation is controlled by SSA values passed into conversion method. For testing, the values are set as constants obtained from a command line flag. See convertLoopToGPULaunch for a description of the required semantics of the converted loop operation. </p>

<p class="definition">Definition at line <a class="el" href="LoopsToGPUPass_8cpp_source.html#l00127">127</a> of file <a class="el" href="LoopsToGPUPass_8cpp_source.html">LoopsToGPUPass.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopsToGPUPass_8cpp.html#afd3d0c13f9e893accfc4191ab287796a">clNumBlockDims()</a>, <a class="el" href="LoopsToGPUPass_8cpp.html#ad30c5fb31bc00c6685bb328e86449798">clNumThreadDims()</a>, <a class="el" href="LoopsToGPUPass_8cpp.html#a8f239597cb6da7283e65f6994007bb2b">clNumWorkGroups()</a>, <a class="el" href="LoopsToGPUPass_8cpp.html#a554b7a6fab09e443852481150758dbd1">clWorkGroupSize()</a>, <a class="el" href="LoopsToGPUPass_8cpp_source.html#l00020">LOOPOP_TO_GPU_PASS_NAME</a>, <a class="el" href="LoopsToGPUPass_8cpp.html#a1963fa925df832b1a1b4c49ebde4ae23">loopOpToGPU</a>, <a class="el" href="LoopsToGPUPass_8cpp_source.html#l00019">PASS_NAME</a>, and <a class="el" href="LoopsToGPUPass_8cpp.html#a33dcdf15006c156ca671ae2e8ae3315f">registration</a>.</p>

</div>
</div>
<a id="a4dcc0952274a0c08c8d6ea76641b2cd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dcc0952274a0c08c8d6ea76641b2cd2">&#9670;&nbsp;</a></span>createLoopUnrollAndJamPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLoopUnrollAndJamPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unroll jam pass to unroll jam by the specified factor. </p>
<p>A factor of -1 lets the pass use the default factor or the one on the command line if provided. </p>

<p class="definition">Definition at line <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00077">77</a> of file <a class="el" href="LoopUnrollAndJam_8cpp_source.html">LoopUnrollAndJam.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUnrollAndJam_8cpp.html#a6ae3602c68a2d1b688e64ad9d28046be">clUnrollJamFactor()</a>, <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">loopUnrollJamByFactor()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

</div>
</div>
<a id="a6ff9a255aa02976b7a6c87ef31bb8bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff9a255aa02976b7a6c87ef31bb8bb1">&#9670;&nbsp;</a></span>createLoopUnrollPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLoopUnrollPass </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollFactor</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>unrollFull</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; unsigned(AffineForOp)&gt; &amp;&#160;</td>
          <td class="paramname"><em>getUnrollFactor</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a loop unrolling pass with the provided parameters. </p>
<p>'getUnrollFactor' is a function callback for clients to supply a function that computes an unroll factor - the callback takes precedence over unroll factors supplied through other means. If -1 is passed as the unrollFactor and no callback is provided, anything passed from the command-line (if at all) or the default unroll factor is used (LoopUnroll:kDefaultUnrollFactor). </p>

<p class="definition">Definition at line <a class="el" href="LoopUnroll_8cpp_source.html#l00174">174</a> of file <a class="el" href="LoopUnroll_8cpp_source.html">LoopUnroll.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>, and <a class="el" href="LoopUnroll_8cpp.html#a76e00da69886c1dabf7c0253c40dcd73">pass</a>.</p>

</div>
</div>
<a id="a6a200b8cbaeac5d7e3924c9cdd2003b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a200b8cbaeac5d7e3924c9cdd2003b9">&#9670;&nbsp;</a></span>createLowerAffinePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createLowerAffinePass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Lowers affine control flow operations (ForStmt, IfStmt and <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>) to equivalent lower-level constructs (flow of basic blocks and arithmetic primitives). </p>
<p>Lowers If and For operations within a function into their lower level CFG equivalent blocks.</p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00574">574</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineToStandard_8cpp.html#ae9ecd35f8113654cef063cb45f9d2a9d">pass</a>.</p>

</div>
</div>
<a id="a783d4bfe3cfba7dfe204f37dfc48b994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783d4bfe3cfba7dfe204f37dfc48b994">&#9670;&nbsp;</a></span>createLowerGpuOpsToNVVMOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToNVVMOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> counterparts. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00752">752</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LowerGpuOpsToNVVMOps_8cpp.html#af5e1faa671958fa8299d84dbe4860d85">pass</a>.</p>

</div>
</div>
<a id="afcd81a6ae73cd5c075caf6af24b13eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcd81a6ae73cd5c075caf6af24b13eff">&#9670;&nbsp;</a></span>createLowerGpuOpsToROCDLOpsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; gpu::GPUModuleOp &gt; &gt; mlir::createLowerGpuOpsToROCDLOpsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that lowers GPU dialect operations to <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> counterparts. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html#l00076">76</a> of file <a class="el" href="LowerGpuOpsToROCDLOps_8cpp_source.html">LowerGpuOpsToROCDLOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="LowerGpuOpsToROCDLOps_8cpp.html#a12262015577b904ec54928c2296014b5">pass</a>.</p>

</div>
</div>
<a id="aa7bcd86978ddc5c8c9eb55e995fa7d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bcd86978ddc5c8c9eb55e995fa7d69">&#9670;&nbsp;</a></span>createLowerToCFGPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1Pass.html">Pass</a> &gt; mlir::createLowerToCFGPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert loop.for, loop.if and loop.terminator ops to CFG. </p>

<p class="definition">Definition at line <a class="el" href="ConvertLoopToStandard_8cpp_source.html#l00263">263</a> of file <a class="el" href="ConvertLoopToStandard_8cpp_source.html">ConvertLoopToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertLoopToStandard_8cpp.html#aac2dd4d4d0bed37fb70f441d0a8487bd">pass</a>.</p>

</div>
</div>
<a id="a2cdd4bb3719cfea4b8c15e63476d9d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdd4bb3719cfea4b8c15e63476d9d39">&#9670;&nbsp;</a></span>createLowerToLLVMPass() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createLowerToLLVMPass </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloca</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert the Standard dialect into the LLVMIR dialect. </p>
<p>By default stdlib malloc/free are used for allocating MemRef payloads. Specifying <code>useAlloca-true</code> emits stack allocations instead. In the future this may become an enum when we have concrete uses for other options. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02259">2259</a> of file <a class="el" href="ConvertStandardToLLVM_8cpp_source.html">ConvertStandardToLLVM.cpp</a>.</p>

</div>
</div>
<a id="a912cc5d2766aefdccb2880236aee54bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a912cc5d2766aefdccb2880236aee54bb">&#9670;&nbsp;</a></span>createLowerToLLVMPass() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createLowerToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a021ec11591c1abe2294a6c0a9e5caa29">LLVMPatternListFiller</a>&#160;</td>
          <td class="paramname"><em>patternListFiller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#ab4a624defb326870761dd5923452a374">LLVMTypeConverterMaker</a>&#160;</td>
          <td class="paramname"><em>typeConverterMaker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloca</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert operations to the LLVMIR dialect. </p>
<p>The conversion is defined by a list of patterns and a type converter that will be obtained during the pass using the provided callbacks. By default stdlib malloc/free are used for allocating MemRef payloads. Specifying <code>useAlloca-true</code> emits stack allocations instead. In the future this may become an enum when we have concrete uses for other options. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02264">2264</a> of file <a class="el" href="ConvertStandardToLLVM_8cpp_source.html">ConvertStandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8cpp.html#a51000701d12412f4101d7873ff45a511">clUseAlloca()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02209">makeStandardToLLVMTypeConverter()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp.html#ac2d683efb4adeb1de3a8886d87436687">pass</a>, and <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02142">populateStdToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="af96088b7ac20f8219884aa02965be52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96088b7ac20f8219884aa02965be52e">&#9670;&nbsp;</a></span>createLowerToLLVMPass() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeConverter  = LLVMTypeConverter&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt;<a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a>&gt; &gt; mlir::createLowerToLLVMPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a021ec11591c1abe2294a6c0a9e5caa29">LLVMPatternListFiller</a>&#160;</td>
          <td class="paramname"><em>patternListFiller</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useAlloca</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to convert operations to the LLVMIR dialect. </p>
<p>The conversion is defined by a list of patterns obtained during the pass using the provided callback and an optional type conversion class, an instance is created during the pass. By default stdlib malloc/free are used for allocating MemRef payloads. Specifying <code>useAlloca-true</code> emits stack allocations instead. In the future this may become an enum when we have concrete uses for other options. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVMPass_8h_source.html#l00088">88</a> of file <a class="el" href="ConvertStandardToLLVMPass_8h_source.html">ConvertStandardToLLVMPass.h</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02021">ensureDistinctSuccessors()</a>.</p>

</div>
</div>
<a id="a491624870c7a589aca2f9d0f6eb9b8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491624870c7a589aca2f9d0f6eb9b8e4">&#9670;&nbsp;</a></span>createLowerVectorToLLVMPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; * mlir::createLowerVectorToLLVMPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert vector operations to the LLVMIR dialect. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00999">999</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertVectorToLLVM_8cpp.html#a9e018c6a718c64b6d641d944e2a78252">pass</a>.</p>

</div>
</div>
<a id="a67b0f1033aa9d5b5d3d199c3f94d742e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67b0f1033aa9d5b5d3d199c3f94d742e">&#9670;&nbsp;</a></span>createLowerVectorToLoopsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt;<a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a>&gt;* mlir::createLowerVectorToLoopsPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass to convert vector operations to affine loops + std dialect. </p>

</div>
</div>
<a id="a539dbb1cb2575bb342b0bb6d8e0637dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a539dbb1cb2575bb342b0bb6d8e0637dc">&#9670;&nbsp;</a></span>createMaterializeVectorsPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt;<a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a>&gt; &gt; mlir::createMaterializeVectorsPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>vectorSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to lower super-vectors to target-dependent HW vectors. </p>

</div>
</div>
<a id="afe4c6e0fa0595b4c4f3dc095fd0bda08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4c6e0fa0595b4c4f3dc095fd0bda08">&#9670;&nbsp;</a></span>createMemRefBoundCheckPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createMemRefBoundCheckPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to check memref accesses in a Function. </p>

<p class="definition">Definition at line <a class="el" href="MemRefBoundCheck_8cpp_source.html#l00038">38</a> of file <a class="el" href="MemRefBoundCheck_8cpp_source.html">MemRefBoundCheck.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00371">boundCheckLoadOrStoreOp()</a>, and <a class="el" href="MemRefBoundCheck_8cpp.html#a92f4ba3e901854a646d321bbda479831">memRefBoundCheck</a>.</p>

</div>
</div>
<a id="ac178054e409e714ae2909b390da1791c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac178054e409e714ae2909b390da1791c">&#9670;&nbsp;</a></span>createMemRefDataFlowOptPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createMemRefDataFlowOptPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to perform optimizations relying on memref dataflow such as store to load forwarding, elimination of dead stores, and dead allocs. </p>

<p class="definition">Definition at line <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00082">82</a> of file <a class="el" href="MemRefDataFlowOpt_8cpp_source.html">MemRefDataFlowOpt.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">checkMemrefAccessDependence()</a>, <a class="el" href="Operation_8cpp_source.html#l00501">mlir::Operation::erase()</a>, <a class="el" href="OpDefinition_8h_source.html#l00192">mlir::OpState::erase()</a>, <a class="el" href="AffineOps_8h_source.html#l00411">mlir::AffineLoadOp::getMemRef()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00864">getNestingDepth()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00894">getNumCommonSurroundingLoops()</a>, <a class="el" href="OpDefinition_8h_source.html#l00966">mlir::Op&lt; ConcreteType, Traits &gt;::getOperation()</a>, <a class="el" href="Value_8h_source.html#l00167">mlir::Value::getUsers()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00118">hasDependence()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp.html#af9073d5dfca846f867d2be71ce01172f">pass</a>, <a class="el" href="OpDefinition_8h_source.html#l00590">mlir::OpTrait::OneResult&lt; ConcreteType &gt;::replaceAllUsesWith()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00214">mlir::OpState::walk()</a>.</p>

</div>
</div>
<a id="a3cce4c7ca75e0e63b1688053ba457aae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cce4c7ca75e0e63b1688053ba457aae">&#9670;&nbsp;</a></span>createParallelismDetectionTestPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createParallelismDetectionTestPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to test parallelism detection; emits note for parallel loops. </p>

<p class="definition">Definition at line <a class="el" href="TestParallelismDetection_8cpp_source.html#l00030">30</a> of file <a class="el" href="TestParallelismDetection_8cpp_source.html">TestParallelismDetection.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00973">isLoopParallel()</a>, <a class="el" href="TestParallelismDetection_8cpp.html#a39e8ad98a616cfb779d7a7c934e20d3e">pass</a>, and <a class="el" href="OpDefinition_8h_source.html#l00214">mlir::OpState::walk()</a>.</p>

</div>
</div>
<a id="a06c956d85f15888a0d54ab0242a225db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c956d85f15888a0d54ab0242a225db">&#9670;&nbsp;</a></span>createPipelineDataTransferPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createPipelineDataTransferPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to pipeline explicit movement of data across levels of the memory hierarchy. </p>

<p class="definition">Definition at line <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00043">43</a> of file <a class="el" href="PipelineDataTransfer_8cpp_source.html">PipelineDataTransfer.cpp</a>.</p>

</div>
</div>
<a id="a7db213aeba7a0131ac371f600c7eafb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db213aeba7a0131ac371f600c7eafb4">&#9670;&nbsp;</a></span>createPrintCFGGraphPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">mlir::OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">mlir::FuncOp</a> &gt; &gt; mlir::createPrintCFGGraphPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print CFG graphs. </p>

<p class="definition">Definition at line <a class="el" href="ViewRegionGraph_8cpp_source.html#l00079">79</a> of file <a class="el" href="ViewRegionGraph_8cpp_source.html">ViewRegionGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewRegionGraph_8cpp.html#a871bf430b13897ef8a9359f8d3b673cb">pass</a>.</p>

</div>
</div>
<a id="a95636a6bbea919685fd7df7ad79eb871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95636a6bbea919685fd7df7ad79eb871">&#9670;&nbsp;</a></span>createPrintOpGraphPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a> &gt; &gt; mlir::createPrintOpGraphPass </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>llvm::errs()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to print op graphs. </p>

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00160">160</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

<p class="reference">References <a class="el" href="ViewOpGraph_8cpp.html#a9890735f43ba3e121e3fa1ee05d3ddbc">pass</a>.</p>

</div>
</div>
<a id="a820e7febf74c59d4401b11a97a5c4a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820e7febf74c59d4401b11a97a5c4a09">&#9670;&nbsp;</a></span>createSimpleLoopsToGPUPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createSimpleLoopsToGPUPass </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numBlockDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numThreadDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pass that converts loop nests into GPU kernels. </p>
<p>It considers top-level affine.for and linalg.for operations as roots of loop nests and converts them to the gpu.launch operations if possible.</p>
<p>No check on the size of the block or grid, or on the validity of parallelization is performed, it is under the responsibility of the caller to strip-mine the loops and to perform the dependence analysis before calling the conversion. </p>

<p class="definition">Definition at line <a class="el" href="LoopsToGPUPass_8cpp_source.html#l00121">121</a> of file <a class="el" href="LoopsToGPUPass_8cpp_source.html">LoopsToGPUPass.cpp</a>.</p>

</div>
</div>
<a id="a358dc09e947c8db396c37ad2fd2f5091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a358dc09e947c8db396c37ad2fd2f5091">&#9670;&nbsp;</a></span>createSimpleParametricTilingPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt;<a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a>&gt; &gt; mlir::createSimpleParametricTilingPass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>outerLoopSizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass that performs parametric tiling so that the outermost loops have the given fixed number of iterations. </p>
<p>Assumes outermost loop nests are permutable. </p>

</div>
</div>
<a id="a4583061063ad5f5c6a88c2d8e3f0ca73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4583061063ad5f5c6a88c2d8e3f0ca73">&#9670;&nbsp;</a></span>createSimplifyAffineStructuresPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createSimplifyAffineStructuresPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a simplification pass for affine structures (maps and sets). </p>
<p>In addition, this pass also normalizes memrefs to have the trivial (identity) layout map. </p>

<p class="definition">Definition at line <a class="el" href="SimplifyAffineStructures_8cpp_source.html#l00080">80</a> of file <a class="el" href="SimplifyAffineStructures_8cpp_source.html">SimplifyAffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00277">mlir::Operation::getAttrs()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00390">normalizeMemRef()</a>, and <a class="el" href="SimplifyAffineStructures_8cpp.html#a8947a61390f90d0ae49ab34dbf8d71f3">pass</a>.</p>

</div>
</div>
<a id="ad742e91af4a7dfad42c161671f99455d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad742e91af4a7dfad42c161671f99455d">&#9670;&nbsp;</a></span>createStripDebugInfoPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createStripDebugInfoPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to strip debug information from a function. </p>

<p class="definition">Definition at line <a class="el" href="StripDebugInfo_8cpp_source.html#l00032">32</a> of file <a class="el" href="StripDebugInfo_8cpp_source.html">StripDebugInfo.cpp</a>.</p>

<p class="reference">References <a class="el" href="StripDebugInfo_8cpp.html#a8cf230da476730f0a69e77cd5b51d9a8">pass</a>.</p>

</div>
</div>
<a id="afaf83469154149385949bf86f4c3bbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf83469154149385949bf86f4c3bbde">&#9670;&nbsp;</a></span>createTestLoopFusionPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt;<a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a>&gt; &gt; mlir::createTestLoopFusionPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass which tests loop fusion utilities. </p>

</div>
</div>
<a id="a3f3afa4304b636b1d037fecee420e58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f3afa4304b636b1d037fecee420e58c">&#9670;&nbsp;</a></span>createTestMemRefDependenceCheckPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createTestMemRefDependenceCheckPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to check memref access dependences in a Function. </p>

<p class="definition">Definition at line <a class="el" href="TestMemRefDependenceCheck_8cpp_source.html#l00040">40</a> of file <a class="el" href="TestMemRefDependenceCheck_8cpp_source.html">TestMemRefDependenceCheck.cpp</a>.</p>

</div>
</div>
<a id="ac68232bc7e405404d5af982388420703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac68232bc7e405404d5af982388420703">&#9670;&nbsp;</a></span>createVectorizePass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt; <a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a> &gt; &gt; mlir::createVectorizePass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>virtualVectorSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to vectorize loops, operations and data types using a target-independent, n-D super-vector abstraction. </p>

<p class="definition">Definition at line <a class="el" href="Vectorize_8cpp_source.html#l01285">1285</a> of file <a class="el" href="Vectorize_8cpp_source.html">Vectorize.cpp</a>.</p>

<p class="reference">References <a class="el" href="Vectorize_8cpp.html#a8dce754dbf1fbce2a5498585d5133051">pass</a>.</p>

</div>
</div>
<a id="a642298e3d87f1699172c886060e7f2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a642298e3d87f1699172c886060e7f2f1">&#9670;&nbsp;</a></span>createVectorizerTestPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmlir_1_1OpPassBase.html">OpPassBase</a>&lt;<a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a>&gt; &gt; mlir::createVectorizerTestPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a pass to allow independent testing of vectorizer functionality with FileCheck. </p>

</div>
</div>
<a id="a6bc84cc9baea1d755e04cc705616c9b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bc84cc9baea1d755e04cc705616c9b1">&#9670;&nbsp;</a></span>debugString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string mlir::debugString </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DebugStringHelper_8h_source.html#l00027">27</a> of file <a class="el" href="DebugStringHelper_8h_source.html">DebugStringHelper.h</a>.</p>

</div>
</div>
<a id="a7dc425822a826dd76ea2e8185aeb9fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc425822a826dd76ea2e8185aeb9fab">&#9670;&nbsp;</a></span>defaultFilterFunction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::defaultFilterFunction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NestedMatcher_8h_source.html#l00091">91</a> of file <a class="el" href="NestedMatcher_8h_source.html">NestedMatcher.h</a>.</p>

</div>
</div>
<a id="a4e96b0c437652eb5a4890734bb6bcee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e96b0c437652eb5a4890734bb6bcee7">&#9670;&nbsp;</a></span>emitError() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit an error message using this location. </p>
<p>Emit an error message using this location. </p>

<p class="definition">Definition at line <a class="el" href="Diagnostics_8cpp_source.html#l00301">301</a> of file <a class="el" href="Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00371">boundCheckLoadOrStoreOp()</a>, <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00039">buildSequentialConstant()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00029">computeConversionSet()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00376">convertLinkageType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00270">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00036">deserializeModule()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00036">diag()</a>, <a class="el" href="Operation_8cpp_source.html#l00300">mlir::Operation::emitError()</a>, <a class="el" href="OpDefinition_8h_source.html#l00192">mlir::OpState::erase()</a>, <a class="el" href="Parser_8cpp_source.html#l01430">extractSymbolReference()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00099">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00318">mlir::MemRefType::getChecked()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00696">getElementPtrType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00460">getElementType()</a>, <a class="el" href="Lexer_8cpp_source.html#l00039">mlir::Lexer::getEncodedSourceLocation()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00542">getICmpPredicate()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00070">getInnermostElementType()</a>, <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00054">mlir::LLVMTypeConverter::getLLVMContext()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00248">getOrInsertBuiltinVariable()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00050">isFnEntryBlock()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00279">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00356">mlir::OpAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00568">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00138">mlir::DialectAsmParser::parseInteger()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00204">mlir::DialectAsmParser::parseKeyword()</a>, <a class="el" href="OpImplementation_8h_source.html#l00281">mlir::OpAsmParser::parseKeyword()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00150">mlir::DialectAsmParser::parseOptionalInteger()</a>, <a class="el" href="Parser_8cpp_source.html#l04761">parseSourceFile()</a>, <a class="el" href="Parser_8cpp_source.html#l00839">parseSymbol()</a>, <a class="el" href="OpImplementation_8h_source.html#l00394">mlir::OpAsmParser::parseSymbolName()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00308">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00368">processLinkage()</a>, <a class="el" href="OpImplementation_8h_source.html#l00479">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="Pass_8cpp_source.html#l00504">runWithCrashRecovery()</a>, <a class="el" href="UniformConstraints_8cpp_source.html#l00036">solveUniformType()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00816">translateLLVMIRToModule()</a>, <a class="el" href="InferQuantizedTypesPass_8cpp_source.html#l00099">validateTypeConversion()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l00680">verifyRegionAttribute()</a>.</p>

</div>
</div>
<a id="a2dc4e9418ff63ebea20c7f709ebcb0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc4e9418ff63ebea20c7f709ebcb0f8">&#9670;&nbsp;</a></span>emitError() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Diagnostics_8cpp_source.html#l00302">302</a> of file <a class="el" href="Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00280">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">Error</a>.</p>

<p class="reference">Referenced by <a class="el" href="Diagnostics_8h_source.html#l00481">emitOptionalError()</a>.</p>

</div>
</div>
<a id="affdaf0aee1c1669e8b822bf98297b85f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdaf0aee1c1669e8b822bf98297b85f">&#9670;&nbsp;</a></span>emitOptionalError()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overloads of the above emission functions that take an optionally null location. </p>
<p>If the location is null, no diagnostic is emitted and a failure is returned. Given that the provided location may be null, these methods take the diagnostic arguments directly instead of relying on the returned <a class="el" href="classmlir_1_1InFlightDiagnostic.html" title="This class represents a diagnostic that is inflight and set to be reported. ">InFlightDiagnostic</a>. </p>

<p class="definition">Definition at line <a class="el" href="Diagnostics_8h_source.html#l00481">481</a> of file <a class="el" href="Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8h_source.html#l00343">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00302">emitError()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StandardTypes_8cpp_source.html#l00236">checkTensorElementType()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00318">mlir::MemRefType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00026">mlir::quant::QuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00055">mlir::IntegerType::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00627">mlir::ComplexType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00217">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="Types_8cpp_source.html#l00074">mlir::OpaqueType::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00210">mlir::VectorType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00258">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00261">mlir::RankedTensorType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00221">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00315">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00320">mlir::OpaqueAttr::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00410">mlir::UnrankedMemRefType::verifyConstructionInvariants()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00208">verifyFloatTypeInvariants()</a>.</p>

</div>
</div>
<a id="ab27e629384a23b9991e36201d87de462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab27e629384a23b9991e36201d87de462">&#9670;&nbsp;</a></span>emitOptionalRemark()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Diagnostics_8h_source.html#l00493">493</a> of file <a class="el" href="Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8h_source.html#l00343">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00318">emitRemark()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>.</p>

</div>
</div>
<a id="a665c32efa8059ae855341f4946f7497c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665c32efa8059ae855341f4946f7497c">&#9670;&nbsp;</a></span>emitOptionalWarning()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::emitOptionalWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Diagnostics_8h_source.html#l00487">487</a> of file <a class="el" href="Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8h_source.html#l00343">mlir::InFlightDiagnostic::append()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00310">emitWarning()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>.</p>

</div>
</div>
<a id="a8a9ca6fe9d5aab498bf090db3e878c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9ca6fe9d5aab498bf090db3e878c87">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a remark message using this location. </p>
<p>Emit a remark message using this location. </p>

<p class="definition">Definition at line <a class="el" href="Diagnostics_8cpp_source.html#l00315">315</a> of file <a class="el" href="Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Operation_8cpp_source.html#l00329">mlir::Operation::emitRemark()</a>, <a class="el" href="OpDefinition_8h_source.html#l00192">mlir::OpState::erase()</a>, and <a class="el" href="UniformConstraints_8cpp_source.html#l00036">solveUniformType()</a>.</p>

</div>
</div>
<a id="a391c4b4ea9dc95fbcfbfdab8a49547a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391c4b4ea9dc95fbcfbfdab8a49547a3">&#9670;&nbsp;</a></span>emitRemark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitRemark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Diagnostics_8cpp_source.html#l00318">318</a> of file <a class="el" href="Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00280">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a91921ada405fd6ba65dff028df047cb6">Remark</a>.</p>

<p class="reference">Referenced by <a class="el" href="Diagnostics_8h_source.html#l00493">emitOptionalRemark()</a>.</p>

</div>
</div>
<a id="a0768c8a572dc71b0b00d57414b56b60d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0768c8a572dc71b0b00d57414b56b60d">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility method to emit a warning message using this location. </p>
<p>Emit a warning message using this location. </p>

<p class="definition">Definition at line <a class="el" href="Diagnostics_8cpp_source.html#l00307">307</a> of file <a class="el" href="Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00040">emitUniformPerLayerDequantize()</a>, <a class="el" href="Operation_8cpp_source.html#l00320">mlir::Operation::emitWarning()</a>, <a class="el" href="OpDefinition_8h_source.html#l00192">mlir::OpState::erase()</a>, and <a class="el" href="UniformConstraints_8cpp_source.html#l00036">solveUniformType()</a>.</p>

</div>
</div>
<a id="a5e96e5ea091fb5bea539cef6ea7c5624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e96e5ea091fb5bea539cef6ea7c5624">&#9670;&nbsp;</a></span>emitWarning() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1InFlightDiagnostic.html">InFlightDiagnostic</a> mlir::emitWarning </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Diagnostics_8cpp_source.html#l00310">310</a> of file <a class="el" href="Diagnostics_8cpp_source.html">Diagnostics.cpp</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00280">emitDiag()</a>, and <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a0eaadb4fcb48a0a0ed7bc9868be9fbaa">Warning</a>.</p>

<p class="reference">Referenced by <a class="el" href="Diagnostics_8h_source.html#l00487">emitOptionalWarning()</a>.</p>

</div>
</div>
<a id="aa85875ff18480bfcf5b02dcbccd2fea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85875ff18480bfcf5b02dcbccd2fea2">&#9670;&nbsp;</a></span>expandAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">mlir::Value</a> mlir::expandAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>dimValues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolValues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the given affine expression using standard arithmetic operations applied to the provided dimension and symbol values. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00211">211</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineToStandard_8cpp_source.html#l00219">expandAffineMap()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00287">lowerAffineUpperBound()</a>.</p>

</div>
</div>
<a id="a9e8c4b79892c7f2e59f2d7dd8b562b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8c4b79892c7f2e59f2d7dd8b562b9a">&#9670;&nbsp;</a></span>extractFixedOuterLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a3f0d45d0562d47acc2c42934ccbfea19">TileLoops</a> mlir::extractFixedOuterLoops </td>
          <td>(</td>
          <td class="paramtype">loop::ForOp&#160;</td>
          <td class="paramname"><em>rootFOrOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of standard for loops rooted at <code>rootForOp</code> by finding such parametric tile sizes that the outer loops have a fixed number of iterations as defined in <code>sizes</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00923">923</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00834">ceilDivPositive()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00354">getPerfectlyNestedLoopsImpl()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00786">tile()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00906">tryIsolateBands()</a>.</p>

</div>
</div>
<a id="a13093ebea6c814674ee1668daf5f81f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13093ebea6c814674ee1668daf5f81f8">&#9670;&nbsp;</a></span>extractForInductionVars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::extractForInductionVars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forInsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>ivs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extracts the induction variables from a list of AffineForOps and places them in the output argument <code>ivs</code>. </p>
<p>Extracts the induction variables from a list of AffineForOps and returns them.</p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01582">1582</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00161">mlir::MemRefRegion::compute()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01547">getFullMemRefAsRegion()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00091">getIndexSet()</a>, and <a class="el" href="LoopTiling_8cpp_source.html#l00177">tileCodeGen()</a>.</p>

</div>
</div>
<a id="aeec13ab4fb753865cdfd2699aa01c23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec13ab4fb753865cdfd2699aa01c23b">&#9670;&nbsp;</a></span>failed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::failed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> corresponds to a failure value. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00045">45</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00019">mlir::LogicalResult::Failure</a>, and <a class="el" href="structmlir_1_1LogicalResult.html#a367e2bef1a5e5122bc9d0484479a353a">mlir::LogicalResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">mlir::FlatAffineConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00811">mlir::FlatAffineConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01842">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00532">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="LoopTiling_8cpp_source.html#l00274">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01595">affineDataCopyGenerate()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00661">analyzeProfitability()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00371">boundCheckLoadOrStoreOp()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00191">canFuseLoops()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01005">canFuseSrcWhichWritesToLiveOut()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00145">checkLoopOpMappable()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">checkMemrefAccessDependence()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00177">compileAndExecuteSingleFloatReturnFunction()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">mlir::FlatAffineConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00161">mlir::MemRefRegion::compute()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">computeSliceUnion()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02077">mlir::FlatAffineConstraints::constantFoldIdRange()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01662">mlir::TypeConverter::convertBlockSignature()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00087">convertLinalgType()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00376">convertLinkageType()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00485">convertLoopNestToGPULaunch()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00504">convertLoopToGPULaunch()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00270">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01599">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01574">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="FoldUtils_8h_source.html#l00076">mlir::OperationFolder::create()</a>, <a class="el" href="PassOptions_8h_source.html#l00224">mlir::PassPipelineOptions&lt; EmptyPipelineOptions &gt;::createFromString()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00341">createLaunchFromOp()</a>, <a class="el" href="Deserializer_8cpp_source.html#l02415">mlir::spirv::deserialize()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00064">doubleBuffer()</a>, <a class="el" href="LinalgToLoops_8cpp_source.html#l00071">emitLoopRanges()</a>, <a class="el" href="Parser_8cpp_source.html#l01430">extractSymbolReference()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00166">findMatchingStartFinishInsts()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00334">mlir::FlatAffineConstraints::FlatAffineConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00311">mlir::AffineApplyOp::fold()</a>, <a class="el" href="Operation_8cpp_source.html#l00603">mlir::Operation::fold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01354">foldLoopBounds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00065">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT &gt;::getChecked()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00153">getElementPtr()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00696">getElementPtrType()</a>, <a class="el" href="OpDefinition_8h_source.html#l01044">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;::getFromOpaquePointer()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00113">getI64SubArray()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00542">getICmpPredicate()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00091">getIndexSet()</a>, <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00909">getMemoryFootprintBytes()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00523">getStridesAndOffset()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00043">getTypeNumBytes()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00024">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00279">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00156">inlineCallsInSCC()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00050">isFnEntryBlock()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00100">lowerEntryPointABIAttr()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02209">makeStandardToLLVMTypeConverter()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00966">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00390">normalizeMemRef()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00107">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="OpDefinition_8h_source.html#l00045">mlir::ParseResult::operator bool()</a>, <a class="el" href="Ops_8cpp_source.html#l02753">operator&lt;&lt;()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00373">parseAndVerify&lt; uint64_t &gt;()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseArgumentList()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00625">parseAttributions()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01153">parseBound()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00093">parseFunctionResultList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00952">parseGlobalOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00658">parseGPUFuncOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01173">parseLLVMFuncOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00150">mlir::DialectAsmParser::parseOptionalInteger()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00377">parsePassPipeline()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00143">parseQuantParams()</a>, <a class="el" href="Parser_8cpp_source.html#l04761">parseSourceFile()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00025">parseStorageType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00446">parseStructMemberDecorations()</a>, <a class="el" href="Parser_8cpp_source.html#l00839">parseSymbol()</a>, <a class="el" href="OpImplementation_8h_source.html#l00394">mlir::OpAsmParser::parseSymbolName()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00273">mlir::quant::QuantizationDialect::parseType()</a>, <a class="el" href="PassRegistry_8h_source.html#l00142">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00040">performActions()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00542">populateAffineToStdConversionPatterns()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00559">populateLinalgToLLVMConversionPatterns()</a>, <a class="el" href="ConvertLoopToStandard_8cpp_source.html#l00249">populateLoopToStdConversionPatterns()</a>, <a class="el" href="DecorateSPIRVCompositeTypeLayoutPass_8cpp_source.html#l00075">populateSPIRVLayoutInfoPatterns()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00955">populateVectorToLLVMConversionPatterns()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00134">mlir::detail::PassOptions::print()</a>, <a class="el" href="Pass_8cpp_source.html#l00052">mlir::Pass::printAsTextualPipeline()</a>, <a class="el" href="TranslateClParser_8cpp_source.html#l00031">printMLIROutput()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00368">processLinkage()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00218">replaceAllMemRefUsesWith()</a>, <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00061">resolveSourceIndices()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00107">roundTripModule()</a>, <a class="el" href="Pass_8cpp_source.html#l00230">mlir::OpPassManager::run()</a>, <a class="el" href="Pass_8cpp_source.html#l00369">mlir::detail::OpToOpPassAdaptor::runOnOperation()</a>, <a class="el" href="Pass_8cpp_source.html#l00408">mlir::detail::OpToOpPassAdaptorParallel::runOnOperation()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00074">serializeModule()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00446">mlir::UnrankedMemRefDescriptor::setMemRefDescPtr()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00021">splitAndProcessBuffer()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00502">topologicalSort()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00796">translateLLVMIRToModule()</a>, <a class="el" href="ModuleTranslation_8h_source.html#l00045">mlir::LLVM::ModuleTranslation::translateModule()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00336">mlir::OpBuilder::tryFold()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00075">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="InferQuantizedTypesPass_8cpp_source.html#l00099">validateTypeConversion()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00847">vectorizeAffineForOp()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00903">vectorizeLoopsAndLoadsRecursively()</a>, <a class="el" href="Vectorize_8cpp_source.html#l01153">vectorizeRootMatch()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01123">verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00773">verifyAttributions()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00217">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00258">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00221">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00315">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00160">verifyFuncArgsGeneric()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00231">verifyGenericOp()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00049">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="OpDefinition_8h_source.html#l01016">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;::verifyInvariants()</a>, <a class="el" href="Operation_8cpp_source.html#l00971">mlir::OpTrait::impl::verifyIsTerminator()</a>, <a class="el" href="Operation_8cpp_source.html#l00891">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00858">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00915">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="Operation_8cpp_source.html#l00877">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00846">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00957">verifyTerminatorSuccessors()</a>, <a class="el" href="FunctionSupport_8h_source.html#l00369">mlir::OpTrait::FunctionLike&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00221">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::verifyTrait()</a>, and <a class="el" href="Serializer_8cpp_source.html#l00062">visitInPrettyBlockOrder()</a>.</p>

</div>
</div>
<a id="a07367c8c4a3d4a47a32bc2b9b7d8a3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07367c8c4a3d4a47a32bc2b9b7d8a3f4">&#9670;&nbsp;</a></span>failure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::failure </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isFailure</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>. </p>
<p>If isFailure is true a <code>failure</code> result is generated, otherwise a 'success' result is generated. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00032">32</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00019">mlir::LogicalResult::Failure</a>, and <a class="el" href="LogicalResult_8h_source.html#l00019">mlir::LogicalResult::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">mlir::FlatAffineConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01842">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00532">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00661">analyzeProfitability()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00371">boundCheckLoadOrStoreOp()</a>, <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">canonicalizeLoopBounds()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00145">checkLoopOpMappable()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00036">collectValidReferencesFor()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">mlir::FlatAffineConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00161">mlir::MemRefRegion::compute()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">computeSliceUnion()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00180">mlir::AffineMap::constantFold()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02064">mlir::FlatAffineConstraints::constantFoldId()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00485">convertLoopNestToGPULaunch()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00504">convertLoopToGPULaunch()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00270">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01599">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01562">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01574">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00341">createLaunchFromOp()</a>, <a class="el" href="Diagnostics_8h_source.html#l00481">emitOptionalError()</a>, <a class="el" href="Diagnostics_8h_source.html#l00493">emitOptionalRemark()</a>, <a class="el" href="Diagnostics_8h_source.html#l00487">emitOptionalWarning()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00479">extractStrides()</a>, <a class="el" href="Parser_8cpp_source.html#l01430">extractSymbolReference()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00076">extractValueFromConstOp()</a>, <a class="el" href="OpDefinition_8h_source.html#l00295">mlir::FoldingHook&lt; AffineDmaWaitOp, llvm::is_one_of&lt; OpTrait::OneResult&lt; AffineDmaWaitOp &gt;, OpTrait::VariadicOperands&lt; AffineDmaWaitOp &gt;... &gt;::value &gt;::fold()</a>, <a class="el" href="Operation_8cpp_source.html#l00603">mlir::Operation::fold()</a>, <a class="el" href="OpDefinition_8h_source.html#l00316">mlir::FoldingHook&lt; ConcreteType, isSingleResult, typename std::enable_if&lt; isSingleResult &gt;::type &gt;::foldHook()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01354">foldLoopBounds()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00068">getFlattenedAffineExprs()</a>, <a class="el" href="OpDefinition_8h_source.html#l01044">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;::getFromOpaquePointer()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00542">getICmpPredicate()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00091">getIndexSet()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00073">getInterfaceVariables()</a>, <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00523">getStridesAndOffset()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00864">hoistOpsBetween()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00024">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00279">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00156">inlineCallsInSCC()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00128">inlineRegion()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00050">isFnEntryBlock()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00410">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00384">loopUnrollFull()</a>, <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">loopUnrollJamByFactor()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00100">lowerEntryPointABIAttr()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00966">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00390">normalizeMemRef()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00107">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00167">mlir::Diagnostic::operator LogicalResult()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00175">mlir::InFlightDiagnostic::operator LogicalResult()</a>, <a class="el" href="Ops_8cpp_source.html#l02753">operator&lt;&lt;()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00799">mlir::detail::ParallelDiagnosticHandlerImpl::ParallelDiagnosticHandlerImpl()</a>, <a class="el" href="Module_8cpp_source.html#l00035">mlir::ModuleOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00238">mlir::AffineApplyOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01385">mlir::DmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00881">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01511">mlir::DmaWaitOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01029">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01773">mlir::AffineLoadOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01867">mlir::AffineStoreOp::parse()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00760">parseAccessChainOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00776">parseAddressOfOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01244">parseAffineForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01624">parseAffineIfOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01944">parseAffineMinOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02013">parseAffinePrefetchOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00130">parseAllocaOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00258">parseAllocOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseArgumentList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01355">parseAtomicBinOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01478">parseAtomicCmpXchgOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00910">parseAtomicCompareExchangeWeakOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01381">parseAtomicOrdering()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01418">parseAtomicRMWOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00530">parseAtomicUpdateOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00279">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00356">mlir::OpAsmParser::parseAttribute()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00625">parseAttributions()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00493">parseBitFieldExtractOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01022">parseBitFieldInsertOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01153">parseBound()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01096">parseBranchConditionalOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01070">parseBranchOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00625">parseBroadcastOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00650">parseBrOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00533">parseCallIndirectOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00304">parseCallOp()</a>, <a class="el" href="Operation_8cpp_source.html#l01104">mlir::impl::parseCastOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00775">parseCmpFOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00622">parseCmpIOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00055">parseCmpOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00568">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01183">parseCompositeConstructOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01262">parseCompositeExtractOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01322">parseCompositeInsertOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00934">parseCondBranchOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00676">parseCondBrOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01700">parseConstantMaskOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00815">parseConstantOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00075">parseContractionOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01519">parseControlBarrierOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01748">parseCreateMaskOp()</a>, <a class="el" href="Ops_8cpp_source.html#l01192">parseDeallocOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00177">parseDimAndSymbolList()</a>, <a class="el" href="Ops_8cpp_source.html#l01228">parseDimOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01555">parseEntryPointOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00107">parseEnumAttribute()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01616">parseExecutionModeOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00410">parseExtractElementOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00412">parseExtractOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00476">parseExtractSlicesOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00492">parseExtractValueOp()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00094">parseForOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00091">mlir::detail::PassOptions::parseFromString()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01657">parseFunctionCallOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00163">mlir::impl::parseFunctionLikeOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00093">parseFunctionResultList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00127">mlir::impl::parseFunctionSignature()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00071">parseGenericOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00171">parseGEPOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00952">parseGlobalOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01784">parseGlobalVariableOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00658">parseGPUFuncOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00828">parseGPUModuleOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01872">parseGroupNonUniformBallotOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01915">parseGroupNonUniformElectOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01947">parseGroupNonUniformIAddOp()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00174">parseIfOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00530">parseInsertElementOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00780">parseInsertOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00832">parseInsertSlicesOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00904">parseInsertStridedSliceOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00575">parseInsertValueOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00593">mlir::OpAsmParser::parseKeywordType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00373">parseLaunchOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00784">parseLinalgStructuredOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01173">parseLLVMFuncOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00225">parseLoadOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00641">parseLogicalBinaryOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00629">parseLogicalUnaryOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00142">parseMemoryAccessAttributes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02332">parseMemoryBarrierOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02391">parseModuleOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00592">parseNoIOOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01332">parseNullOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00108">parseNVVMMmaOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00065">parseNVVMShflSyncBflyOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00045">parseNVVMSpecialRegisterOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00090">parseNVVMVoteBallotOp()</a>, <a class="el" href="Operation_8cpp_source.html#l01064">mlir::impl::parseOneResultSameOperandTypeOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00934">parseOptionalLinkageKeyword()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01058">parseOuterProductOp()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00274">parseParallelOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00377">parsePassPipeline()</a>, <a class="el" href="Ops_8cpp_source.html#l01790">parsePrefetchOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01778">parsePrintOp()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00143">parseQuantParams()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00309">parseRangeOp()</a>, <a class="el" href="Ops_8cpp_source.html#l01852">parseRankOp()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00359">parseReduceOp()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00401">parseReduceReturnOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02531">parseReferenceOfOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00509">parseReshapeOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00718">parseReturnOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02582">parseReturnValueOp()</a>, <a class="el" href="ROCDLDialect_8cpp_source.html#l00044">parseROCDLOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00617">parseSelectOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00658">parseShiftOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00172">parseShuffleOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01058">parseShuffleVectorOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00344">parseSizeAssignment()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00596">parseSliceOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02926">parseSpecConstantOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02057">parseSplatOp()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00253">parseStoreOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01261">parseStridedSliceOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00446">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03034">parseSubgroupBallotKHROp()</a>, <a class="el" href="Ops_8cpp_source.html#l02601">parseSubViewOp()</a>, <a class="el" href="Parser_8cpp_source.html#l00839">parseSymbol()</a>, <a class="el" href="Ops_8cpp_source.html#l02254">parseTensorLoadOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02277">parseTensorStoreOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01474">parseTransferReadOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01550">parseTransferWriteOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00677">parseTransposeOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01648">parseTupleGetOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01621">parseTupleOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00308">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00604">parseUnaryOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00745">parseUndefOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00300">parseVariableDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03092">parseVariableOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02316">parseViewOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00707">parseYieldOp()</a>, <a class="el" href="PassRegistry_8h_source.html#l00142">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="PassRegistry_8h_source.html#l00159">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00040">performActions()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00220">mlir::linalg::permuteGenericLinalgOpPrecondition()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00134">mlir::detail::PassOptions::print()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01672">print()</a>, <a class="el" href="Pass_8cpp_source.html#l00052">mlir::Pass::printAsTextualPipeline()</a>, <a class="el" href="TranslateClParser_8cpp_source.html#l00031">printMLIROutput()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00110">promoteIfSingleIteration()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00271">mlir::linalg::promoteSubviewsLinalgOpPrecondition()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">replaceAllMemRefUsesWith()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00689">replaceAllSymbolUsesImpl()</a>, <a class="el" href="OpImplementation_8h_source.html#l00468">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00061">resolveSourceIndices()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00107">roundTripModule()</a>, <a class="el" href="Pass_8cpp_source.html#l00230">mlir::OpPassManager::run()</a>, <a class="el" href="Pass_8cpp_source.html#l00504">runWithCrashRecovery()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00074">serializeModule()</a>, <a class="el" href="ToolUtilities_8cpp_source.html#l00021">splitAndProcessBuffer()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00053">mlir::linalg::tileAndFuseLinalgOpAndSetMarker()</a>, <a class="el" href="LoopTiling_8cpp_source.html#l00177">tileCodeGen()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00041">mlir::linalg::tileLinalgOpAndSetMarker()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00502">topologicalSort()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00024">translateModuleToLLVMIR()</a>, <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00068">translateModuleToNVVMIR()</a>, <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00077">translateModuleToROCDLIR()</a>, <a class="el" href="TranslateClParser_8cpp_source.html#l00038">mlir::TranslationParser::TranslationParser()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00336">mlir::OpBuilder::tryFold()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00906">tryIsolateBands()</a>, <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00144">tryRewriteAffineAddEwIsomorphicSigned()</a>, <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00216">tryRewriteAffineMulEwSigned()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00075">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02744">mlir::FlatAffineConstraints::unionBoundingBox()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00847">vectorizeAffineForOp()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00161">mlir::linalg::vectorizeLinalgOpPrecondition()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00903">vectorizeLoopsAndLoadsRecursively()</a>, <a class="el" href="Vectorize_8cpp_source.html#l01109">vectorizeNonTerminals()</a>, <a class="el" href="Vectorize_8cpp_source.html#l01153">vectorizeRootMatch()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00704">mlir::SourceMgrDiagnosticVerifierHandler::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01123">verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00773">verifyAttributions()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00054">verifyCompatibleShape()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00217">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00258">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00221">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00315">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="Ops_8cpp_source.html#l02362">verifyDynamicStrides()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00231">verifyGenericOp()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00049">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="OpDefinition_8h_source.html#l01016">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;::verifyInvariants()</a>, <a class="el" href="Operation_8cpp_source.html#l00971">mlir::OpTrait::impl::verifyIsTerminator()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00046">mlir::gpu::GPUDialect::verifyOperationAttribute()</a>, <a class="el" href="Operation_8cpp_source.html#l00891">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00858">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00915">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="Operation_8cpp_source.html#l00877">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00846">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00957">verifyTerminatorSuccessors()</a>, <a class="el" href="FunctionSupport_8h_source.html#l00369">mlir::OpTrait::FunctionLike&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00221">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l00836">mlir::OpTrait::IsIsolatedFromAbove&lt; ConcreteType &gt;::verifyTrait()</a>, and <a class="el" href="Serializer_8cpp_source.html#l00062">visitInPrettyBlockOrder()</a>.</p>

</div>
</div>
<a id="a3983eab6c9a05efd28747c0e79dd9d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3983eab6c9a05efd28747c0e79dd9d44">&#9670;&nbsp;</a></span>floorDiv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::floorDiv </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the result of MLIR's floordiv operation on constants. </p>
<p>The RHS is expected to be positive. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00031">31</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00887">createPrivateMemRef()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02097">mlir::FlatAffineConstraints::getConstantBoundOnDimSize()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01186">mlir::FlatAffineConstraints::isEmptyByGCDTest()</a>, and <a class="el" href="AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="ab80da81dcbeeee5cc76ed25a83f10200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80da81dcbeeee5cc76ed25a83f10200">&#9670;&nbsp;</a></span>fullyComposeAffineMapAndOperands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::fullyComposeAffineMapAndOperands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an affine map <code>map</code> and its input <code>operands</code>, this method composes into <code>map</code>, maps of AffineApplyOps whose results are the values in <code>operands</code>, iteratively until no more of <code>operands</code> are the result of an <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>. </p>
<p>When this function returns, <code>map</code> becomes the composed affine map, and each <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in <code>operands</code> is guaranteed to be either a loop IV or a terminal symbol, i.e., a symbol defined at the top level or a block/function argument. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00589">589</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00578">composeAffineMapAndOperands()</a>, and <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01751">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00322">createAffineComputationSlice()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>, <a class="el" href="Dialect_2Linalg_2Utils_2Utils_8cpp_source.html#l00032">emitOrFoldComposedAffineApply()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00663">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00044">getCleanupLoopLowerBound()</a>, <a class="el" href="AffineOps_8h_source.html#l00505">mlir::AffineStoreOp::getOperationName()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">replaceAllMemRefUsesWith()</a>.</p>

</div>
</div>
<a id="a6e8a0f44c623301035b6151ca51cca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8a0f44c623301035b6151ca51cca4d">&#9670;&nbsp;</a></span>getAffineBinaryOpExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineBinaryOpExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133">AffineExprKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00045">45</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9baec211f7c20af43e742bf2570c3cb84f9">Add</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a30c212eb3184a5ed41f01a25c8124e8a">CeilDiv</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00520">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133abaa422535e7ce48b442cc07089e64e7a">FloorDiv</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00477">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a7aeb0277500c86e4aa6bd23f9a737942">Mod</a>, and <a class="el" href="namespacemlir.html#a6d3b7fd763c24274db6c115579084133a62b6d55816cf737bfc6f42e60df1a3f2">Mul</a>.</p>

<p class="reference">Referenced by <a class="el" href="SDBMExpr_8cpp_source.html#l00260">mlir::SDBMExpr::getAsAffineExpr()</a>, <a class="el" href="AffineExpr_8h_source.html#l00201">operator-()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00064">mlir::AffineExpr::replaceDimsAndSymbols()</a>.</p>

</div>
</div>
<a id="ab26cdced424aa629fde4150cc8674d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26cdced424aa629fde4150cc8674d50">&#9670;&nbsp;</a></span>getAffineConstantExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineConstantExpr </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>constant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00277">277</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bacb17869fe51048b5a5c4c6106551a255">Constant</a>, <a class="el" href="StorageUniquer_8h_source.html#l00126">mlir::StorageUniquer::get()</a>, and <a class="el" href="MLIRContext_8cpp_source.html#l00567">mlir::MLIRContext::getAffineUniquer()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00654">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00337">categorizeValueByAffineType()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00520">mlir::AffineExpr::ceilDiv()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01391">detectAsFloorDiv()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00477">mlir::AffineExpr::floorDiv()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00493">generateTransferOpSlices()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00252">mlir::Builder::getAffineConstantExpr()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00260">mlir::SDBMExpr::getAsAffineExpr()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00095">mlir::AffineMap::getConstantMap()</a>, <a class="el" href="IntegerSet_8h_source.html#l00054">mlir::IntegerSet::getEmptySet()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00523">getStridesAndOffset()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00430">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorAnalysis_8cpp_source.html#l00102">makePermutationMap()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00666">makeStridedLinearLayoutMap()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00567">mlir::AffineExpr::operator%()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00411">mlir::AffineExpr::operator*()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00351">mlir::AffineExpr::operator+()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00424">mlir::AffineExpr::operator-()</a>, <a class="el" href="AffineExpr_8h_source.html#l00201">operator-()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00273">mlir::AffineExpr::operator==()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00288">simplifyAdd()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00490">simplifyCeilDiv()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00434">simplifyFloorDiv()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00533">simplifyMod()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00364">simplifyMul()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00594">toAffineExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00742">mlir::SimpleAffineExprFlattener::visitConstantExpr()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00668">mlir::SimpleAffineExprFlattener::visitModExpr()</a>.</p>

</div>
</div>
<a id="addfd4323ef72147332661606b030d04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd4323ef72147332661606b030d04d">&#9670;&nbsp;</a></span>getAffineDimExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineDimExpr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>These free functions allow clients of the API to not use classes in detail. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00252">252</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9bab49b848e4bb608f4d5650e4b2817c641">DimId</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00241">getAffineDimOrSymbol()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineExpr_8h_source.html#l00277">mlir::detail::bindDims()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00654">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00611">canonicalizePromotedSymbols()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00337">categorizeValueByAffineType()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00225">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00311">mlir::AffineApplyOp::fold()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00493">generateTransferOpSlices()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00244">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00260">mlir::SDBMExpr::getAsAffineExpr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00273">getDimMap()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00114">mlir::AffineMap::getMultiDimIdentityMap()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00101">mlir::AffineMap::getPermutationMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00289">inversePermutation()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00216">mlir::AffineExpr::isFunctionOfDim()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00146">isMatmul()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00929">mlir::linalg::loopToOperandRangesMaps()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00895">makeAffineDimExprs()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00430">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="VectorAnalysis_8cpp_source.html#l00102">makePermutationMap()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00666">makeStridedLinearLayoutMap()</a>, <a class="el" href="AffineExpr_8h_source.html#l00201">operator-()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00387">promoteComposedSymbolsAsDims()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00594">toAffineExpr()</a>.</p>

</div>
</div>
<a id="aefb7ba5a55b4f16631528884d3617a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb7ba5a55b4f16631528884d3617a47">&#9670;&nbsp;</a></span>getAffineSymbolExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::getAffineSymbolExpr </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00262">262</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8cpp_source.html#l00241">getAffineDimOrSymbol()</a>, and <a class="el" href="namespacemlir.html#ae0a5f1311f5db69741663dd9e28a3c9baea00d3c6059a4ff11d351696747fc7ff">SymbolId</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00654">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00611">canonicalizePromotedSymbols()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00337">categorizeValueByAffineType()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00225">mlir::AffineMap::compose()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00311">mlir::AffineApplyOp::fold()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00248">mlir::Builder::getAffineSymbolExpr()</a>, <a class="el" href="SDBMExpr_8cpp_source.html#l00260">mlir::SDBMExpr::getAsAffineExpr()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00430">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00666">makeStridedLinearLayoutMap()</a>, <a class="el" href="AffineExpr_8h_source.html#l00201">operator-()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00387">promoteComposedSymbolsAsDims()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00594">toAffineExpr()</a>.</p>

</div>
</div>
<a id="ad50433d156c440b227ebae0e883d85a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50433d156c440b227ebae0e883d85a3">&#9670;&nbsp;</a></span>getAllIteratorTypeNames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt;StringRef&gt; mlir::getAllIteratorTypeNames </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has window semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">79</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8h_source.html#l00064">getParallelIteratorTypeName()</a>, <a class="el" href="StructuredOpsUtils_8h_source.html#l00069">getReductionIteratorTypeName()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00074">getWindowIteratorTypeName()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00087">getNumIterators()</a>.</p>

</div>
</div>
<a id="afe6d625c94bde77cc435c01814ceca49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6d625c94bde77cc435c01814ceca49">&#9670;&nbsp;</a></span>getArgsInAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getArgsInAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the <a class="el" href="classmlir_1_1IntegerAttr.html">IntegerAttr</a> which encodes the number of input buffer arguments. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00039">39</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a76fed7ca60dd96dc6cb59ac7439d4d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fed7ca60dd96dc6cb59ac7439d4d6a">&#9670;&nbsp;</a></span>getArgsOutAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getArgsOutAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the <a class="el" href="classmlir_1_1IntegerAttr.html">IntegerAttr</a> which encodes the number of input buffer arguments. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00045">45</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a40741d257063d17fe7e8da3ebea443a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40741d257063d17fe7e8da3ebea443a3">&#9670;&nbsp;</a></span>getBackwardSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getBackwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>backwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>backwardSlice</code> with the computed backward slice (i.e. </p>
<p>all the transitive defs of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at defs transitively, a operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForInst or the scope within an IfInst.</p>
<p>The implementation traverses the def chains in postorder traversal for efficiency reasons: if a operation is already in <code>backwardSlice</code>, no need to traverse its definitions again. Since useuse-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>backwardSlice</code> is filled with a postorder list of defs. This happens to be a topological order, from the point of view of the use-def chains.</p>
<h1>Example starting from node 8 </h1>
<p>1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order: {1, 2, 5, 3, 4, 6} </p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00080">getBackwardSliceImpl()</a>, and <a class="el" href="SliceAnalysis_8cpp_source.html#l00134">getSlice()</a>.</p>

</div>
</div>
<a id="a99e86ef5d27ed3a0aeb9895984c059de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e86ef5d27ed3a0aeb9895984c059de">&#9670;&nbsp;</a></span>getCleanupLoopLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getCleanupLoopLowerBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>unrollFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; *&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the cleanup loop lower bound of the loop being unrolled with the specified unroll factor; this bound will also be upper bound of the main part of the unrolled loop. </p>
<p>Computes the bound as an <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> with its operands or a null map when the trip count can't be expressed as an affine expression. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00044">44</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00129">mlir::StandardAttributes::AffineMap</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">buildTripCountMapAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00731">canonicalizeMapAndOperands()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00589">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00244">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00171">mlir::AffineMap::getResult()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00280">simplifyAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00410">loopUnrollByFactor()</a>, and <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a68dfa6bfaaa9a03dcbfdaeee28dc80ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dfa6bfaaa9a03dcbfdaeee28dc80ab">&#9670;&nbsp;</a></span>getComputationSliceState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getComputationSliceState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>depSourceOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>depSinkOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>dependenceConstraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isBackwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the computation slice loop bounds for one loop nest as affine maps of the other loop nest's IVs and symbols, using 'dependenceConstraints' computed between 'depSourceAccess' and 'depSinkAccess'. </p>
<p>If 'isBackwardSlice' is true, a backwards slice is computed in which the slice bounds of loop nest surrounding 'depSourceAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSinkAccess' at 'loopDepth'. If 'isBackwardSlice' is false, a forward slice is computed in which the slice bounds of loop nest surrounding 'depSinkAccess' are computed in terms of loop IVs and symbols of the loop nest surrounding 'depSourceAccess' at 'loopDepth'. The slice loop bounds and associated operands are returned in 'sliceState'. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">680</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00129">mlir::StandardAttributes::AffineMap</a>, <a class="el" href="Operation_8cpp_source.html#l00248">mlir::Operation::getContext()</a>, <a class="el" href="AffineStructures_8h_source.html#l00584">mlir::FlatAffineConstraints::getIdValue()</a>, <a class="el" href="AffineStructures_8h_source.html#l00591">mlir::FlatAffineConstraints::getIdValues()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00031">getLoopIVs()</a>, <a class="el" href="AffineStructures_8h_source.html#l00566">mlir::FlatAffineConstraints::getNumDimAndSymbolIds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00963">getSequentialLoops()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00068">mlir::ComputationSliceState::insertPoint</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00058">mlir::ComputationSliceState::ivs</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00675">kSliceFusionBarrierAttrName</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00064">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00060">mlir::ComputationSliceState::lbs</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02670">mlir::FlatAffineConstraints::projectOut()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00066">mlir::ComputationSliceState::ubOperands</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00062">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">computeSliceUnion()</a>.</p>

</div>
</div>
<a id="a61eaf936f054b483e983fa6be1cb27f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61eaf936f054b483e983fa6be1cb27f3">&#9670;&nbsp;</a></span>getComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::getComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the total cost of the loop nest rooted at 'forOp' using 'stats'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00404">404</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00304">getComputeCostHelper()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a8cdcd2c284243df5d427fcdfe4edde75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdcd2c284243df5d427fcdfe4edde75">&#9670;&nbsp;</a></span>getConstantTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt; mlir::getConstantTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the trip count of the loop if it's a constant, None otherwise. </p>
<p>This uses affine expression analysis and is able to determine constant trip count in non-trivial cases.</p>
<p>This method uses affine expression analysis (in turn using getTripCount) and is able to determine constant trip count in non-trivial cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">91</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">buildTripCountMapAndOperands()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00167">mlir::AffineMap::getResults()</a>, <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00274">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00367">buildSliceTripCountMap()</a>, <a class="el" href="LoopTiling_8cpp_source.html#l00101">constructTiledIndexSetHyperRect()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00166">findMatchingStartFinishInsts()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00252">getLoopNestStats()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00229">instBodySkew()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00410">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00384">loopUnrollFull()</a>, <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">loopUnrollJamByFactor()</a>, <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00105">loopUnrollJamUpToFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00398">loopUnrollUpToFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00110">promoteIfSingleIteration()</a>.</p>

</div>
</div>
<a id="a7a72abd84dcc66c8c890fc6c5e0d24f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a72abd84dcc66c8c890fc6c5e0d24f8">&#9670;&nbsp;</a></span>getDependenceComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getDependenceComponents </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="structmlir_1_1DependenceComponent.html">DependenceComponent</a>, 2 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>depCompsVec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'depCompsVec', dependence components for dependences between all load and store ops in loop nest rooted at 'forOp', at loop depths in range [1, maxLoopDepth]. </p>
<p>Gathers dependence components for dependences between all ops in loop nest rooted at 'forOp' at loop depths in range [1, maxLoopDepth].</p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00857">857</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">checkMemrefAccessDependence()</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00118">hasDependence()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8h_source.html#l00118">hasDependence()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00559">isValidLoopInterchangePermutation()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00592">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a3783be00e80b62134e4a1f6f6fccd376"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3783be00e80b62134e4a1f6f6fccd376">&#9670;&nbsp;</a></span>getDocAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getDocAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the <a class="el" href="classmlir_1_1StringAttr.html">StringAttr</a> which encodes an optional documentation string of the structured op. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00051">51</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a82686ceb29eb0f78b59e29021f1b2cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82686ceb29eb0f78b59e29021f1b2cdd">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00021">21</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00258">mlir::Type::dyn_cast()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Traits_8cpp_source.html#l00089">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00027">getElementTypeOrSelf()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00129">mlir::edsc::makeGenericLinalgOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02027">verify()</a>, <a class="el" href="Operation_8cpp_source.html#l00891">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00915">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, and <a class="el" href="Operation_8cpp_source.html#l00877">mlir::OpTrait::impl::verifySameOperandsElementType()</a>.</p>

</div>
</div>
<a id="a252aee27751e05d584d0b1a8e793ecf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a252aee27751e05d584d0b1a8e793ecf0">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the element type or return the type itself. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00031">31</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00021">getElementTypeOrSelf()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00043">mlir::Attribute::getType()</a>.</p>

</div>
</div>
<a id="ae81d443c449b61825fb2c2ec6aa90d35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81d443c449b61825fb2c2ec6aa90d35">&#9670;&nbsp;</a></span>getElementTypeOrSelf() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::getElementTypeOrSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00027">27</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="TypeUtilities_8cpp_source.html#l00021">getElementTypeOrSelf()</a>, and <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>.</p>

</div>
</div>
<a id="afe50d78867e8c7b15e7e481f931ca98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe50d78867e8c7b15e7e481f931ca98b">&#9670;&nbsp;</a></span>getFlattenedAffineExpr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getFlattenedAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>flattenedExpr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens 'expr' into 'flattenedExpr'. </p>
<p>Returns true on success or false if 'expr' could not be flattened (i.e., semi-affine is not yet handled). See documentation for AffineExprFlattener on how mod's and div's are flattened. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00889">889</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00115">getFlattenedAffineExprs()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00256">mlir::SimpleAffineExprFlattener::numDims</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00257">mlir::SimpleAffineExprFlattener::numSymbols</a>.</p>

</div>
</div>
<a id="a7746ab6b30038f20f1508c7821fa3052"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7746ab6b30038f20f1508c7821fa3052">&#9670;&nbsp;</a></span>getFlattenedAffineExpr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; *&#160;</td>
          <td class="paramname"><em>flattenedExpr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens 'expr' into 'flattenedExpr', which contains the coefficients of the dimensions, symbols, and additional variables that represent floor divisions of dimensions, symbols, and in turn other floor divisions. </p>
<p>Returns failure if 'expr' could not be flattened (i.e., semi-affine is not yet handled). 'cst' contains constraints that connect newly introduced local identifiers to existing dimensional and symbolic identifiers. See documentation for AffineExprFlattener on how mod's and div's are flattened. </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00102">102</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00115">getFlattenedAffineExprs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineExpr_8h_source.html#l00241">mlir::AffineExpr::cast()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00611">mlir::FlatAffineConstraints::setIdValues()</a>.</p>

</div>
</div>
<a id="a6da4e5105fe7664adb2d7c4f34bde6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da4e5105fe7664adb2d7c4f34bde6ae">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'. </p>
<p>Flattens the expressions in map.</p>
<p>Returns true on success or false if any expression in the map could not be flattened (i.e., semi-affine is not yet handled). For all affine expressions that share the same operands (like those of an affine map), this method should be used instead of repeatedly calling getFlattenedAffineExpr since local variables added to deal with div's and mod's will be reused across expressions.</p>
<p>Returns true on success or false if 'expr' was unable to be flattened (i.e., semi-affine expressions not handled yet). </p>

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00902">902</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8cpp_source.html#l00861">getFlattenedAffineExprs()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00167">mlir::AffineMap::getResults()</a>.</p>

</div>
</div>
<a id="a319408fd489397df5e58cb8193e5bfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319408fd489397df5e58cb8193e5bfcd">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00911">911</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8cpp_source.html#l00861">getFlattenedAffineExprs()</a>.</p>

</div>
</div>
<a id="ae54668e284d7e980f404164472f75c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54668e284d7e980f404164472f75c62">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>localVarCst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flattens the result expressions of the map to their corresponding flattened forms and set in 'flattenedExprs'. </p>
<p>Flattens the expressions in map.</p>
<p>Returns failure if any expression in the map could not be flattened (i.e., semi-affine is not yet handled). 'cst' contains constraints that connect newly introduced local identifiers to existing dimensional and / symbolic identifiers. See documentation for AffineExprFlattener on how mod's and div's are flattened. For all affine expressions that share the same operands (like those of an affine map), this method should be used instead of repeatedly calling getFlattenedAffineExpr since local variables added to deal with div's and mod's will be reused across expressions.</p>
<p>Returns failure if 'expr' was unable to be flattened (i.e., semi-affine expressions not handled yet). </p>

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00115">115</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00068">getFlattenedAffineExprs()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00167">mlir::AffineMap::getResults()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00367">mlir::FlatAffineConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01751">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineExpr_8h_source.html#l00241">mlir::AffineExpr::cast()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">mlir::FlatAffineConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00334">mlir::FlatAffineConstraints::FlatAffineConstraints()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00102">getFlattenedAffineExpr()</a>, and <a class="el" href="AffineStructures_8h_source.html#l00611">mlir::FlatAffineConstraints::setIdValues()</a>.</p>

</div>
</div>
<a id="a50f3de480d05c0d64fcc14fd29efde14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f3de480d05c0d64fcc14fd29efde14">&#9670;&nbsp;</a></span>getFlattenedAffineExprs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getFlattenedAffineExprs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 8 &gt;&gt; *&#160;</td>
          <td class="paramname"><em>flattenedExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>cst</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineStructures_8cpp_source.html#l00127">127</a> of file <a class="el" href="AffineStructures_8cpp_source.html">AffineStructures.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00068">getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00367">mlir::FlatAffineConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

</div>
</div>
<a id="a46bbb7497276c5ea7e8ed4ad1315bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46bbb7497276c5ea7e8ed4ad1315bf40">&#9670;&nbsp;</a></span>getFlattenedTypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classmlir_1_1Type.html">Type</a>, 10 &gt; mlir::getFlattenedTypes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TupleType.html">TupleType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the types within a nested Tuple. </p>
<p>A helper for the class method that handles storage concerns, which is tricky to do in tablegen. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00035">35</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8cpp_source.html#l00654">mlir::TupleType::getFlattenedTypes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StandardTypes_8h_source.html#l00491">mlir::TupleType::get()</a>.</p>

</div>
</div>
<a id="a95142edbf4c3eba444c22b6508d9a573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95142edbf4c3eba444c22b6508d9a573">&#9670;&nbsp;</a></span>getForInductionVarOwner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForOp mlir::loop::getForInductionVarOwner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the loop parent of an induction variable. </p>
<p>If the provided value is not an induction variable, then return nullptr. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01572">1572</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00083">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8h_source.html#l00243">mlir::BlockArgument::getOwner()</a>, <a class="el" href="Block_8cpp_source.html#l00036">mlir::Block::getParent()</a>, and <a class="el" href="Region_8cpp_source.html#l00041">mlir::Region::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00811">mlir::FlatAffineConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00367">buildSliceTripCountMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00161">mlir::MemRefRegion::compute()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00798">mlir::FlatAffineConstraints::convertLoopIVSymbolsToDims()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00080">getBackwardSliceImpl()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00537">getCommonBlock()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00515">getNumCommonLoops()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01566">isForInductionVar()</a>, <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00073">isOpLoopInvariant()</a>, and <a class="el" href="EDSC_2Builders_8cpp_source.html#l00172">mlir::edsc::LoopBuilder::makeAffine()</a>.</p>

</div>
</div>
<a id="ab3c9138cd38e82a78b5895b0e606d5d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c9138cd38e82a78b5895b0e606d5d6">&#9670;&nbsp;</a></span>getForwardSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getForwardSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; *&#160;</td>
          <td class="paramname"><em>forwardSlice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>filter</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;true;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fills <code>forwardSlice</code> with the computed forward slice (i.e. </p>
<p>all the transitive uses of op), <b>without</b> including that operation.</p>
<p>This additionally takes a TransitiveFilter which acts as a frontier: when looking at uses transitively, a operation that does not pass the filter is never propagated through. This allows in particular to carve out the scope within a ForInst or the scope within an IfInst.</p>
<p>The implementation traverses the use chains in postorder traversal for efficiency reasons: if a operation is already in <code>forwardSlice</code>, no need to traverse its uses again. Since use-def chains form a DAG, this terminates.</p>
<p>Upon return to the root call, <code>forwardSlice</code> is filled with a postorder list of uses (i.e. a reverse topological order). To get a proper topological order, we just just reverse the order in <code>forwardSlice</code> before returning.</p>
<h1>Example starting from node 0 </h1>
<pre class="fragment">          0
</pre><p> ___________|___________ 1 2 3 4 |_______| |______| | | | | 5 6 |___|_____________| | | 7 8 |_______________| | 9</p>
<p>Assuming all local orders match the numbering order:</p><ol type="1">
<li>after getting back to the root getForwardSlice, <code>forwardSlice</code> may contain: {9, 7, 8, 5, 1, 2, 6, 3, 4}</li>
<li>reversing the result of 1. gives: {4, 3, 6, 2, 1, 5, 8, 7, 9} </li>
</ol>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00031">getForwardSliceImpl()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00134">getSlice()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00864">hoistOpsBetween()</a>, and <a class="el" href="Vectorize_8cpp_source.html#l01109">vectorizeNonTerminals()</a>.</p>

</div>
</div>
<a id="a0ad4a4f2b9f799fb94f6ed67574a7130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ad4a4f2b9f799fb94f6ed67574a7130">&#9670;&nbsp;</a></span>getFunAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getFunAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the StrArrayAttr which encodes the SymbolAttr for the MLIR function that implements the body of the structured op. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00055">55</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l00071">parseGenericOp()</a>.</p>

</div>
</div>
<a id="a9370f018bc06e196d615cf7669d727fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9370f018bc06e196d615cf7669d727fe">&#9670;&nbsp;</a></span>getFusionComputeCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getFusionComputeCost </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>srcForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>srcStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>dstForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> &amp;&#160;</td>
          <td class="paramname"><em>dstStats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>slice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>computeCost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns in 'computeCost', the total compute cost of fusing the 'slice' of the loop nest rooted at 'srcForOp' into 'dstForOp'. </p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. Returns true on success, failure otherwise (e.g. non-constant trip counts).</p>
<p>Currently, the total cost is computed by counting the total operation instance count (i.e. total number of operations in the loop body * loop trip count) for the entire loop nest. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00415">415</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopFusionUtils_8cpp_source.html#l00367">buildSliceTripCountMap()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00304">getComputeCostHelper()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00031">getLoopIVs()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00353">getSliceIterationCount()</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00068">mlir::ComputationSliceState::insertPoint</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a8d8832a0e0699c7854b7844ea4a2cb06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8832a0e0699c7854b7844ea4a2cb06">&#9670;&nbsp;</a></span>getIndexingMapsAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getIndexingMapsAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the AffineArrayAttr which encodes the relationship between a structured op iterators' and its operands. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00027">27</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00056">mlir::vector::getVectorSubscriptAttr()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00235">mlir::linalg::permuteGenericLinalgOp()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00191">verify()</a>.</p>

</div>
</div>
<a id="a22708f1f7f952a54a86ec8ea10cc2e40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22708f1f7f952a54a86ec8ea10cc2e40">&#9670;&nbsp;</a></span>getIndexSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getIndexSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FlatAffineConstraints.html">FlatAffineConstraints</a> *&#160;</td>
          <td class="paramname"><em>domain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a system of constraints with dimensional identifiers corresponding to the loop IVs of the forOps appearing in that order. </p>
<p>Bounds of the loop are used to add appropriate inequalities. Any symbols founds in the bound operands are added as symbols in the system. Returns failure for the yet unimplemented cases. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00091">91</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l00833">mlir::FlatAffineConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01582">extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00367">mlir::FlatAffineConstraints::reset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00111">getInstIndexSet()</a>, and <a class="el" href="LoopTiling_8cpp_source.html#l00177">tileCodeGen()</a>.</p>

</div>
</div>
<a id="a4243a75480867bb61c05aa5879d2a32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4243a75480867bb61c05aa5879d2a32f">&#9670;&nbsp;</a></span>getInvariantAccesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#a59d6aae8a616cd9d13c8b1edb1095948">DenseSet</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; mlir::getInvariantAccesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>iv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an induction variable <code>iv</code> of type AffineForOp and <code>indices</code> of type <a class="el" href="classmlir_1_1IndexType.html" title="Index is a special integer-like type with unknown platform-dependent bit width. ">IndexType</a>, returns the set of <code>indices</code> that are independent of <code>iv</code>. </p>
<p>Prerequisites (inherited from <code>isAccessInvariant</code> above):</p><ol type="1">
<li><code>iv</code> and <code>indices</code> of the proper type;</li>
<li>at most one affine.apply is reachable from each index in <code>indices</code>;</li>
</ol>
<p>Emits a note if it encounters a chain of affine.apply and conservatively those cases. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00191">191</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00167">isAccessIndexInvariant()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorAnalysis_8cpp_source.html#l00102">makePermutationMap()</a>.</p>

</div>
</div>
<a id="a0cd44bf7d517ba785af9e9412c7ca8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd44bf7d517ba785af9e9412c7ca8cc">&#9670;&nbsp;</a></span>getIteratorTypesAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getIteratorTypesAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the StrArrayAttr which encodes the type of a structured op's iterators. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00033">33</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorOps_8cpp_source.html#l00056">mlir::vector::getVectorSubscriptAttr()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00235">mlir::linalg::permuteGenericLinalgOp()</a>, and <a class="el" href="VectorOps_8cpp_source.html#l00191">verify()</a>.</p>

</div>
</div>
<a id="a8c3272c7e5d627a525a70f55fb93fb57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c3272c7e5d627a525a70f55fb93fb57">&#9670;&nbsp;</a></span>getLargestDivisorOfTripCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mlir::getLargestDivisorOfTripCount </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the greatest known integral divisor of the trip count. </p>
<p>Affine expression analysis is used (indirectly through getTripCount), and this method is thus able to determine non-trivial divisors. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00117">117</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00035">buildTripCountMapAndOperands()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00167">mlir::AffineMap::getResults()</a>, and <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00101">constructTiledIndexSetHyperRect()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00410">loopUnrollByFactor()</a>, and <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a807920d891bec3be4c57bc48ac72591a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807920d891bec3be4c57bc48ac72591a">&#9670;&nbsp;</a></span>getLibraryCallAttrName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getLibraryCallAttrName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classmlir_1_1Attribute.html" title="Attributes are known-constant values of operations and functions. ">Attribute</a> name for the StrArrayAttr which encodes the external library function that implements the structured op. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00059">59</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

</div>
</div>
<a id="a991e7b35354627941316244640aa4392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991e7b35354627941316244640aa4392">&#9670;&nbsp;</a></span>getLoopIVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getLoopIVs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; *&#160;</td>
          <td class="paramname"><em>loops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populates 'loops' with IVs of the loops surrounding 'op' ordered from the outermost 'affine.for' operation to the innermost one. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00031">31</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00265">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00161">mlir::MemRefRegion::compute()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01124">findHighestBlockForPlacement()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">getComputationSliceState()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01547">getFullMemRefAsRegion()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00415">getFusionComputeCost()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00491">getInnermostCommonLoopDepth()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00111">getInstIndexSet()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00092">getLastDependentOpInRange()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00894">getNumCommonSurroundingLoops()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00777">insertBackwardComputationSlice()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00113">isMemRefDereferencingOp()</a>, and <a class="el" href="AffineLoopInvariantCodeMotion_8cpp_source.html#l00073">isOpLoopInvariant()</a>.</p>

</div>
</div>
<a id="a1b8c56a4421761c1f8658aa16c292463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8c56a4421761c1f8658aa16c292463">&#9670;&nbsp;</a></span>getLoopNestStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::getLoopNestStats </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpRoot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LoopNestStats.html">LoopNestStats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect loop nest statistics (eg. </p>
<p>loop trip count and operation count) in 'stats' for loop nest rooted at 'forOp'. Returns true on success, returns false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopFusionUtils_8cpp_source.html#l00252">252</a> of file <a class="el" href="LoopFusionUtils_8cpp_source.html">LoopFusionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00044">mlir::WalkResult::advance()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, <a class="el" href="Visitors_8h_source.html#l00043">mlir::WalkResult::interrupt()</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00059">mlir::LoopNestStats::loopMap</a>, <a class="el" href="LoopFusionUtils_8h_source.html#l00061">mlir::LoopNestStats::opCountMap</a>, and <a class="el" href="LoopFusionUtils_8h_source.html#l00063">mlir::LoopNestStats::tripCountMap</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a1670cd81ab396ba425cd0063d516b9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1670cd81ab396ba425cd0063d516b9a9">&#9670;&nbsp;</a></span>getMemoryFootprintBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; int64_t &gt; mlir::getMemoryFootprintBytes </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memorySpace</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the memory footprint of all data touched in the specified memory space in bytes; if the memory space is unspecified, considers all memory spaces. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00953">953</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00909">getMemoryFootprintBytes()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00274">adjustToDivisorsOfTripCounts()</a>, <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00133">createAffineDataCopyGenerationPass()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a5bd0c019a961c60a1fd09225b7dcd3be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd0c019a961c60a1fd09225b7dcd3be">&#9670;&nbsp;</a></span>getMemRefSizeInBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; uint64_t &gt; mlir::getMemRefSizeInBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>memRefType</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the size of memref data in bytes if it's statically shaped, None otherwise. </p>
<p>If the element of the memref has vector type, takes into account size of the vector as well. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00356">356</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00312">getMemRefEltSizeInBytes()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>.</p>

</div>
</div>
<a id="ae005ef4690791c3f145f4efcfff38fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae005ef4690791c3f145f4efcfff38fb2">&#9670;&nbsp;</a></span>getNestingDepth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::getNestingDepth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the nesting depth of this operation, i.e., the number of loops surrounding this operation. </p>
<p>Returns the nesting depth of this statement, i.e., the number of loops surrounding this statement.</p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00864">864</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00265">mlir::Operation::getParentOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01595">affineDataCopyGenerate()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">computeSliceUnion()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00082">createMemRefDataFlowOptPass()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00909">getMemoryFootprintBytes()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>, and <a class="el" href="Analysis_2Utils_8cpp_source.html#l00973">isLoopParallel()</a>.</p>

</div>
</div>
<a id="af9ce1eb0663c1448ebc1bbeccc2b6bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ce1eb0663c1448ebc1bbeccc2b6bcf">&#9670;&nbsp;</a></span>getNumCommonSurroundingLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::getNumCommonSurroundingLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of surrounding loops common to both A and B. </p>
<p>Returns the number of surrounding loops common to 'loopsA' and 'loopsB', where each lists loops from outer-most to inner-most in loop nest.</p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00894">894</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00031">getLoopIVs()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusionUtils_8cpp_source.html#l00191">canFuseLoops()</a>, <a class="el" href="TestMemRefDependenceCheck_8cpp_source.html#l00076">checkDependences()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00082">createMemRefDataFlowOptPass()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00814">getMaxLoopDepth()</a>.</p>

</div>
</div>
<a id="a729f6e1552c6df7db231ce20f67947b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729f6e1552c6df7db231ce20f67947b2">&#9670;&nbsp;</a></span>getNumIterators() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::getNumIterators </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>&#160;</td>
          <td class="paramname"><em>iteratorTypes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the iterator of a certain type. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00087">87</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l01354">mlir::Attribute::cast()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">getAllIteratorTypeNames()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00096">getNumIterators()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00091">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::getNumLoops()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00076">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::getNumParallelLoops()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00081">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::getNumReductionLoops()</a>, and <a class="el" href="LinalgTraits_8h_source.html#l00086">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::getNumWindowLoops()</a>.</p>

</div>
</div>
<a id="a6d068f0cba2b5a92fe603c4118664b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d068f0cba2b5a92fe603c4118664b61">&#9670;&nbsp;</a></span>getNumIterators() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::getNumIterators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ArrayAttr.html">ArrayAttr</a>&#160;</td>
          <td class="paramname"><em>iteratorTypes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00096">96</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">References <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">getAllIteratorTypeNames()</a>, and <a class="el" href="StructuredOpsUtils_8h_source.html#l00087">getNumIterators()</a>.</p>

</div>
</div>
<a id="a73d505ce9a9e5eb2b9c03ec43cd97458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d505ce9a9e5eb2b9c03ec43cd97458">&#9670;&nbsp;</a></span>getParallelIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getParallelIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has parallel semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00064">64</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">getAllIteratorTypeNames()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00273">getDimMap()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00076">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::getNumParallelLoops()</a>, and <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00087">mlir::edsc::toString()</a>.</p>

</div>
</div>
<a id="a7cd53e808ea039aa9738dfab187468f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd53e808ea039aa9738dfab187468f8">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; AffineForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get perfectly nested sequence of loops starting at root of loop nest (the first op being another AffineFor, and the second op - a terminator). </p>
<p>A loop is perfectly nested iff: the first op in the loop's body is another AffineForOp, and the second op is a terminator). </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00373">373</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00354">getPerfectlyNestedLoopsImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00256">getTileableBands()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00592">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a8fb4801ba13af1fb78fe2894414fbb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb4801ba13af1fb78fe2894414fbb49">&#9670;&nbsp;</a></span>getPerfectlyNestedLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getPerfectlyNestedLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; loop::ForOp &gt; &amp;&#160;</td>
          <td class="paramname"><em>nestedLoops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loop::ForOp&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00378">378</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00354">getPerfectlyNestedLoopsImpl()</a>.</p>

</div>
</div>
<a id="a1522039bca148f6d365612eb404e0994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1522039bca148f6d365612eb404e0994">&#9670;&nbsp;</a></span>getReachableAffineApplyOps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getReachableAffineApplyOps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>affineApplyOps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in <code>affineApplyOps</code>, the sequence of those <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> Operations that are reachable via a search starting from <code>operands</code> and ending at those operands that are not the result of an <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a>. </p>
<p>Returns the sequence of <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> Operations operation in 'affineApplyOps', which are reachable via a search starting from 'operands', and ending at operands which are not defined by AffineApplyOps.</p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8cpp_source.html#l00041">41</a> of file <a class="el" href="AffineAnalysis_8cpp_source.html">AffineAnalysis.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00322">createAffineComputationSlice()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00166">findMatchingStartFinishInsts()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00167">isAccessIndexInvariant()</a>.</p>

</div>
</div>
<a id="a67c6c4d23ae5922c768383462ef7982f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c6c4d23ae5922c768383462ef7982f">&#9670;&nbsp;</a></span>getReductionIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getReductionIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has reduction semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00069">69</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">getAllIteratorTypeNames()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00273">getDimMap()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00081">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::getNumReductionLoops()</a>, and <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00087">mlir::edsc::toString()</a>.</p>

</div>
</div>
<a id="a4052bdb6ce4bde76e5de054805848162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4052bdb6ce4bde76e5de054805848162">&#9670;&nbsp;</a></span>getSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SmallDenseSet&lt; <a class="el" href="classmlir_1_1Value.html">Value</a>, 8 &gt; *&#160;</td>
          <td class="paramname"><em>sequentialLoops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns in 'sequentialLoops' all sequential loops in loop nest rooted at 'forOp'. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00963">963</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Analysis_2Utils_8cpp_source.html#l00973">isLoopParallel()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Analysis_2Utils_8cpp_source.html#l00680">getComputationSliceState()</a>.</p>

</div>
</div>
<a id="ae7beb62292ad20dc8c447387c371f9a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7beb62292ad20dc8c447387c371f9a2">&#9670;&nbsp;</a></span>getSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> * &gt; mlir::getSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>backwardFilter</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;true;&#160;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a389845a5dc285d746b24f6012a0ca2e3">TransitiveFilter</a>&#160;</td>
          <td class="paramname"><em>forwardFilter</em> = <code>[](<a class="el" href="classmlir_1_1Operation.html">Operation</a>&#160;*)&#160;{&#160;return&#160;true;&#160;}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iteratively computes backward slices and forward slices until a fixed point is reached. </p>
<p>Returns an <code>llvm::SetVector&lt;<a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a> *&gt;</code> which <b>includes</b> the original operation.</p>
<p>This allows building a slice (i.e. multi-root DAG where everything that is reachable from an <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> in forward and backward direction is contained in the slice). This is the abstraction we need to materialize all the operations for supervectorization without worrying about orderings and <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> replacements.</p>
<h1>Example starting from any node </h1>
<p>1 2 3 4 |_______| |______| | | | | | 5 6___| |___|_____________| | | | | 7 8 | |_______________| | | | 9 10</p>
<p>Return the whole DAG in some topological order.</p>
<p>The implementation works by just filling up a worklist with iterative alternate calls to <code>getBackwardSlice</code> and <code>getForwardSlice</code>.</p>
<p>The following section describes some additional implementation considerations for a potentially more efficient implementation but they are just an intuition without proof, we still use a worklist for now.</p>
<h1>Additional implementation considerations </h1>
<p>Consider the defs-op-uses hourglass. </p><hr/>
<p> \ / defs (in some topological order) \/ op /\ / \ uses (in some topological order) /____\</p>
<p>We want to iteratively apply <code>getSlice</code> to construct the whole list of <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a> that are reachable by (use|def)+ from op. We want the resulting slice in topological order. Ideally we would like the ordering to be maintained in-place to avoid copying <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a> at each step. Keeping this ordering by construction seems very unclear, so we list invariants in the hope of seeing whether useful properties pop up.</p>
<p>In the following: we use |= for set inclusion; we use &lt;&lt; for set topological ordering (i.e. each pair is ordered).</p>
<h1>Assumption: </h1>
<p>We wish to maintain the following property by a recursive argument: """ defs &lt;&lt; {op} &lt;&lt;uses are in topological order. """ The property clearly holds for 0 and 1-sized uses and defs;</p>
<p>Invariants:</p><ol type="1">
<li>defs and uses are in topological order internally, by construction;</li>
<li>for any {x} |= defs, defs(x) |= defs; because all go through op</li>
<li>for any {x} |= uses, defs |= defs(x); because all go through op</li>
<li>for any {x} |= defs, uses |= uses(x); because all go through op</li>
<li>for any {x} |= uses, uses(x) |= uses; because all go through op</li>
</ol>
<p>Intuitively, we should be able to recurse like: preorder(defs) - op - postorder(uses) and keep things ordered but this is still hand-wavy and not worth the trouble for now: punt to a simple worklist-based solution. </p>

<p class="definition">Definition at line <a class="el" href="SliceAnalysis_8cpp_source.html#l00134">134</a> of file <a class="el" href="SliceAnalysis_8cpp_source.html">SliceAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="namespacemlir.html#a40741d257063d17fe7e8da3ebea443a3">getBackwardSlice()</a>, <a class="el" href="namespacemlir.html#ab3c9138cd38e82a78b5895b0e606d5d6">getForwardSlice()</a>, and <a class="el" href="namespacemlir.html#a67f5deb263dc3ca56a8c5ae015cba4af">topologicalSort()</a>.</p>

</div>
</div>
<a id="a506c478f802ab2f874c0b34a18bc091b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506c478f802ab2f874c0b34a18bc091b">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the strides of the MemRef if the layout map is in strided form. </p>
<p>MemRefs with layout maps in strided form include:</p><ol type="1">
<li>empty or identity layout map, in which case the stride information is the canonical form computed from sizes;</li>
<li>single affine map layout of the form <code>K + k0 * d0 + ... kn * dn</code>, where K and ki's are constants or symbols.</li>
</ol>
<p>A stride specification is a list of integer values that are either static or dynamic (encoded with getDynamicStrideOrOffset()). Strides encode the distance in the number of elements between successive entries along a particular dimension. For example, <code>memref&lt;42x16xf32, (64 * d0 + d1)&gt;</code> specifies a view into a non-contiguous memory region of <code>42</code> by <code>16</code> <code>f32</code> elements in which the distance between two consecutive elements along the outer dimension is <code>1</code> and the distance between two consecutive elements along the inner dimension is <code>64</code>.</p>
<p>If a simple strided form cannot be extracted from the composition of the layout map, returns llvm::None.</p>
<p>The convention is that the strides for dimensions d0, .. dn appear in order to make indexing intuitive into the result. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00592">592</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8h_source.html#l00233">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="StandardTypes_8h_source.html#l00187">mlir::ShapedType::kDynamicStrideOrOffset</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l00387">computeReshapeCollapsedType()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00087">convertLinalgType()</a>, <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00153">getElementPtr()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00113">getI64SubArray()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00043">getTypeNumBytes()</a>, <a class="el" href="Ops_8cpp_source.html#l02559">inferSubViewResultType()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00734">isStrided()</a>, <a class="el" href="Ops_8cpp_source.html#l02753">operator&lt;&lt;()</a>, <a class="el" href="Ops_8cpp_source.html#l02341">print()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00446">mlir::UnrankedMemRefDescriptor::setMemRefDescPtr()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00524">verify()</a>.</p>

</div>
</div>
<a id="ab9d8af8a280cbdd7ffbf4629ee82ccc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d8af8a280cbdd7ffbf4629ee82ccc4">&#9670;&nbsp;</a></span>getStridesAndOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::getStridesAndOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In practice, a strided memref must be internally non-aliasing. Test against 0 as a proxy. TODO(ntv) static cases can have more advanced checks. TODO(ntv) dynamic cases would require a way to compare symbolic expressions and would probably need an affine set context propagated everywhere. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00523">523</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8cpp_source.html#l00479">extractStrides()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00277">getAffineConstantExpr()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00382">mlir::MemRefType::getAffineMaps()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00021">mlir::AffineExpr::getContext()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00171">mlir::AffineMap::getResult()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00380">mlir::MemRefType::getShape()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00125">mlir::AffineMap::isIdentity()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00430">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00839">simplifyAffineExpr()</a>, <a class="el" href="LogicalResult_8h_source.html#l00039">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StandardTypes_8h_source.html#l00528">mlir::NoneType::kindof()</a>.</p>

</div>
</div>
<a id="abb9b11fe741d1b8ed149d9b7c88ee1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9b11fe741d1b8ed149d9b7c88ee1a2">&#9670;&nbsp;</a></span>getTranslationFromMLIRRegistry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::StringMap&lt; <a class="el" href="namespacemlir.html#a13b54e61e2491e2bc91c54f8ef429cfa">TranslateFromMLIRFunction</a> &gt; &amp; mlir::getTranslationFromMLIRRegistry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Translation_8cpp_source.html#l00105">105</a> of file <a class="el" href="Translation_8cpp_source.html">Translation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Translation_8cpp_source.html#l00032">getMutableTranslationFromMLIRRegistry()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TranslateClParser_8cpp_source.html#l00038">mlir::TranslationParser::TranslationParser()</a>.</p>

</div>
</div>
<a id="a98cc980616f787ceaef19159104ac419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cc980616f787ceaef19159104ac419">&#9670;&nbsp;</a></span>getTranslationRegistry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::StringMap&lt; <a class="el" href="namespacemlir.html#addbb54b5d484b1a53b08f04871fb0da8">TranslateFunction</a> &gt; &amp; mlir::getTranslationRegistry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Translation_8cpp_source.html#l00109">109</a> of file <a class="el" href="Translation_8cpp_source.html">Translation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Translation_8cpp_source.html#l00039">getMutableTranslationRegistry()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TranslateClParser_8cpp_source.html#l00038">mlir::TranslationParser::TranslationParser()</a>.</p>

</div>
</div>
<a id="a631cb71a57000b8e9448317986781aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631cb71a57000b8e9448317986781aa4">&#9670;&nbsp;</a></span>getTranslationToMLIRRegistry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const llvm::StringMap&lt; <a class="el" href="namespacemlir.html#a16773901a5b8781f9be66507fad3c5b4">TranslateSourceMgrToMLIRFunction</a> &gt; &amp; mlir::getTranslationToMLIRRegistry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a read-only reference to the translator registry. </p>

<p class="definition">Definition at line <a class="el" href="Translation_8cpp_source.html#l00100">100</a> of file <a class="el" href="Translation_8cpp_source.html">Translation.cpp</a>.</p>

<p class="reference">References <a class="el" href="Translation_8cpp_source.html#l00024">getMutableTranslationToMLIRRegistry()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TranslateClParser_8cpp_source.html#l00038">mlir::TranslationParser::TranslationParser()</a>.</p>

</div>
</div>
<a id="a9f633b099c2b8b42235818ba7bb70bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f633b099c2b8b42235818ba7bb70bc0">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values defined at the ancestors of the <code>limit</code> region and used within <code>region</code> or its descendants. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00056">56</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00207">mlir::OpOperand::get()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00029">visitUsedValuesDefinedAbove()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00023">areValuesDefinedAbove()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00341">createLaunchFromOp()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00063">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="afdabf77e050b8d684e39d2e5c760a2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdabf77e050b8d684e39d2e5c760a2f0">&#9670;&nbsp;</a></span>getUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::getUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SetVector&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fill <code>values</code> with a list of values used within any of the regions provided but defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00063">63</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00056">getUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a9b1c2592f2447da69c493194bebeef37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1c2592f2447da69c493194bebeef37">&#9670;&nbsp;</a></span>getWindowIteratorTypeName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr StringLiteral mlir::getWindowIteratorTypeName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use to encode that a particular iterator type has window semantics. </p>

<p class="definition">Definition at line <a class="el" href="StructuredOpsUtils_8h_source.html#l00074">74</a> of file <a class="el" href="StructuredOpsUtils_8h_source.html">StructuredOpsUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="StructuredOpsUtils_8h_source.html#l00079">getAllIteratorTypeNames()</a>, and <a class="el" href="LinalgTraits_8h_source.html#l00086">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::getNumWindowLoops()</a>.</p>

</div>
</div>
<a id="a3e57462dce07886d882db84bbe3aa9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e57462dce07886d882db84bbe3aa9f1">&#9670;&nbsp;</a></span>has_single_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::has_single_element </td>
          <td>(</td>
          <td class="paramtype">ContainerTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true of the given range only contains a single element. </p>

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00337">337</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l01400">canonicalizeLoopBounds()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02182">hasOneBranchOpTo()</a>, <a class="el" href="UseDefLists_8h_source.html#l00149">mlir::IRMultiObjectWithUseList&lt; OpOperand &gt;::hasOneUse()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00136">insertCopies()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00076">mlir::SymbolTable::SymbolTable()</a>, <a class="el" href="Module_8cpp_source.html#l00072">mlir::ModuleOp::verify()</a>, <a class="el" href="Ops_8cpp_source.html#l00283">verify()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00277">mlir::OpTrait::impl::verifySymbolTable()</a>.</p>

</div>
</div>
<a id="a0139b17eb17bf529e630ec15f2051472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0139b17eb17bf529e630ec15f2051472">&#9670;&nbsp;</a></span>hasDependence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::hasDependence </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1DependenceResult.html">DependenceResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1DependenceResult.html" title="Checks whether two accesses to the same memref access the same element. ">DependenceResult</a> corresponds to a dependence result. </p>

<p class="definition">Definition at line <a class="el" href="AffineAnalysis_8h_source.html#l00118">118</a> of file <a class="el" href="AffineAnalysis_8h_source.html">AffineAnalysis.h</a>.</p>

<p class="reference">References <a class="el" href="AffineAnalysis_8cpp_source.html#l00857">getDependenceComponents()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00103">mlir::DependenceResult::HasDependence</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="TestMemRefDependenceCheck_8cpp_source.html#l00076">checkDependences()</a>, <a class="el" href="MemRefDataFlowOpt_8cpp_source.html#l00082">createMemRefDataFlowOptPass()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00857">getDependenceComponents()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00814">getMaxLoopDepth()</a>.</p>

</div>
</div>
<a id="a060d54dd4c592884f7bb771cbff354e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a060d54dd4c592884f7bb771cbff354e7">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00092">92</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00034">mlir::Identifier::strref()</a>.</p>

</div>
</div>
<a id="a655bb0e17a21ea2c35194f7c822c9ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655bb0e17a21ea2c35194f7c822c9ca5">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerSet.html">IntegerSet</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="IntegerSet_8h_source.html#l00114">114</a> of file <a class="el" href="IntegerSet_8h_source.html">IntegerSet.h</a>.</p>

</div>
</div>
<a id="a032c893ca9a2fff3b16e5a7cb6d413cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c893ca9a2fff3b16e5a7cb6d413cd">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineMap_8h_source.html#l00154">154</a> of file <a class="el" href="AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="AffineMap_8cpp_source.html#l00313">concatAffineMaps()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00289">inversePermutation()</a>, <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00280">simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="ad9141d8b586a68549d2ecaccbce99a69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9141d8b586a68549d2ecaccbce99a69">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpr_8h_source.html#l00195">195</a> of file <a class="el" href="AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8h_source.html#l00153">mlir::AffineExpr::expr</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00130">mlir::Type::classof()</a>, <a class="el" href="Location_8h_source.html#l00073">mlir::Location::dump()</a>, <a class="el" href="Attributes_8h_source.html#l00112">mlir::Attribute::getFromOpaquePointer()</a>, <a class="el" href="Value_8h_source.html#l00184">mlir::Value::getFromOpaquePointer()</a>, <a class="el" href="IntegerSet_8h_source.html#l00131">llvm::DenseMapInfo&lt; mlir::IntegerSet &gt;::getHashValue()</a>, <a class="el" href="Function_8h_source.html#l00168">llvm::DenseMapInfo&lt; mlir::FuncOp &gt;::getHashValue()</a>, <a class="el" href="AffineMap_8h_source.html#l00239">llvm::DenseMapInfo&lt; mlir::AffineMap &gt;::getHashValue()</a>, <a class="el" href="Types_8h_source.html#l00283">llvm::DenseMapInfo&lt; mlir::Type &gt;::getHashValue()</a>, <a class="el" href="AffineExpr_8h_source.html#l00304">llvm::DenseMapInfo&lt; mlir::AffineExpr &gt;::getHashValue()</a>, <a class="el" href="Location_8h_source.html#l00307">llvm::DenseMapInfo&lt; mlir::Location &gt;::getHashValue()</a>, <a class="el" href="Value_8h_source.html#l00322">llvm::DenseMapInfo&lt; mlir::Value &gt;::getHashValue()</a>, <a class="el" href="Value_8h_source.html#l00354">llvm::DenseMapInfo&lt; mlir::BlockArgument &gt;::getHashValue()</a>, <a class="el" href="Attributes_8h_source.html#l01430">llvm::DenseMapInfo&lt; mlir::Attribute &gt;::getHashValue()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00423">mlir::detail::DenseElementsAttributeStorage::getKey()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00469">mlir::detail::DenseElementsAttributeStorage::getKeyForBoolData()</a>, <a class="el" href="SDBMExpr_8h_source.html#l00128">mlir::SDBMExpr::hash_value()</a>, <a class="el" href="Location_8h_source.html#l00289">hash_value()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00077">mlir::detail::BoolAttributeStorage::hashKey()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00151">mlir::detail::FloatAttributeStorage::hashKey()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00214">mlir::detail::IntegerAttributeStorage::hashKey()</a>, <a class="el" href="AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>, <a class="el" href="AffineMap_8h_source.html#l00070">mlir::AffineMap::operator!=()</a>, and <a class="el" href="IntegerSet_8h_source.html#l00075">mlir::IntegerSet::operator==()</a>.</p>

</div>
</div>
<a id="ad93109842c1b05424c5052d9bd9a4394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93109842c1b05424c5052d9bd9a4394">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00250">250</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00225">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="a31eede9183d3fdae566e18d94a5ef51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eede9183d3fdae566e18d94a5ef51b">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00250">250</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00181">mlir::Type::impl</a>.</p>

</div>
</div>
<a id="aa6261878bc5197cfcc003e5b3fa735ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6261878bc5197cfcc003e5b3fa735ea">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00289">289</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8h_source.html#l00195">hash_value()</a>, and <a class="el" href="Location_8h_source.html#l00085">mlir::Location::impl</a>.</p>

</div>
</div>
<a id="ab710b1f6f21f3f35197575b609aae4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab710b1f6f21f3f35197575b609aae4b4">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> hashable. </p>

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00305">305</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00205">mlir::Value::ownerAndKind</a>.</p>

</div>
</div>
<a id="a68bae84b1d7cdba11b048d9af3478a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bae84b1d7cdba11b048d9af3478a07">&#9670;&nbsp;</a></span>hash_value() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">inline ::llvm::hash_code mlir::hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l01360">1360</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00119">mlir::Attribute::impl</a>.</p>

</div>
</div>
<a id="a51ea257fc0167ade93ef4d07cdd98af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ea257fc0167ade93ef4d07cdd98af8">&#9670;&nbsp;</a></span>initializeLLVMPasses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::initializeLLVMPasses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> passes that can be when running MLIR code using <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a>. </p>

<p class="definition">Definition at line <a class="el" href="OptUtils_8cpp_source.html#l00046">46</a> of file <a class="el" href="OptUtils_8cpp_source.html">OptUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00177">compileAndExecuteSingleFloatReturnFunction()</a>.</p>

</div>
</div>
<a id="afa82b2f82348c0eacc76f1c4a862a796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa82b2f82348c0eacc76f1c4a862a796">&#9670;&nbsp;</a></span>inlineCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineCall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallOpInterface&#160;</td>
          <td class="paramname"><em>call</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CallableOpInterface&#160;</td>
          <td class="paramname"><em>callable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a given region, 'src', of a callable operation, 'callable', into the location defined by the given call operation. </p>
<p>This function returns failure if inlining is not possible, success otherwise. On failure, no changes are made to the module. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'call' or spliced directly. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00279">279</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00049">mlir::Region::empty()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00054">mlir::Region::front()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="DialectInterface_8h_source.html#l00163">mlir::DialectInterfaceCollection&lt; InterfaceType &gt;::getInterfaceFor()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00246">mlir::BlockArgument::getType()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00128">inlineRegion()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00253">materializeConversion()</a>, <a class="el" href="Value_8cpp_source.html#l00111">mlir::Value::replaceAllUsesWith()</a>, <a class="el" href="Operation_8cpp_source.html#l00279">mlir::Operation::replaceUsesOfWith()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00254">mlir::OpBuilder::setInsertionPointAfter()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Inliner_8cpp_source.html#l00156">inlineCallsInSCC()</a>, and <a class="el" href="InliningUtils_8h_source.html#l00137">mlir::InlinerInterface::processInlinedBlocks()</a>.</p>

</div>
</div>
<a id="a0711a5bd6d0958ffd8e120249018415a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0711a5bd6d0958ffd8e120249018415a">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1BlockAndValueMapping.html">BlockAndValueMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function inlines a region, 'src', into another. </p>
<p>This function returns failure if it is not possible to inline this function. If the function returned failure, then no changes to the module have been made.</p>
<p>The provided 'inlinePoint' must be within a region, and corresponds to the location where the 'src' region should be inlined. 'mapping' contains any remapped operands that are used within the region, and <em>must</em> include remappings for the entry arguments to the region. 'resultsToReplace' corresponds to any results that should be replaced by terminators within the inlined region. 'inlineLoc' is an optional <a class="el" href="classmlir_1_1Location.html" title="This class defines the main interface for locations in MLIR and acts as a non-nullable wrapper around...">Location</a> that, if provided, will be used to update the inlined operations' location information. 'shouldCloneInlinedRegion' corresponds to whether the source region should be cloned into the 'inlinePoint' or spliced directly. </p>
<p>Handle the terminators for each of the new blocks. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00128">128</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8cpp_source.html#l00146">mlir::Block::addArgument()</a>, <a class="el" href="IR_2Region_8h_source.html#l00044">mlir::Region::begin()</a>, <a class="el" href="Block_8h_source.html#l00113">mlir::Block::begin()</a>, <a class="el" href="Region_8cpp_source.html#l00063">mlir::Region::cloneInto()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00040">mlir::BlockAndValueMapping::contains()</a>, <a class="el" href="IR_2Region_8h_source.html#l00049">mlir::Region::empty()</a>, <a class="el" href="IR_2Region_8h_source.html#l00045">mlir::Region::end()</a>, <a class="el" href="Block_8h_source.html#l00114">mlir::Block::end()</a>, <a class="el" href="Block_8cpp_source.html#l00064">mlir::Block::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00054">mlir::Region::front()</a>, <a class="el" href="Operation_8h_source.html#l00097">mlir::Operation::getBlock()</a>, <a class="el" href="IR_2Region_8h_source.html#l00038">mlir::Region::getBlocks()</a>, <a class="el" href="Block_8h_source.html#l00107">mlir::Block::getOperations()</a>, <a class="el" href="Block_8cpp_source.html#l00036">mlir::Block::getParent()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00083">mlir::InlinerInterface::handleTerminator()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00060">mlir::InlinerInterface::isLegalToInline()</a>, <a class="el" href="InliningUtils_8h_source.html#l00137">mlir::InlinerInterface::processInlinedBlocks()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00030">remapInlinedLocations()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00045">remapInlinedOperands()</a>, <a class="el" href="Block_8cpp_source.html#l00256">mlir::Block::splitBlock()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="InliningUtils_8cpp_source.html#l00279">inlineCall()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00221">inlineRegion()</a>, and <a class="el" href="InliningUtils_8h_source.html#l00137">mlir::InlinerInterface::processInlinedBlocks()</a>.</p>

</div>
</div>
<a id="a5e80dbab8ac36c2184b88ca5a9ebe0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e80dbab8ac36c2184b88ca5a9ebe0ae">&#9670;&nbsp;</a></span>inlineRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::inlineRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1InlinerInterface.html">InlinerInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>interface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>inlinePoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>inlinedOperands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>resultsToReplace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classmlir_1_1Location.html">Location</a> &gt;&#160;</td>
          <td class="paramname"><em>inlineLoc</em> = <code>llvm::None</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCloneInlinedRegion</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is an overload of the above 'inlineRegion' that allows for providing the set of operands ('inlinedOperands') that should be used in-favor of the region arguments when inlining. </p>

<p class="definition">Definition at line <a class="el" href="InliningUtils_8cpp_source.html#l00221">221</a> of file <a class="el" href="InliningUtils_8cpp_source.html">InliningUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Region_8h_source.html#l00049">mlir::Region::empty()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="IR_2Region_8h_source.html#l00054">mlir::Region::front()</a>, <a class="el" href="Value_8h_source.html#l00246">mlir::BlockArgument::getType()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00128">inlineRegion()</a>, and <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>.</p>

</div>
</div>
<a id="aa8c76f66345aba4e6cabb250bf7699c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c76f66345aba4e6cabb250bf7699c1">&#9670;&nbsp;</a></span>insertBackwardComputationSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::insertBackwardComputationSlice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>srcOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>dstOpInst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>dstLoopDepth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmlir_1_1ComputationSliceState.html">ComputationSliceState</a> *&#160;</td>
          <td class="paramname"><em>sliceState</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a clone of the computation contained in the loop nest surrounding 'srcOpInst', slices the iteration space of src loop based on slice bounds in 'sliceState', and inserts the computation slice at the beginning of the operation block of the loop at 'dstLoopDepth' in the loop nest surrounding 'dstOpInst'. </p>
<p>Creates a computation slice of the loop nest surrounding 'srcOpInst', updates the slice loop bounds with any non-null bound maps specified in 'sliceState', and inserts this slice into the loop nest surrounding 'dstOpInst' at loop depth 'dstLoopDepth'.</p>
<p>Returns the top-level loop of the computation slice on success, returns nullptr otherwise.</p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00777">777</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00300">mlir::Operation::emitError()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00432">findInstPosition()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00449">getInstAtPosition()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00031">getLoopIVs()</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00064">mlir::ComputationSliceState::lbOperands</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00060">mlir::ComputationSliceState::lbs</a>, <a class="el" href="Analysis_2Utils_8h_source.html#l00066">mlir::ComputationSliceState::ubOperands</a>, and <a class="el" href="Analysis_2Utils_8h_source.html#l00062">mlir::ComputationSliceState::ubs</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>.</p>

</div>
</div>
<a id="a16773aefb2757e351bd51059c6bcbfe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16773aefb2757e351bd51059c6bcbfe0">&#9670;&nbsp;</a></span>instBodySkew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::instBodySkew </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>shifts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unrollPrologueEpilogue</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Skew the operations in the body of a 'affine.for' operation with the specified operation-wise shifts. </p>
<p>The shifts are with respect to the original execution order, and are multiplied by the loop 'step' before being applied.</p>
<p>The shifts are with respect to the original execution order, and are multiplied by the loop 'step' before being applied. A shift of zero for each operation will lead to no change. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00229">229</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00167">generateLoop()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00355">isInstwiseShiftValid()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00384">loopUnrollFull()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00166">findMatchingStartFinishInsts()</a>.</p>

</div>
</div>
<a id="a9ff3713bf5c6762b9f8239a980ded85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff3713bf5c6762b9f8239a980ded85a">&#9670;&nbsp;</a></span>interchangeLoops() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::interchangeLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOpB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs loop interchange on 'forOpA' and 'forOpB'. </p>
<p>Performs loop interchange on 'forOpA' and 'forOpB', where 'forOpB' is nested within 'forOpA' as the only non-terminator operation in its block.</p>
<p>Requires that 'forOpA' and 'forOpB' are part of a perfectly nested sequence of loops.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00499">499</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00646">sinkLoop()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00592">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="ac8dee404eb41233de0e84a82c7082f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8dee404eb41233de0e84a82c7082f67">&#9670;&nbsp;</a></span>interchangeLoops() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned mlir::interchangeLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>loopPermMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs a sequence of loop interchanges on perfectly nested 'loops', as specified by permutation 'loopPermMap' (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' after the loop interchange). </p>
<p>Performs a sequence of loop interchanges of loops in perfectly nested sequence of loops in 'loops', as specified by permutation in 'loopPermMap'.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00572">572</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00646">sinkLoop()</a>.</p>

</div>
</div>
<a id="ae8a8aef862a81d9299c1444038b3e67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8a8aef862a81d9299c1444038b3e67f">&#9670;&nbsp;</a></span>interleave() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename UnaryFunctor , typename NullaryFunctor , typename  = typename std::enable_if&lt;              !std::is_constructible&lt;StringRef, UnaryFunctor&gt;::value &amp;&amp;              !std::is_constructible&lt;StringRef, NullaryFunctor&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::interleave </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&#160;</td>
          <td class="paramname"><em>each_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryFunctor&#160;</td>
          <td class="paramname"><em>between_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An STL-style algorithm similar to std::for_each that applies a second functor between every pair of elements. </p>
<p>This provides the control flow logic to, for example, print a comma-separated list: </p><div class="fragment"><div class="line"><a class="code" href="namespacemlir.html#ae8a8aef862a81d9299c1444038b3e67f">interleave</a>(names.begin(), names.end(),</div><div class="line">           [&amp;](StringRef name) { os &lt;&lt; name; },</div><div class="line">           [&amp;] { os &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>; });</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00043">43</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01019">appendMangledType()</a>, <a class="el" href="Diagnostics_8h_source.html#l00243">mlir::Diagnostic::appendRange()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l01040">mlir::linalg::generateLibraryCallName()</a>, <a class="el" href="STLExtras_8h_source.html#l00059">interleave()</a>, <a class="el" href="STLExtras_8h_source.html#l00081">interleaveComma()</a>, <a class="el" href="PassOptions_8h_source.html#l00162">mlir::detail::PassOptions::ListOption&lt; DataType &gt;::operator-&gt;()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00134">mlir::detail::PassOptions::print()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00345">printUniformQuantizedPerAxisType()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l00802">mlir::AsmState::~AsmState()</a>.</p>

</div>
</div>
<a id="a705fe42a16585f4416744194cf20ca3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705fe42a16585f4416744194cf20ca3b">&#9670;&nbsp;</a></span>interleave() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunctor , typename NullaryFunctor , typename  = typename std::enable_if&lt;              !std::is_constructible&lt;StringRef, UnaryFunctor&gt;::value &amp;&amp;              !std::is_constructible&lt;StringRef, NullaryFunctor&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::interleave </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&#160;</td>
          <td class="paramname"><em>each_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NullaryFunctor&#160;</td>
          <td class="paramname"><em>between_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00059">59</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l00043">interleave()</a>.</p>

</div>
</div>
<a id="a8f58a9799d63ae7c61ebc3e7826b27d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f58a9799d63ae7c61ebc3e7826b27d8">&#9670;&nbsp;</a></span>interleave() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunctor , typename raw_ostream , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::interleave </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&#160;</td>
          <td class="paramname"><em>each_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRef &amp;&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of interleave for the common case of string separator. </p>

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00067">67</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l00043">interleave()</a>.</p>

</div>
</div>
<a id="ad3fdcfac89fcbf9f678d791ad9897b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fdcfac89fcbf9f678d791ad9897b29">&#9670;&nbsp;</a></span>interleave() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename raw_ostream , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::interleave </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const StringRef &amp;&#160;</td>
          <td class="paramname"><em>separator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00073">73</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l00043">interleave()</a>.</p>

</div>
</div>
<a id="a201521de2339762c1c50305ae2aaa245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201521de2339762c1c50305ae2aaa245">&#9670;&nbsp;</a></span>interleaveComma() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename UnaryFunctor , typename raw_ostream , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::interleaveComma </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UnaryFunctor&#160;</td>
          <td class="paramname"><em>each_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00081">81</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l00043">interleave()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Pass_8cpp_source.html#l00355">mlir::detail::OpToOpPassAdaptorBase::getName()</a>, <a class="el" href="STLExtras_8h_source.html#l00087">interleaveComma()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00966">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="OpImplementation_8h_source.html#l00189">operator&lt;&lt;()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00584">print()</a>, <a class="el" href="Pass_8cpp_source.html#l00052">mlir::Pass::printAsTextualPipeline()</a>, <a class="el" href="Pass_8cpp_source.html#l00289">mlir::OpPassManager::printAsTextualPipeline()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00720">printAttributions()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01317">printDenseFloatElement()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01140">printElidedElementsAttr()</a>, <a class="el" href="OpImplementation_8h_source.html#l00112">mlir::OpAsmPrinter::printFunctionalType()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00211">printFunctionResultList()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00303">printLaunchOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00099">mlir::OpAsmPrinter::printOptionalArrowTypeList()</a>, <a class="el" href="Metadata_8cpp_source.html#l00018">mlir::quantizer::CAGUniformMetadata::printSummary()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l00802">mlir::AsmState::~AsmState()</a>.</p>

</div>
</div>
<a id="ab948853b9cc4777456a793ee58eed635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab948853b9cc4777456a793ee58eed635">&#9670;&nbsp;</a></span>interleaveComma() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container , typename raw_ostream , typename T  = detail::ValueOfRange&lt;Container&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::interleaveComma </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00087">87</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l00081">interleaveComma()</a>.</p>

</div>
</div>
<a id="a52b322818d83a2256d4e4391acbf78a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b322818d83a2256d4e4391acbf78a2">&#9670;&nbsp;</a></span>inversePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::inversePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a map of codomain to domain dimensions such that the first codomain dimension for a particular domain dimension is selected. </p>
<p>Returns an empty map if the input map is empty or if <code>map</code> is not invertible (i.e. <code>map</code> does not contain a subset that is a permutation of full domain rank).</p>
<p>Prerequisites:</p><ol type="1">
<li><code>map</code> has no symbols.</li>
</ol>
<p>Example 1:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d1, d0, d2, d1, d2, d1, d0)</div><div class="line">                  0       2   3</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div></div><!-- fragment --><p>Example 2:</p>
<div class="fragment"><div class="line">(d0, d1, d2) -&gt; (d1, d0 + d1, d0, d2, d1, d2, d1, d0)</div><div class="line">                  0            2   3</div></div><!-- fragment --><p>returns:</p>
<div class="fragment"><div class="line">(d0, d1, d2, d3, d4, d5, d6, d7) -&gt; (d2, d0, d3)</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="AffineMap_8cpp_source.html#l00289">289</a> of file <a class="el" href="AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00129">mlir::StandardAttributes::AffineMap</a>, <a class="el" href="AffineExpr_8h_source.html#l00233">mlir::AffineExpr::dyn_cast()</a>, <a class="el" href="Matchers_8h_source.html#l00180">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00252">getAffineDimExpr()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00167">mlir::AffineMap::getResults()</a>, and <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLoops_8cpp_source.html#l00071">emitLoopRanges()</a>, <a class="el" href="AffineMap_8h_source.html#l00154">hash_value()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00235">mlir::linalg::permuteGenericLinalgOp()</a>, <a class="el" href="Tiling_8cpp_source.html#l00311">mlir::linalg::tileLinalgOp()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00231">verifyGenericOp()</a>.</p>

</div>
</div>
<a id="a0dd391dd6c617912e9c5e70caa5fb513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd391dd6c617912e9c5e70caa5fb513">&#9670;&nbsp;</a></span>isForInductionVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isForInductionVar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns if the provided value is the induction variable of a AffineForOp. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l01566">1566</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01572">getForInductionVarOwner()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00811">mlir::FlatAffineConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00210">buildDimAndSymbolPositionMaps()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00515">getNumCommonLoops()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00167">isAccessIndexInvariant()</a>.</p>

</div>
</div>
<a id="a5cd425fb7a4b98fc6a1343e123a2217f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd425fb7a4b98fc6a1343e123a2217f">&#9670;&nbsp;</a></span>isInstwiseShiftValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isInstwiseShiftValid </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>shifts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks where SSA dominance would be violated if a for op's body operations are shifted by the specified shifts. </p>
<p>Checks whether SSA dominance would be violated if a for op's body operations are shifted by the specified shifts.</p>
<p>This method checks if a 'def' and all its uses have the same shift factor. </p>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00355">355</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00180">mlir::detail::enumerate()</a>, and <a class="el" href="Value_8h_source.html#l00167">mlir::Value::getUsers()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00166">findMatchingStartFinishInsts()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00229">instBodySkew()</a>.</p>

</div>
</div>
<a id="a0d9c4fc904589c35cd742b2f96393ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9c4fc904589c35cd742b2f96393ee2">&#9670;&nbsp;</a></span>isLoopParallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isLoopParallel </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if `forOp' is a parallel loop. </p>
<p>Returns true if 'forOp' is parallel. </p>

<p class="definition">Definition at line <a class="el" href="Analysis_2Utils_8cpp_source.html#l00973">973</a> of file <a class="el" href="Analysis_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Visitors_8h_source.html#l00044">mlir::WalkResult::advance()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00764">checkMemrefAccessDependence()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00864">getNestingDepth()</a>, <a class="el" href="Operation_8h_source.html#l00458">mlir::Operation::hasNoSideEffect()</a>, <a class="el" href="Visitors_8h_source.html#l00043">mlir::WalkResult::interrupt()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00104">mlir::DependenceResult::NoDependence</a>, and <a class="el" href="structmlir_1_1DependenceResult.html#a5c10fed021f68af23445caa363b7ff7c">mlir::DependenceResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="TestParallelismDetection_8cpp_source.html#l00030">createParallelismDetectionTestPass()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00963">getSequentialLoops()</a>, and <a class="el" href="Vectorize_8cpp_source.html#l01153">vectorizeRootMatch()</a>.</p>

</div>
</div>
<a id="a4bd6b581b08699ce79d3e9f820c1ade9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd6b581b08699ce79d3e9f820c1ade9">&#9670;&nbsp;</a></span>isOpaqueTypeWithName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isOpaqueTypeWithName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>dialect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>typeData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified type is an opaque type with the specified dialect and typeData. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00043">43</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00258">mlir::Type::dyn_cast()</a>.</p>

</div>
</div>
<a id="ad0c26bcf64137533f38f2cda9abd75af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c26bcf64137533f38f2cda9abd75af">&#9670;&nbsp;</a></span>isStrided()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isStrided </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MemRefType.html">MemRefType</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the layout for <code>t</code> is compatible with strided semantics. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00734">734</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8cpp_source.html#l00592">getStridesAndOffset()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00039">succeeded()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Helpers_8cpp_source.html#l00016">getMemRefSizes()</a>, <a class="el" href="Ops_8h_source.html#l00275">mlir::DmaStartOp::getNumElementsPerStride()</a>, <a class="el" href="AffineOps_8h_source.html#l00305">mlir::AffineDmaStartOp::getNumElementsPerStride()</a>, <a class="el" href="Ops_8h_source.html#l00269">mlir::DmaStartOp::getStride()</a>, <a class="el" href="AffineOps_8h_source.html#l00298">mlir::AffineDmaStartOp::getStride()</a>, <a class="el" href="StandardTypes_8h_source.html#l00528">mlir::NoneType::kindof()</a>, <a class="el" href="Ops_8cpp_source.html#l01385">mlir::DmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00881">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01365">mlir::DmaStartOp::print()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00859">mlir::AffineDmaStartOp::print()</a>, and <a class="el" href="DependenceAnalysis_8cpp_source.html#l00028">toStringRef()</a>.</p>

</div>
</div>
<a id="aa36b5164871eaf1d6423cd0a2eb4e4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa36b5164871eaf1d6423cd0a2eb4e4fd">&#9670;&nbsp;</a></span>isTopLevelValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isTopLevelValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A utility function to check if a value is defined at the top level of a function. </p>
<p>A value of index type defined at the top level is always a valid symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00109">109</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00083">mlir::Value::dyn_cast()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Operation_8cpp_source.html#l00261">mlir::Operation::getParentRegion()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00102">isFunctionRegion()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00811">mlir::FlatAffineConstraints::addInductionVarOrTerminalSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00157">isDimOpValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00118">isValidDim()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00179">isValidSymbol()</a>.</p>

</div>
</div>
<a id="a9e447f320894cc02bbaeff66dd31ccee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e447f320894cc02bbaeff66dd31ccee">&#9670;&nbsp;</a></span>isValidDim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidDim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a dimension id. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00118">118</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00089">mlir::Value::cast()</a>, <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">isFunctionRegion()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00030">mlir::Type::isIndex()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00109">isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="EDSC_2Builders_8cpp_source.html#l00337">categorizeValueByAffineType()</a>, <a class="el" href="AffineOps_8h_source.html#l00072">mlir::AffineApplyOp::getAffineMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00505">mlir::AffineStoreOp::getOperationName()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00202">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00299">mlir::AffineApplyOp::isValidDim()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">replaceAllMemRefUsesWith()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00213">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="aacd689ef70c61ee029b443673c78a04e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd689ef70c61ee029b443673c78a04e">&#9670;&nbsp;</a></span>isValidLoopInterchangePermutation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidLoopInterchangePermutation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>loops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>loopPermMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the loop interchange permutation 'loopPermMap', of the perfectly nested sequence of loops in 'loops', would violate dependences (loop 'i' in 'loops' is mapped to location 'j = 'loopPermMap[i]' in the interchange). </p>
<p>Checks if the loop interchange permutation 'loopPermMap' of the perfectly nested sequence of loops in 'loops' would violate dependences.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00559">559</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00524">checkLoopInterchangeDependences()</a>, and <a class="el" href="AffineAnalysis_8cpp_source.html#l00857">getDependenceComponents()</a>.</p>

</div>
</div>
<a id="a6f320624f15a47e5732c1142f99dc144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f320624f15a47e5732c1142f99dc144">&#9670;&nbsp;</a></span>isValidSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isValidSymbol </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a> can be used as a symbol. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00179">179</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00157">isDimOpValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00102">isFunctionRegion()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00030">mlir::Type::isIndex()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00109">isTopLevelValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00210">buildDimAndSymbolPositionMaps()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00611">canonicalizePromotedSymbols()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00337">categorizeValueByAffineType()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00161">mlir::MemRefRegion::compute()</a>, <a class="el" href="AffineOps_8h_source.html#l00072">mlir::AffineApplyOp::getAffineMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="AffineOps_8h_source.html#l00505">mlir::AffineStoreOp::getOperationName()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00245">initDependenceConstraints()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00144">isMemRefSizeValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00202">isValidAffineIndexOperand()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00306">mlir::AffineApplyOp::isValidSymbol()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00387">promoteComposedSymbolsAsDims()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">replaceAllMemRefUsesWith()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l00213">verifyDimAndSymbolIdentifiers()</a>.</p>

</div>
</div>
<a id="a76b6d2ee408bfc5909eb81779da3e0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b6d2ee408bfc5909eb81779da3e0f1">&#9670;&nbsp;</a></span>isVectorizableLoopBody() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorTransferMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable; i.e. </p>
<p>:</p><ol type="1">
<li>no conditionals are nested under the loop;</li>
<li>all nested load/stores are to scalar MemRefs. TODO(ntv): relax the no-conditionals restriction </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00345">345</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00283">isVectorizableLoopBodyWithOpCond()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Vectorize_8cpp_source.html#l00882">isVectorizableLoopPtrFactory()</a>, and <a class="el" href="Vectorize_8cpp_source.html#l01153">vectorizeRootMatch()</a>.</p>

</div>
</div>
<a id="ae13f2a9f8242f345de0163689c30304e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae13f2a9f8242f345de0163689c30304e">&#9670;&nbsp;</a></span>isVectorizableLoopBody() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::isVectorizableLoopBody </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>loop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>memRefDim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1NestedPattern.html">NestedPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>vectorTransferMatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks whether the loop is structurally vectorizable and that all the LoadOp and StoreOp matched have access indexing functions that are are either: </p>
<ol type="1">
<li>invariant along the loop induction variable created by 'loop';</li>
<li>varying along at most one memory dimension. If such a unique dimension is found, it is written into <code>memRefDim</code>. </li>
</ol>

<p class="definition">Definition at line <a class="el" href="LoopAnalysis_8cpp_source.html#l00334">334</a> of file <a class="el" href="LoopAnalysis_8cpp_source.html">LoopAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00222">isContiguousAccess()</a>, and <a class="el" href="LoopAnalysis_8cpp_source.html#l00283">isVectorizableLoopBodyWithOpCond()</a>.</p>

</div>
</div>
<a id="a75d1b07f83032b4bccf115a648e0f907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d1b07f83032b4bccf115a648e0f907">&#9670;&nbsp;</a></span>JitRunnerMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mlir::JitRunnerMain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1function__ref.html">llvm::function_ref</a>&lt; <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>(<a class="el" href="classmlir_1_1ModuleOp.html">mlir::ModuleOp</a>)&gt;&#160;</td>
          <td class="paramname"><em>mlirTransformer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00177">compileAndExecuteSingleFloatReturnFunction()</a>.</p>

</div>
</div>
<a id="a5f7a5c72c1e0e867f3aac796b26ec2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f7a5c72c1e0e867f3aac796b26ec2aa">&#9670;&nbsp;</a></span>lcm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::lcm </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the least common multiple of 'a' and 'b'. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00047">47</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00992">eliminateFromConstraint()</a>, and <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>.</p>

</div>
</div>
<a id="a69f3012781c34e4c455dcb89956d7983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f3012781c34e4c455dcb89956d7983">&#9670;&nbsp;</a></span>loopUnrollByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation by the specified unroll factor. </p>
<p>Unrolls this loop by the specified factor.</p>
<p>Returns failure if the loop cannot be unrolled either due to restrictions or due to invalid unroll factors.</p>
<p>Returns success if the loop is successfully unrolled. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00410">410</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00356">mlir::OpBuilder::clone()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00244">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="Operation_8h_source.html#l00097">mlir::Operation::getBlock()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00044">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00117">getLargestDivisorOfTripCount()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00110">promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00384">loopUnrollFull()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00398">loopUnrollUpToFactor()</a>.</p>

</div>
</div>
<a id="ab9a5f6331a28a90f85a2d8498fd6f801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9a5f6331a28a90f85a2d8498fd6f801">&#9670;&nbsp;</a></span>loopUnrollFull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollFull </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this for operation completely if the trip count is known to be constant. </p>
<p>Unrolls this loop completely.</p>
<p>Returns failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00384">384</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00410">loopUnrollByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00110">promoteIfSingleIteration()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00229">instBodySkew()</a>.</p>

</div>
</div>
<a id="ad67a63b71c0fe3f345278eab205e10a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67a63b71c0fe3f345278eab205e10a3">&#9670;&nbsp;</a></span>loopUnrollJamByFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollJamByFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor. </p>
<p>Returns success if the loop is successfully unroll-jammed. </p>

<p class="definition">Definition at line <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">116</a> of file <a class="el" href="LoopUnrollAndJam_8cpp_source.html">LoopUnrollAndJam.cpp</a>.</p>

<p class="reference">References <a class="el" href="Block_8h_source.html#l00113">mlir::Block::begin()</a>, <a class="el" href="Block_8h_source.html#l00114">mlir::Block::end()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00244">mlir::Builder::getAffineDimExpr()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00044">getCleanupLoopLowerBound()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00117">getLargestDivisorOfTripCount()</a>, <a class="el" href="Operation_8h_source.html#l00365">mlir::Operation::getRegions()</a>, <a class="el" href="BlockAndValueMapping_8h_source.html#l00030">mlir::BlockAndValueMapping::map()</a>, <a class="el" href="LoopUnrollAndJam_8cpp.html#a4898622b1e98989abe0a725d362bab6f">pass</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00110">promoteIfSingleIteration()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00077">createLoopUnrollAndJamPass()</a>, and <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00105">loopUnrollJamUpToFactor()</a>.</p>

</div>
</div>
<a id="ac918847951e0d20706fe61380e119adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac918847951e0d20706fe61380e119adb">&#9670;&nbsp;</a></span>loopUnrollJamUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollJamUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollJamFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls and jams this loop by the specified factor or by the trip count (if constant), whichever is lower. </p>

<p class="definition">Definition at line <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00105">105</a> of file <a class="el" href="LoopUnrollAndJam_8cpp_source.html">LoopUnrollAndJam.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, and <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">loopUnrollJamByFactor()</a>.</p>

</div>
</div>
<a id="a4a6ed1cfcc6232ad7dae507d67db6462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6ed1cfcc6232ad7dae507d67db6462">&#9670;&nbsp;</a></span>loopUnrollUpToFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::loopUnrollUpToFactor </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>unrollFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unrolls this loop by the specified unroll factor or its trip count, whichever is lower. </p>
<p>Unrolls and jams this loop by the specified factor or by the trip count (if constant) whichever is lower.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00398">398</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00410">loopUnrollByFactor()</a>.</p>

</div>
</div>
<a id="afdf4bbbb9eb7a9678bd98d122b837cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf4bbbb9eb7a9678bd98d122b837cbd">&#9670;&nbsp;</a></span>lowerAffineLowerBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineLowerBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the lower bound of the given affine loop using standard arithmetic operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00264">264</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineToStandard_8cpp_source.html#l00246">buildMinMaxReductionSeq()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00219">expandAffineMap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopsToGPU_8cpp_source.html#l00078">getOrEmitLowerBound()</a>, and <a class="el" href="AffineToStandard_8cpp_source.html#l00287">lowerAffineUpperBound()</a>.</p>

</div>
</div>
<a id="a2d924b9762c352e82e8fe0fb1e222288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d924b9762c352e82e8fe0fb1e222288">&#9670;&nbsp;</a></span>lowerAffineUpperBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Value.html">Value</a> mlir::lowerAffineUpperBound </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit code that computes the upper bound of the given affine loop using standard arithmetic operations. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00287">287</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00265">mlir::PatternRewriter::create()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00091">mlir::PatternRewriter::eraseOp()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00211">expandAffineExpr()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00219">expandAffineMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00072">mlir::AffineApplyOp::getAffineMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00421">mlir::AffineLoadOp::getAffineMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00492">mlir::AffineStoreOp::getAffineMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00200">mlir::AffineDmaStartOp::getDstMap()</a>, <a class="el" href="Ops_8h_source.html#l00195">mlir::DmaStartOp::getDstMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00179">mlir::AffineDmaStartOp::getDstMemRefOperandIndex()</a>, <a class="el" href="OpDefinition_8h_source.html#l00134">mlir::OpState::getLoc()</a>, <a class="el" href="AffineOps_8h_source.html#l00418">mlir::AffineLoadOp::getMapOperands()</a>, <a class="el" href="AffineOps_8h_source.html#l00489">mlir::AffineStoreOp::getMapOperands()</a>, <a class="el" href="AffineOps_8h_source.html#l00411">mlir::AffineLoadOp::getMemRef()</a>, <a class="el" href="Ops_8h_source.html#l00215">mlir::DmaStartOp::getNumElements()</a>, <a class="el" href="Ops_8h_source.html#l00320">mlir::DmaWaitOp::getNumElements()</a>, <a class="el" href="Ops_8h_source.html#l00275">mlir::DmaStartOp::getNumElementsPerStride()</a>, <a class="el" href="OpDefinition_8h_source.html#l00438">mlir::OpTrait::detail::MultiOperandTraitBase&lt; ConcreteType, TraitType &gt;::getOperands()</a>, <a class="el" href="AffineOps_8h_source.html#l00161">mlir::AffineDmaStartOp::getSrcMap()</a>, <a class="el" href="Ops_8h_source.html#l00183">mlir::DmaStartOp::getSrcMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00149">mlir::AffineDmaStartOp::getSrcMemRefOperandIndex()</a>, <a class="el" href="Ops_8h_source.html#l00269">mlir::DmaStartOp::getStride()</a>, <a class="el" href="AffineOps_8h_source.html#l00348">mlir::AffineDmaWaitOp::getTagIndices()</a>, <a class="el" href="AffineOps_8h_source.html#l00229">mlir::AffineDmaStartOp::getTagMap()</a>, <a class="el" href="AffineOps_8h_source.html#l00342">mlir::AffineDmaWaitOp::getTagMap()</a>, <a class="el" href="Ops_8h_source.html#l00220">mlir::DmaStartOp::getTagMemRef()</a>, <a class="el" href="Ops_8h_source.html#l00306">mlir::DmaWaitOp::getTagMemRef()</a>, <a class="el" href="AffineOps_8h_source.html#l00213">mlir::AffineDmaStartOp::getTagMemRefOperandIndex()</a>, <a class="el" href="AffineOps_8h_source.html#l00475">mlir::AffineStoreOp::getValueToStore()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00141">mlir::PatternRewriter::inlineRegionBefore()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00264">lowerAffineLowerBound()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00276">lowerAffineMapMin()</a>, <a class="el" href="PatternMatch_8cpp_source.html#l00077">mlir::PatternRewriter::replaceOp()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00327">mlir::PatternRewriter::replaceOpWithNewOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopsToGPU_8cpp_source.html#l00087">getOrEmitUpperBound()</a>.</p>

</div>
</div>
<a id="ac267882a978b6b3c9d07e8fb3490d659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac267882a978b6b3c9d07e8fb3490d659">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt;<a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&gt; mlir::m_Constant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant foldable operation. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00205">205</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8cpp_source.html#l00654">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01354">foldLoopBounds()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00051">materializeConstant()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00107">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00336">mlir::OpBuilder::tryFold()</a>, and <a class="el" href="Ops_8cpp_source.html#l00472">verify()</a>.</p>

</div>
</div>
<a id="a10b6da5781fbe1b019fcb64dcd6921dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b6da5781fbe1b019fcb64dcd6921dd">&#9670;&nbsp;</a></span>m_Constant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AttrT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__op__binder.html">detail::constant_op_binder</a>&lt;AttrT&gt; mlir::m_Constant </td>
          <td>(</td>
          <td class="paramtype">AttrT *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a value from a constant foldable operation and writes the value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00212">212</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00037">mlir::detail::attr_value_binder&lt; AttrClass, ValueType, typename &gt;::bind_value</a>.</p>

</div>
</div>
<a id="a930dbe1d176d999aec049a4581838974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930dbe1d176d999aec049a4581838974">&#9670;&nbsp;</a></span>m_ConstantInt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__op__binder.html">detail::constant_int_op_binder</a> mlir::m_ConstantInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntegerAttr.html#a338d41710c0bd77a572190b8d552c754">IntegerAttr::ValueType</a> *&#160;</td>
          <td class="paramname"><em>bind_value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant holding a scalar/vector/tensor integer (splat) and writes the integer value to bind_value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00255">255</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a585ff769cbd1cef62ceda90ccd14062a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585ff769cbd1cef62ceda90ccd14062a">&#9670;&nbsp;</a></span>m_NonZero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__not__value__matcher.html">detail::constant_int_not_value_matcher</a>&lt;0&gt; mlir::m_NonZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer that is any non-zero value. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00233">233</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l00842">applyCmpPredicate()</a>.</p>

</div>
</div>
<a id="ac4cc1a8746679396a5dfe6e4c7ef8396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4cc1a8746679396a5dfe6e4c7ef8396">&#9670;&nbsp;</a></span>m_One()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__matcher.html">detail::constant_int_value_matcher</a>&lt;1&gt; mlir::m_One </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer one. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00217">217</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SPIRVOps_8cpp_source.html#l01993">verify()</a>.</p>

</div>
</div>
<a id="ac2418532386147bec2ca5aadf5414406"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2418532386147bec2ca5aadf5414406">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpClass &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1op__matcher.html">detail::op_matcher</a>&lt;OpClass&gt; mlir::m_Op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches the given OpClass. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00222">222</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="a7ecde76b07cd295bae0d6ef10d1c45d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecde76b07cd295bae0d6ef10d1c45d8">&#9670;&nbsp;</a></span>m_Op() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OpType , typename... Matchers&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::m_Op </td>
          <td>(</td>
          <td class="paramtype">Matchers...&#160;</td>
          <td class="paramname"><em>matchers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00260">260</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

</div>
</div>
<a id="aacf138ddcdd4a81f4047f2d6bbee3482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf138ddcdd4a81f4047f2d6bbee3482">&#9670;&nbsp;</a></span>m_Zero()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1detail_1_1constant__int__value__matcher.html">detail::constant_int_value_matcher</a>&lt;0&gt; mlir::m_Zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Matches a constant scalar / vector splat / tensor splat integer zero. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00227">227</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l00842">applyCmpPredicate()</a>, <a class="el" href="Ops_8cpp_source.html#l00209">foldMemRefCast()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l01993">verify()</a>.</p>

</div>
</div>
<a id="aac48118e62e44dabf4e8cf759a87daf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac48118e62e44dabf4e8cf759a87daf6">&#9670;&nbsp;</a></span>make_second_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ContainerTy &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto mlir::make_second_range </td>
          <td>(</td>
          <td class="paramtype">ContainerTy &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a container of pairs, return a range over the second elements. </p>

<p class="definition">Definition at line <a class="el" href="STLExtras_8h_source.html#l00328">328</a> of file <a class="el" href="STLExtras_8h_source.html">STLExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="SymbolTable_8cpp_source.html#l00632">rebuildAttrAfterRAUW()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00348">walkSymbolRefs()</a>.</p>

</div>
</div>
<a id="a1186a736d12d4f188f6eac3c02a11b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1186a736d12d4f188f6eac3c02a11b0f">&#9670;&nbsp;</a></span>makeComposedAffineApply()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineApplyOp.html">AffineApplyOp</a> mlir::makeComposedAffineApply </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpBuilder.html">OpBuilder</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Location.html">Location</a>&#160;</td>
          <td class="paramname"><em>loc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>operands</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a composed <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> by composing <code>map</code> and <code>operands</code> with other AffineApplyOps supplying those operands. </p>
<p>The operands of the resulting <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> do not change the length of <a class="el" href="classmlir_1_1AffineApplyOp.html" title="The &quot;affine.apply&quot; operation applies an affine map to a list of operands, yielding a single result...">AffineApplyOp</a> chains. </p>

<p class="definition">Definition at line <a class="el" href="AffineOps_8cpp_source.html#l00598">598</a> of file <a class="el" href="AffineOps_8cpp_source.html">AffineOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00578">composeAffineMapAndOperands()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, and <a class="el" href="Functional_8h_source.html#l00028">mlir::functional::map()</a>.</p>

<p class="reference">Referenced by <a class="el" href="EDSC_2Builders_8cpp_source.html#l00083">mlir::edsc::ValueHandle::createComposedAffineApply()</a>, and <a class="el" href="AffineOps_8h_source.html#l00505">mlir::AffineStoreOp::getOperationName()</a>.</p>

</div>
</div>
<a id="a923fafcbdcfdcb3b735fab2ab293a1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923fafcbdcfdcb3b735fab2ab293a1ad">&#9670;&nbsp;</a></span>makeStridedLinearLayoutMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::makeStridedLinearLayoutMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>strides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given a list of strides (in which <a class="el" href="classmlir_1_1MemRefType.html#acbdbbe58df49b67438c3c03507d0c8b3">MemRefType::getDynamicStrideOrOffset()</a> represents a dynamic value), return the single result <a class="el" href="classmlir_1_1AffineMap.html" title="A multi-dimensional affine map Affine map&#39;s are immutable like Type&#39;s, and they are uniqued...">AffineMap</a> which represents the linearized strided layout map. </p>
<p>Dimensions correspond to the offset followed by the strides in order. Symbols are inserted for each dynamic dimension in order. A stride cannot take value <code>0</code>.</p>
<h1>Examples: </h1>
<ol type="1">
<li>For offset: 0 strides: ?, ?, 1 return (i, j, k)[M, N]-&gt;(M * i + N * j + k)</li>
<li>For offset: 3 strides: 32, ?, 16 return (i, j, k)[M]-&gt;(3 + 32 * i + M * j + 16 * k)</li>
<li>For offset: ? strides: ?, ?, ? return (i, j, k)[off, M, N, P]-&gt;(off + M * i + N * j + P * k) </li>
</ol>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00666">666</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00180">mlir::detail::enumerate()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00277">getAffineConstantExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00252">getAffineDimExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00262">getAffineSymbolExpr()</a>, and <a class="el" href="StandardTypes_8h_source.html#l00426">mlir::MemRefType::getDynamicStrideOrOffset()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l00387">computeReshapeCollapsedType()</a>, <a class="el" href="Ops_8cpp_source.html#l02559">inferSubViewResultType()</a>, <a class="el" href="StandardTypes_8h_source.html#l00528">mlir::NoneType::kindof()</a>, <a class="el" href="Ops_8cpp_source.html#l02753">operator&lt;&lt;()</a>, <a class="el" href="Parser_8cpp_source.html#l00839">parseSymbol()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00524">verify()</a>.</p>

</div>
</div>
<a id="a945dcb325575f8843205517f1647a096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945dcb325575f8843205517f1647a096">&#9670;&nbsp;</a></span>mapLoopToProcessorIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::mapLoopToProcessorIds </td>
          <td>(</td>
          <td class="paramtype">loop::ForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>processorId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>numProcessors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps <code>forOp</code> for execution on a parallel grid of virtual <code>processorIds</code> of size given by <code>numProcessors</code>. </p>
<p>This is achieved by embedding the SSA values corresponding to <code>processorIds</code> and <code>numProcessors</code> into the bounds and step of the <code>forOp</code>. No check is performed on the legality of the rewrite, it is the caller's responsibility to ensure legality.</p>
<p>Requires that <code>processorIds</code> and <code>numProcessors</code> have the same size and that for each idx, <code>processorIds</code>[idx] takes, at runtime, all values between 0 and <code>numProcessors</code>[idx] - 1. This corresponds to traditional use cases for:</p><ol type="1">
<li>GPU (threadIdx, get_local_id(), ...)</li>
<li>MPI (MPI_Comm_rank)</li>
<li>OpenMP (omp_get_thread_num)</li>
</ol>
<p>Example: Assuming a 2-d grid with processorIds = [blockIdx.x, threadIdx.x] and numProcessors = [gridDim.x, blockDim.x], the loop:</p>
<div class="fragment"><div class="line">loop.for %i = %lb to %ub step %step {</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --><p>is rewritten into a version resembling the following pseudo-IR:</p>
<div class="fragment"><div class="line">loop.for %i = %lb + %step * (threadIdx.x + blockIdx.x * blockDim.x)</div><div class="line">   to %ub step %gridDim.x * blockDim.x * %step {</div><div class="line">  ...</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l01096">1096</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopsToGPU_8cpp_source.html#l00268">createGPULaunchLoops()</a>, and <a class="el" href="MemoryPromotion_8cpp_source.html#l00043">insertCopyLoops()</a>.</p>

</div>
</div>
<a id="a0190228b09e7b51a4bc1e013c01d404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0190228b09e7b51a4bc1e013c01d404c">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over a <a class="el" href="classmlir_1_1Value.html" title="This class represents an instance of an SSA value in the MLIR system, representing a computable value...">Value</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00239">239</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Value_8cpp_source.html#l00071">mlir::Value::getDefiningOp()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l00842">applyCmpPredicate()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00654">canonicalizeMapOrSetAndOperands()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01354">foldLoopBounds()</a>, <a class="el" href="Ops_8cpp_source.html#l00209">foldMemRefCast()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00051">materializeConstant()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00107">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="Ops_8cpp_source.html#l02753">operator&lt;&lt;()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00336">mlir::OpBuilder::tryFold()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l01993">verify()</a>.</p>

</div>
</div>
<a id="a1b97d57dcd6c08b495fbd3ef22aeda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b97d57dcd6c08b495fbd3ef22aeda6f">&#9670;&nbsp;</a></span>matchPattern() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Pattern &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::matchPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Pattern.html">Pattern</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Entry point for matching a pattern over an <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a>. </p>

<p class="definition">Definition at line <a class="el" href="Matchers_8h_source.html#l00248">248</a> of file <a class="el" href="Matchers_8h_source.html">Matchers.h</a>.</p>

<p class="reference">References <a class="el" href="Matchers_8h_source.html#l00042">mlir::detail::attr_value_binder&lt; AttrClass, ValueType, typename &gt;::match()</a>.</p>

</div>
</div>
<a id="ac9bf0a43f6ae7b00a5dd777d74d65b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9bf0a43f6ae7b00a5dd777d74d65b58">&#9670;&nbsp;</a></span>MlirOptMain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::MlirOptMain </td>
          <td>(</td>
          <td class="paramtype">llvm::raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1PassPipelineCLParser.html">PassPipelineCLParser</a> &amp;&#160;</td>
          <td class="paramname"><em>passPipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitInputFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyDiagnostics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verifyPasses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00067">processBuffer()</a>.</p>

</div>
</div>
<a id="afca33cad5b0cd935568ea0fc0a439abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca33cad5b0cd935568ea0fc0a439abd">&#9670;&nbsp;</a></span>mod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mlir::mod </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns MLIR's mod operation on constants. </p>
<p>MLIR's mod operation yields the remainder of the Euclidean division of 'lhs' by 'rhs', and is therefore not C's % operator. The RHS is always expected to be positive, and the result is always non-negative. </p>

<p class="definition">Definition at line <a class="el" href="MathExtras_8h_source.html#l00041">41</a> of file <a class="el" href="MathExtras_8h_source.html">MathExtras.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Rules_8h_source.html#l00078">mlir::quantizer::BasePropagatedFact&lt; ExpandingMinMaxReducer &gt;::assertValue()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00533">simplifyMod()</a>.</p>

</div>
</div>
<a id="ae4f3ffb3d4089a4a62f1b01ef2cc80df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f3ffb3d4089a4a62f1b01ef2cc80df">&#9670;&nbsp;</a></span>normalizeMemRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::normalizeMemRef </td>
          <td>(</td>
          <td class="paramtype">AllocOp&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rewrites the memref defined by this alloc op to have an identity layout map and updates all its indexing uses. </p>
<p>Returns failure if any of its uses escape (while leaving the IR in a valid state). </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00390">390</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineStructures_8cpp_source.html#l01894">mlir::FlatAffineConstraints::addConstantLowerBound()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00303">mlir::MemRefType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00382">mlir::MemRefType::getAffineMaps()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00268">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00380">mlir::MemRefType::getShape()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00218">replaceAllMemRefUsesWith()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="SimplifyAffineStructures_8cpp_source.html#l00080">createSimplifyAffineStructuresPass()</a>.</p>

</div>
</div>
<a id="a0c2eb0b34f6d7e90435b0a6ce3d8ffaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2eb0b34f6d7e90435b0a6ce3d8ffaf">&#9670;&nbsp;</a></span>openInputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::MemoryBuffer&gt; mlir::openInputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>inputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for reading. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00095">parseMLIRInput()</a>.</p>

</div>
</div>
<a id="a4c8c9750d9c8efdbcc7542f3b1564d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c8c9750d9c8efdbcc7542f3b1564d8d">&#9670;&nbsp;</a></span>openOutputFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;llvm::ToolOutputFile&gt; mlir::openOutputFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>outputFilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>errorMessage</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open the file specified by its name for writing. </p>
<p>Write the error message to <code>errorMessage</code> if errors occur and <code>errorMessage</code> is not nullptr. </p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00081">mlir::SimpleObjectCache::dumpToObjectFile()</a>, and <a class="el" href="Pass_8cpp_source.html#l00504">runWithCrashRecovery()</a>.</p>

</div>
</div>
<a id="aba1fa005aee40f3f33c8e44097af7377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1fa005aee40f3f33c8e44097af7377">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00082">82</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00046">mlir::Identifier::data()</a>.</p>

</div>
</div>
<a id="aeec87c8e176e5200de6eabb890d01e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec87c8e176e5200de6eabb890d01e96">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00087">87</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00052">mlir::Identifier::is()</a>.</p>

</div>
</div>
<a id="aa956129148e25edd5ec7b39b592c6082"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa956129148e25edd5ec7b39b592c6082">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00089">89</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00052">mlir::Identifier::is()</a>.</p>

</div>
</div>
<a id="ab8d0033d79ef89bd4fe840819c0e5b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d0033d79ef89bd4fe840819c0e5b44">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00094">94</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

</div>
</div>
<a id="a5da97a01717dee2c2fa7ad551de8dc46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5da97a01717dee2c2fa7ad551de8dc46">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00245">245</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00225">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="aee326f96469cd288efb48265e173295e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee326f96469cd288efb48265e173295e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00250">250</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00107">mlir::OpState::getOperation()</a>.</p>

</div>
</div>
<a id="a9137193b56dc5134c3092273b13e3f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9137193b56dc5134c3092273b13e3f47">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator* </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineExpr_8h_source.html#l00200">200</a> of file <a class="el" href="AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Helpers_8h_source.html#l00160">mlir::edsc::TemplatedIndexedValue&lt; Load, Store &gt;::getBase()</a>, <a class="el" href="Attributes_8h_source.html#l00215">mlir::ArrayAttr::kindof()</a>, and <a class="el" href="AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="a014242a015c4e9c9aa58c829af2fc4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014242a015c4e9c9aa58c829af2fc4d4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a> mlir::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00057">57</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

<p class="reference">References <a class="el" href="SDBM_8h_source.html#l00048">mlir::IntInfty::getValue()</a>, <a class="el" href="SDBM_8h_source.html#l00037">mlir::IntInfty::infty</a>, and <a class="el" href="SDBM_8h_source.html#l00051">mlir::IntInfty::isFinite()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Helpers_8h_source.html#l00160">mlir::edsc::TemplatedIndexedValue&lt; Load, Store &gt;::getBase()</a>, and <a class="el" href="AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>.</p>

</div>
</div>
<a id="a8f6f52bcd2d859c9d9a6f393ad5481c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6f52bcd2d859c9d9a6f393ad5481c1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator+ </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineExpr_8h_source.html#l00199">199</a> of file <a class="el" href="AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

</div>
</div>
<a id="a72aa3fc8e169b33e5d4a63f593172d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa3fc8e169b33e5d4a63f593172d4e">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::operator- </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>val</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineExpr_8h_source.html#l00201">201</a> of file <a class="el" href="AffineExpr_8h_source.html">AffineExpr.h</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8cpp_source.html#l00045">getAffineBinaryOpExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00277">getAffineConstantExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00252">getAffineDimExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00262">getAffineSymbolExpr()</a>, <a class="el" href="Ops_8cpp_source.html#l02753">operator&lt;&lt;()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00594">toAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Helpers_8h_source.html#l00160">mlir::edsc::TemplatedIndexedValue&lt; Load, Store &gt;::getBase()</a>, <a class="el" href="AffineExpr_8h_source.html#l00080">mlir::AffineExpr::operator!()</a>, <a class="el" href="SDBMExpr_8h_source.html#l00106">mlir::SDBMExpr::operator!()</a>, and <a class="el" href="SDBMExpr_8h_source.html#l00474">mlir::ops_assertions::operator+()</a>.</p>

</div>
</div>
<a id="a9f5e28263eb0fcf092160b8a9e0f6ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5e28263eb0fcf092160b8a9e0f6ce8">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00082">82</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

<p class="reference">References <a class="el" href="SDBM_8h_source.html#l00048">mlir::IntInfty::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TableGen_2Dialect_8h_source.html#l00027">mlir::tblgen::Dialect::Dialect()</a>.</p>

</div>
</div>
<a id="a30603aed1417a20bef2b8efae1167bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30603aed1417a20bef2b8efae1167bde">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00056">56</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1DialectAsmPrinter.html#a768bb4630d64c0e4c122528d5d5c9285">mlir::DialectAsmPrinter::printAttribute()</a>.</p>

</div>
</div>
<a id="a649ee8579b14d0897aab47f53b883b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649ee8579b14d0897aab47f53b883b29">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const APFloat &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00061">61</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1DialectAsmPrinter.html#ab02ac89957d800e1349a3480de0b54ff">mlir::DialectAsmPrinter::printFloat()</a>.</p>

</div>
</div>
<a id="a1afb696ee471be35a4d1f75c64ea1bd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1afb696ee471be35a4d1f75c64ea1bd4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[3/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00066">66</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

</div>
</div>
<a id="ae26a3adac6475f34a40e802331ee10d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26a3adac6475f34a40e802331ee10d6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[4/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00069">69</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

</div>
</div>
<a id="a9f5b241db4d1de80e4879009596797b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5b241db4d1de80e4879009596797b6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[5/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>identifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00073">73</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00043">mlir::Identifier::print()</a>.</p>

</div>
</div>
<a id="aa2ffb26ef01caacb04bda28d4501f4fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ffb26ef01caacb04bda28d4501f4fd">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[6/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00073">73</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1DialectAsmPrinter.html#a54221cc3b0583573cd7481e3ed3f7633">mlir::DialectAsmPrinter::printType()</a>.</p>

</div>
</div>
<a id="af9916cd8c014a3b0a666cc2fe88a6fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9916cd8c014a3b0a666cc2fe88a6fae">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[7/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; !std::is_convertible&lt; T &amp;, Attribute &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Type &amp;&gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, APFloat &amp;&gt;::value &amp;&amp;!llvm::is_one_of&lt; T, double, float &gt;::value, T &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1DialectAsmPrinter.html">DialectAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DialectImplementation_8h_source.html#l00087">87</a> of file <a class="el" href="DialectImplementation_8h_source.html">DialectImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1DialectAsmPrinter.html#a78fab18b310c7e80c94b5bf3c7c1f66d">mlir::DialectAsmPrinter::getStream()</a>.</p>

</div>
</div>
<a id="ab097ddf5971ea2a3956fc814005f459f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab097ddf5971ea2a3956fc814005f459f">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[8/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Location.html">Location</a> &amp;&#160;</td>
          <td class="paramname"><em>loc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Location_8h_source.html#l00088">88</a> of file <a class="el" href="Location_8h_source.html">Location.h</a>.</p>

<p class="reference">References <a class="el" href="Location_8h_source.html#l00072">mlir::Location::print()</a>.</p>

</div>
</div>
<a id="a5e8f0e932c305de3ac1584560d1b03d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8f0e932c305de3ac1584560d1b03d0">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[9/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Attributes_8h_source.html#l00122">122</a> of file <a class="el" href="Attributes_8h_source.html">Attributes.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02131">mlir::Attribute::print()</a>.</p>

</div>
</div>
<a id="acabdc4e9d44aae13942c9ea9b41b9a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabdc4e9d44aae13942c9ea9b41b9a33">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[10/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00144">144</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#acddd5eb143c94fa8528920c75799e3ba">mlir::OpAsmPrinter::printOperand()</a>.</p>

</div>
</div>
<a id="a0454cf763cf2a4bab30345a05f174fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0454cf763cf2a4bab30345a05f174fe6">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[11/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename std::enable_if&lt; std::is_convertible&lt; T &amp;, ValueRange &gt;::value &amp;&amp;!std::is_convertible&lt; T &amp;, Value &amp;&gt;::value, T &gt;::type *  = nullptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00153">153</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="OpImplementation_8h_source.html#l00043">mlir::OpAsmPrinter::printOperands()</a>.</p>

</div>
</div>
<a id="a9b198f57489cfde31dc674cca18d6e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b198f57489cfde31dc674cca18d6e9d">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[12/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00158">158</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#acdfd3cf030c2a51ba8746715ca686417">mlir::OpAsmPrinter::printType()</a>.</p>

</div>
</div>
<a id="ae72e36349258a6b2baeae78188a74550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72e36349258a6b2baeae78188a74550">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[13/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1DiagnosticArgument.html">DiagnosticArgument</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Diagnostics_8h_source.html#l00161">161</a> of file <a class="el" href="Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00063">mlir::DiagnosticArgument::print()</a>.</p>

</div>
</div>
<a id="a6974d43c0e2f0e03e5ffe739237dcae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6974d43c0e2f0e03e5ffe739237dcae4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[14/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a>&#160;</td>
          <td class="paramname"><em>attr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00163">163</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="classmlir_1_1OpAsmPrinter.html#a45343700e3bbe60085d5478d073c1009">mlir::OpAsmPrinter::getStream()</a>, <a class="el" href="Ops_8cpp_source.html#l02753">operator&lt;&lt;()</a>, and <a class="el" href="classmlir_1_1OpAsmPrinter.html#a693e157c72502460919366e54d2d8080">mlir::OpAsmPrinter::printAttribute()</a>.</p>

</div>
</div>
<a id="af05b62a76688ea80f262ea5b69665ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05b62a76688ea80f262ea5b69665ae4">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[15/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00183">183</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

</div>
</div>
<a id="acd5bfd80339235fbb32a685ff75f4e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5bfd80339235fbb32a685ff75f4e16">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[16/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00184">184</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02140">mlir::Type::print()</a>.</p>

</div>
</div>
<a id="a2cb66d612704fc6cbd310158b9458545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb66d612704fc6cbd310158b9458545">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[17/24]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IteratorT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a>&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classllvm_1_1iterator__range.html">iterator_range</a>&lt; <a class="el" href="classmlir_1_1ValueTypeIterator.html">ValueTypeIterator</a>&lt; IteratorT &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpImplementation_8h_source.html#l00189">189</a> of file <a class="el" href="OpImplementation_8h_source.html">OpImplementation.h</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l00081">interleaveComma()</a>.</p>

</div>
</div>
<a id="a3df16c49c963cdc57cf6f9e7c3e9f822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df16c49c963cdc57cf6f9e7c3e9f822">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[18/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Value_8h_source.html#l00208">208</a> of file <a class="el" href="Value_8h_source.html">Value.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02179">mlir::Value::print()</a>.</p>

</div>
</div>
<a id="a6f93a44db5e2d93372201d5a594e51cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f93a44db5e2d93372201d5a594e51cd">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[19/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineMap_8h_source.html#l00221">221</a> of file <a class="el" href="AffineMap_8h_source.html">AffineMap.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02167">mlir::AffineMap::print()</a>.</p>

</div>
</div>
<a id="abee64f56d77f8346c5187e789c587ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee64f56d77f8346c5187e789c587ae9">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[20/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &amp;&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00584">584</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02154">mlir::AffineExpr::print()</a>.</p>

</div>
</div>
<a id="aff09e0657f1f97508b409ac5f6e4e5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff09e0657f1f97508b409ac5f6e4e5b8">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[21/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>identifier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00236">236</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l00047">mlir::OperationName::print()</a>.</p>

</div>
</div>
<a id="a85b9a8e647d5e73b7e107b0669ec9e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b9a8e647d5e73b7e107b0669ec9e29">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[22/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Diagnostic.html">Diagnostic</a> &amp;&#160;</td>
          <td class="paramname"><em>diag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Diagnostics_8h_source.html#l00308">308</a> of file <a class="el" href="Diagnostics_8h_source.html">Diagnostics.h</a>.</p>

<p class="reference">References <a class="el" href="Diagnostics_8cpp_source.html#l00135">mlir::Diagnostic::print()</a>.</p>

</div>
</div>
<a id="a76958b05a1a457434e625f4b31594dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76958b05a1a457434e625f4b31594dd3">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[23/24]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SubViewOp::Range &amp;&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l02753">2753</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00265">mlir::PatternRewriter::create()</a>, <a class="el" href="Matchers_8h_source.html#l00180">mlir::detail::enumerate()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00303">mlir::MemRefType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00382">mlir::MemRefType::getAffineMaps()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00052">mlir::Builder::getContext()</a>, <a class="el" href="StandardTypes_8h_source.html#l00426">mlir::MemRefType::getDynamicStrideOrOffset()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00386">mlir::MemRefType::getMemorySpace()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00380">mlir::MemRefType::getShape()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00592">getStridesAndOffset()</a>, <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="Ops_8cpp_source.html#l00198">m_ConstantIndex()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00666">makeStridedLinearLayoutMap()</a>, <a class="el" href="Matchers_8h_source.html#l00239">matchPattern()</a>, <a class="el" href="LinalgTypes_8h_source.html#l00020">mlir::linalg::Range</a>, <a class="el" href="PatternMatch_8h_source.html#l00327">mlir::PatternRewriter::replaceOpWithNewOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8h_source.html#l00320">mlir::DmaWaitOp::getNumElements()</a>, <a class="el" href="AffineExpr_8h_source.html#l00201">operator-()</a>, and <a class="el" href="OpImplementation_8h_source.html#l00163">operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a253b4a2344293dfbeab47ede8971fb29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253b4a2344293dfbeab47ede8971fb29">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[24/24]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream&amp; mlir::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Operation_8h_source.html#l00661">661</a> of file <a class="el" href="Operation_8h_source.html">Operation.h</a>.</p>

<p class="reference">References <a class="el" href="AsmPrinter_8cpp_source.html#l02209">mlir::Operation::print()</a>.</p>

</div>
</div>
<a id="a8491b7c1cf514aa1510eb26fd5003c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8491b7c1cf514aa1510eb26fd5003c18">&#9670;&nbsp;</a></span>operator<=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00086">86</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

<p class="reference">References <a class="el" href="SDBM_8h_source.html#l00048">mlir::IntInfty::getValue()</a>.</p>

</div>
</div>
<a id="a0ddf739fdaf5a03fdb07ac3b4c672f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddf739fdaf5a03fdb07ac3b4c672f4e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00078">78</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00046">mlir::Identifier::data()</a>.</p>

</div>
</div>
<a id="aa492640c61b36ef2ab8565e5015abd1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa492640c61b36ef2ab8565e5015abd1e">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00086">86</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00052">mlir::Identifier::is()</a>.</p>

</div>
</div>
<a id="ad6b0dcdd7e4c238b039144d7840350f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6b0dcdd7e4c238b039144d7840350f2">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Identifier.html">Identifier</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Identifier_8h_source.html#l00088">88</a> of file <a class="el" href="Identifier_8h_source.html">Identifier.h</a>.</p>

<p class="reference">References <a class="el" href="Identifier_8h_source.html#l00052">mlir::Identifier::is()</a>.</p>

</div>
</div>
<a id="a572d4713cebe03e129bef601d1041f0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a572d4713cebe03e129bef601d1041f0f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1IntInfty.html">IntInfty</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="SDBM_8h_source.html#l00090">90</a> of file <a class="el" href="SDBM_8h_source.html">SDBM.h</a>.</p>

<p class="reference">References <a class="el" href="SDBM_8h_source.html#l00048">mlir::IntInfty::getValue()</a>.</p>

<p class="reference">Referenced by <a class="el" href="TableGen_2Dialect_8h_source.html#l00027">mlir::tblgen::Dialect::Dialect()</a>, and <a class="el" href="AffineExpr_8h_source.html#l00075">mlir::AffineExpr::operator!=()</a>.</p>

</div>
</div>
<a id="a14c6a127d8f1fa12d3c7405b9d51a695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c6a127d8f1fa12d3c7405b9d51a695">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OperationName.html">OperationName</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OperationSupport_8h_source.html#l00241">241</a> of file <a class="el" href="OperationSupport_8h_source.html">OperationSupport.h</a>.</p>

<p class="reference">References <a class="el" href="OperationSupport_8h_source.html#l00225">mlir::OperationName::getAsOpaquePointer()</a>.</p>

</div>
</div>
<a id="abc4f129dda2c412845b5ec66a77325a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f129dda2c412845b5ec66a77325a3">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpState.html">OpState</a>&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OpDefinition_8h_source.html#l00247">247</a> of file <a class="el" href="OpDefinition_8h_source.html">OpDefinition.h</a>.</p>

<p class="reference">References <a class="el" href="OpDefinition_8h_source.html#l00107">mlir::OpState::getOperation()</a>.</p>

</div>
</div>
<a id="af1aa182f707b3cb6a071cf1a9937578d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1aa182f707b3cb6a071cf1a9937578d">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>attrStr</code>. If the passed <code>attrStr</code> has additional tokens that were not part of the type, an error is emitted. </p>

<p class="reference">Referenced by <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="Parser_8cpp_source.html#l01430">extractSymbolReference()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00279">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00335">mlir::OpAsmParser::parseAttribute()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00212">mlir::DialectAsmParser::parseKeyword()</a>, and <a class="el" href="Parser_8cpp_source.html#l00839">parseSymbol()</a>.</p>

</div>
</div>
<a id="ae34310a5d6e4690062af470064089068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34310a5d6e4690062af470064089068">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bd19a863e2bf8969c4bae3ecaa84a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd19a863e2bf8969c4bae3ecaa84a16">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR attribute to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>attrStr</code>. The number of characters of <code>attrStr</code> parsed in the process is returned in <code>numRead</code>. </p>

</div>
</div>
<a id="ae61d149703ad4537629141fab7417075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61d149703ad4537629141fab7417075">&#9670;&nbsp;</a></span>parseAttribute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Attribute.html">Attribute</a> mlir::parseAttribute </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>attrStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc3d0c425094498fc25bf4856eb029c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3d0c425094498fc25bf4856eb029c8">&#9670;&nbsp;</a></span>parseDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1ParseResult.html">ParseResult</a> mlir::parseDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmParser.html">OpAsmParser</a> &amp;&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1SmallVectorImpl.html">SmallVectorImpl</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operands</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>numDims</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses dimension and symbol list and returns true if parsing failed. </p>

<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l00177">177</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#a06b1d7cb826bcceb3ce2fe325faff660">mlir::OpAsmParser::getBuilder()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00054">mlir::Builder::getIndexType()</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#acabba33fbd8180d7ad2c752821696f92ae4e85fd5ca8927b9be287e34162aab21">mlir::OpAsmParser::OptionalSquare</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#acabba33fbd8180d7ad2c752821696f92a3f5a1b4ee2e68aebee8e1fa43e0eed27">mlir::OpAsmParser::Paren</a>, <a class="el" href="classmlir_1_1OpAsmParser.html#af904bf0873e8641211c3a735eca3bfd8">mlir::OpAsmParser::parseOperandList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00468">mlir::OpAsmParser::resolveOperands()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8h_source.html#l00320">mlir::DmaWaitOp::getNumElements()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00238">mlir::AffineApplyOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01624">parseAffineIfOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00258">parseAllocOp()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01153">parseBound()</a>.</p>

</div>
</div>
<a id="ad8d10077c7edf58c1152a1170257d739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8d10077c7edf58c1152a1170257d739">&#9670;&nbsp;</a></span>parsePassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::parsePassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>pipeline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpPassManager.html">OpPassManager</a> &amp;&#160;</td>
          <td class="paramname"><em>pm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>errorStream</em> = <code>llvm::errs()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function parses the textual representation of a pass pipeline, and adds the result to 'pm' on success. </p>
<p>This function returns failure if the given pipeline was invalid. 'errorStream' is the output stream used to emit errors found during parsing.</p>
<p>This function returns failure if the given pipeline was invalid. 'errorStream' is an optional parameter that, if non-null, will be used to emit errors found during parsing. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00377">377</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="PassManagerOptions_8cpp_source.html#l00099">options</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00159">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="a58242edc66b5abcd9ee83a1ba8eeef9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58242edc66b5abcd9ee83a1ba8eeef9a">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">const llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated SourceMgr and returns an MLIR module if it was valid. </p>
<p>If not, the error message is emitted through the error handler registered in the context, and a null pointer is returned.</p>
<p>If not, it emits diagnostics and returns null. </p>

<p class="definition">Definition at line <a class="el" href="Parser_8cpp_source.html#l04761">4761</a> of file <a class="el" href="Parser_8cpp_source.html">Parser.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00028">mlir::ModuleOp::create()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00301">emitError()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="Location_8cpp_source.html#l00041">mlir::FileLineColLoc::get()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00559">mlir::UnknownLoc::get()</a>, <a class="el" href="namespacemlir.html#a35164c0dafdbc75ec99d61670e14f4fa">parseSourceString()</a>, and <a class="el" href="Verifier_8cpp_source.html#l00264">verify()</a>.</p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00095">parseMLIRInput()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00040">performActions()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00107">roundTripModule()</a>, and <a class="el" href="TranslateClParser_8cpp_source.html#l00038">mlir::TranslationParser::TranslationParser()</a>.</p>

</div>
</div>
<a id="af62f251042b70003de696c34e9d6ef21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62f251042b70003de696c34e9d6ef21">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename and returns an MLIR module if it was valid. </p>
<p>If not, the error message is emitted through the error handler registered in the context, and a null pointer is returned. </p>

</div>
</div>
<a id="a0223a06797244d877e547544d49b7cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0223a06797244d877e547544d49b7cad">&#9670;&nbsp;</a></span>parseSourceFile() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::parseSourceFile </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::SourceMgr &amp;&#160;</td>
          <td class="paramname"><em>sourceMgr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the file specified by the indicated filename using the provided SourceMgr and returns an MLIR module if it was valid. </p>
<p>If not, the error message is emitted through the error handler registered in the context, and a null pointer is returned. </p>

</div>
</div>
<a id="a35164c0dafdbc75ec99d61670e14f4fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35164c0dafdbc75ec99d61670e14f4fa">&#9670;&nbsp;</a></span>parseSourceString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::parseSourceString </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>moduleStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses the module string to a MLIR module if it was valid. </p>
<p>If not, the error message is emitted through the error handler registered in the context, and a null pointer is returned. </p>

<p class="reference">Referenced by <a class="el" href="Parser_8cpp_source.html#l04761">parseSourceFile()</a>.</p>

</div>
</div>
<a id="ac5ffe10560be9caf3b9e8de592c20e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ffe10560be9caf3b9e8de592c20e93">&#9670;&nbsp;</a></span>parseType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>typeStr</code>. If the passed <code>typeStr</code> has additional tokens that were not part of the type, an error is emitted. </p>

<p class="reference">Referenced by <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="Parser_8cpp_source.html#l01430">extractSymbolReference()</a>, <a class="el" href="SPIRVDialect_8h_source.html#l00027">mlir::spirv::SPIRVDialect::getDialectNamespace()</a>, <a class="el" href="LLVMDialect_8h_source.html#l00203">mlir::LLVM::LLVMDialect::getDialectNamespace()</a>, <a class="el" href="CoreAPIs_8cpp_source.html#l00085">mlirParseType()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00279">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00593">mlir::OpAsmParser::parseKeywordType()</a>, <a class="el" href="OpImplementation_8h_source.html#l00536">mlir::OpAsmParser::parseRegionArgumentList()</a>, <a class="el" href="Parser_8cpp_source.html#l00839">parseSymbol()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01594">mlir::LLVM::LLVMDialect::parseType()</a>, and <a class="el" href="DialectImplementation_8h_source.html#l00308">mlir::DialectAsmParser::parseType()</a>.</p>

</div>
</div>
<a id="afafaf30c94bd5327a769f9fd691cd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafaf30c94bd5327a769f9fd691cd42a">&#9670;&nbsp;</a></span>parseType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a> mlir::parseType </td>
          <td>(</td>
          <td class="paramtype">llvm::StringRef&#160;</td>
          <td class="paramname"><em>typeStr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numRead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This parses a single MLIR type to an MLIR context if it was valid. </p>
<p>If not, an error message is emitted through a new <a class="el" href="classmlir_1_1SourceMgrDiagnosticHandler.html" title="This class is a utility diagnostic handler for use with llvm::SourceMgr. ">SourceMgrDiagnosticHandler</a> constructed from a new SourceMgr with a single a MemoryBuffer wrapping <code>typeStr</code>. The number of characters of <code>typeStr</code> parsed in the process is returned in <code>numRead</code>. </p>

</div>
</div>
<a id="a0a8c7352bef2e6ad933b0342ac148d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8c7352bef2e6ad933b0342ac148d83">&#9670;&nbsp;</a></span>populateAffineToStdConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateAffineToStdConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Affine dialect to the Standard dialect, in particular convert structured affine control flow into CFG branch-based control flow. </p>

<p class="definition">Definition at line <a class="el" href="AffineToStandard_8cpp_source.html#l00542">542</a> of file <a class="el" href="AffineToStandard_8cpp_source.html">AffineToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00510">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01791">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLLVM_8cpp_source.html#l00559">populateLinalgToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="ae6fe385239da2dd1c47fa998533a19f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6fe385239da2dd1c47fa998533a19f6">&#9670;&nbsp;</a></span>populateBuiltinFuncToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateBuiltinFuncToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating the builtin <code>func</code> op to the SPIR-V dialect. </p>
<p>These patterns do not handle shader interface/ABI; they convert function parameters to be of SPIR-V allowed types. </p>

<p class="definition">Definition at line <a class="el" href="SPIRVLowering_8cpp_source.html#l00214">214</a> of file <a class="el" href="SPIRVLowering_8cpp_source.html">SPIRVLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a923f103c236da2f1bb3afc9ceff7ac13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923f103c236da2f1bb3afc9ceff7ac13">&#9670;&nbsp;</a></span>populateFuncOpTypeConversionPattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateFuncOpTypeConversionPattern </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1TypeConverter.html">TypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a pattern to the given pattern list to convert the signature of a <a class="el" href="classmlir_1_1FuncOp.html" title="FuncOp represents a function, or an operation containing one region that forms a CFG(Control Flow Gra...">FuncOp</a> with the given type converter. </p>

<p class="definition">Definition at line <a class="el" href="DialectConversion_8cpp_source.html#l01653">1653</a> of file <a class="el" href="DialectConversion_8cpp_source.html">DialectConversion.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectConversion_8h_source.html#l00282">mlir::OpConversionPattern&lt; SourceOp &gt;::matchAndRewrite()</a>.</p>

</div>
</div>
<a id="acd6199c25bfc092bd63f31f982855e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6199c25bfc092bd63f31f982855e1c">&#9670;&nbsp;</a></span>populateGpuRewritePatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuRewritePatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to rewrite ops within the GPU dialect. </p>

<p class="definition">Definition at line <a class="el" href="AllReduceLowering_8cpp_source.html#l00370">370</a> of file <a class="el" href="AllReduceLowering_8cpp_source.html">AllReduceLowering.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a2cb104ff278ae6a462a7e4339637f405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb104ff278ae6a462a7e4339637f405">&#9670;&nbsp;</a></span>populateGpuToNVVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGpuToNVVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the GPU dialect to <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html#l00727">727</a> of file <a class="el" href="LowerGpuOpsToNVVMOps_8cpp_source.html">LowerGpuOpsToNVVMOps.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Dialect_8h_source.html#l00047">mlir::Dialect::getContext()</a>, <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00063">mlir::LLVMTypeConverter::getDialect()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a22eea25e76e053acdaf89905feba42d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22eea25e76e053acdaf89905feba42d4">&#9670;&nbsp;</a></span>populateGPUToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateGPUToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>workGroupSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating GPU Ops to SPIR-V ops. </p>
<p>Needs the workgroup size as input since SPIR-V/Vulkan requires the workgroup size to be statically specified. </p>

<p class="definition">Definition at line <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html#l00397">397</a> of file <a class="el" href="ConvertGPUToSPIRV_8cpp_source.html">ConvertGPUToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="afdbac6a13953f49ca582ee2b710d1f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdbac6a13953f49ca582ee2b710d1f45">&#9670;&nbsp;</a></span>populateLinalgToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateLinalgToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LinalgTypeConverter.html">LinalgTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate the given list with patterns that convert from Linalg to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="LinalgToLLVM_8cpp_source.html#l00559">559</a> of file <a class="el" href="LinalgToLLVM_8cpp_source.html">LinalgToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00443">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00510">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8h_source.html#l00433">mlir::ConversionTarget::addLegalOp()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01809">applyFullConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01592">mlir::TypeConverter::isSignatureLegal()</a>, <a class="el" href="AffineToStandard_8cpp_source.html#l00542">populateAffineToStdConversionPatterns()</a>, <a class="el" href="ConvertLoopToStandard_8cpp_source.html#l00249">populateLoopToStdConversionPatterns()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02142">populateStdToLLVMConversionPatterns()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00955">populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a1ca74253af65583026863be8081bbd84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca74253af65583026863be8081bbd84">&#9670;&nbsp;</a></span>populateLoopToStdConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateLoopToStdConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to lower from loop.for, loop.if, and loop.terminator to CFG operations within the Standard dialect, in particular convert structured control flow into CFG branch-based control flow. </p>

<p class="definition">Definition at line <a class="el" href="ConvertLoopToStandard_8cpp_source.html#l00249">249</a> of file <a class="el" href="ConvertLoopToStandard_8cpp_source.html">ConvertLoopToStandard.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00510">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01791">applyPartialConversion()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02209">makeStandardToLLVMTypeConverter()</a>, and <a class="el" href="LinalgToLLVM_8cpp_source.html#l00559">populateLinalgToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="ad1de38d84e16c5c7e869995fb1c3605b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1de38d84e16c5c7e869995fb1c3605b">&#9670;&nbsp;</a></span>populateStandardToSPIRVPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateStandardToSPIRVPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1SPIRVTypeConverter.html">SPIRVTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>typeConverter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list additional patterns for translating StandardOps to SPIR-V ops. </p>
<p>Also adds the patterns legalize ops not directly translated to SPIR-V dialect. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html#l00392">392</a> of file <a class="el" href="ConvertStandardToSPIRV_8cpp_source.html">ConvertStandardToSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a6ac4da050bc6b23d395d3480f9dfae8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ac4da050bc6b23d395d3480f9dfae8a">&#9670;&nbsp;</a></span>populateStdLegalizationPatternsForSPIRVLowering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateStdLegalizationPatternsForSPIRVLowering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Appends to a pattern list patterns to legalize ops that are not directly lowered to SPIR-V. </p>

<p class="definition">Definition at line <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00153">153</a> of file <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html">LegalizeStandardForSPIRV.cpp</a>.</p>

<p class="reference">References <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00218">applyPatternsGreedily()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a595c6a19148f86b48b2121b201475618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a595c6a19148f86b48b2121b201475618">&#9670;&nbsp;</a></span>populateStdToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateStdToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Standard dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02142">2142</a> of file <a class="el" href="ConvertStandardToLLVM_8cpp_source.html">ConvertStandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02124">populateStdToLLVMMemoryConversionPatters()</a>, and <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02069">populateStdToLLVMNonMemoryConversionPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02264">createLowerToLLVMPass()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02209">makeStandardToLLVMTypeConverter()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00559">populateLinalgToLLVMConversionPatterns()</a>, and <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00955">populateVectorToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a295a0479fed5f043620777a1f1e6f93b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a295a0479fed5f043620777a1f1e6f93b">&#9670;&nbsp;</a></span>populateStdToLLVMMemoryConversionPatters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateStdToLLVMMemoryConversionPatters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert memory-related operations from the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, excluding the memory-related operations. </p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02124">2124</a> of file <a class="el" href="ConvertStandardToLLVM_8cpp_source.html">ConvertStandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8cpp.html#a51000701d12412f4101d7873ff45a511">clUseAlloca()</a>, <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00063">mlir::LLVMTypeConverter::getDialect()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02142">populateStdToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="ac272d602be4199d577e0a2e42788c50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac272d602be4199d577e0a2e42788c50d">&#9670;&nbsp;</a></span>populateStdToLLVMNonMemoryConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateStdToLLVMNonMemoryConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Standard dialect to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect, excluding the memory-related operations. </p>
<p>Collect a set of patterns to convert from the Standard dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>.</p>

<p class="definition">Definition at line <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02069">2069</a> of file <a class="el" href="ConvertStandardToLLVM_8cpp_source.html">ConvertStandardToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00063">mlir::LLVMTypeConverter::getDialect()</a>, and <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02142">populateStdToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a619f33d7fea7eea9addb79a3d680cc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619f33d7fea7eea9addb79a3d680cc9b">&#9670;&nbsp;</a></span>populateVectorToAffineLoopsConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToAffineLoopsConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Vector dialect to loops + std. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLoops_8cpp_source.html#l00354">354</a> of file <a class="el" href="ConvertVectorToLoops_8cpp_source.html">ConvertVectorToLoops.cpp</a>.</p>

<p class="reference">References <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>.</p>

</div>
</div>
<a id="a7c8bf0ac3b61b7aa5915ddf914c2d66e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c8bf0ac3b61b7aa5915ddf914c2d66e">&#9670;&nbsp;</a></span>populateVectorToLLVMConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToLLVMConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1LLVMTypeConverter.html">LLVMTypeConverter</a> &amp;&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Vector dialect to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>
<p>Populate the given list with patterns that convert from Vector to <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00955">955</a> of file <a class="el" href="ConvertVectorToLLVM_8cpp_source.html">ConvertVectorToLLVM.cpp</a>.</p>

<p class="reference">References <a class="el" href="DialectConversion_8h_source.html#l00443">mlir::ConversionTarget::addDynamicallyLegalOp()</a>, <a class="el" href="DialectConversion_8h_source.html#l00510">mlir::ConversionTarget::addLegalDialect()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01791">applyPartialConversion()</a>, <a class="el" href="GreedyPatternRewriteDriver_8cpp_source.html#l00218">applyPatternsGreedily()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="IR_2Dialect_8h_source.html#l00047">mlir::Dialect::getContext()</a>, <a class="el" href="ConvertStandardToLLVM_8h_source.html#l00063">mlir::LLVMTypeConverter::getDialect()</a>, <a class="el" href="PatternMatch_8h_source.html#l00419">mlir::OwningRewritePatternList::insert()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01592">mlir::TypeConverter::isSignatureLegal()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02142">populateStdToLLVMConversionPatterns()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00797">mlir::vector::populateVectorSlicesLoweringPatterns()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLLVM_8cpp_source.html#l00559">populateLinalgToLLVMConversionPatterns()</a>.</p>

</div>
</div>
<a id="a32cc57e028b9dcf6b1d9dc54b6489c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cc57e028b9dcf6b1d9dc54b6489c58">&#9670;&nbsp;</a></span>populateVectorToVectorConversionPatterns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::populateVectorToVectorConversionPatterns </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OwningRewritePatternList.html">OwningRewritePatternList</a> &amp;&#160;</td>
          <td class="paramname"><em>patterns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>coarseVectorShape</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>fineVectorShape</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect a set of patterns to convert from the Vector dialect to itself. </p>
<p>Should be merged with populateVectorToAffineLoopsConversionPatterns. </p>

</div>
</div>
<a id="a79f1e788f04c669e931f8fc314d7b597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f1e788f04c669e931f8fc314d7b597">&#9670;&nbsp;</a></span>printDimAndSymbolList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::printDimAndSymbolList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html#ae9f435d73bdd799ad9f8ace519293a45">Operation::operand_iterator</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1OpAsmPrinter.html">OpAsmPrinter</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints dimension and symbol list. </p>

<p class="definition">Definition at line <a class="el" href="Ops_8cpp_source.html#l00165">165</a> of file <a class="el" href="Ops_8cpp_source.html">Ops.cpp</a>.</p>

<p class="reference">References <a class="el" href="STLExtras_8h_source.html#l00249">mlir::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;::drop_front()</a>, <a class="el" href="STLExtras_8h_source.html#l00237">mlir::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;::size()</a>, and <a class="el" href="STLExtras_8h_source.html#l00260">mlir::detail::indexed_accessor_range_base&lt; DerivedT, BaseT, T, PointerT, ReferenceT &gt;::take_front()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8h_source.html#l00320">mlir::DmaWaitOp::getNumElements()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00260">mlir::AffineApplyOp::print()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01672">print()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01293">printBound()</a>.</p>

</div>
</div>
<a id="a9f574bfd0dab3a0967cf1e3c77780fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f574bfd0dab3a0967cf1e3c77780fd4">&#9670;&nbsp;</a></span>promoteIfSingleIteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::promoteIfSingleIteration </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes the loop body of a AffineForOp to its containing block if the AffineForOp was known to have a single iteration. </p>
<p>Promotes the loop body of a forOp to its containing block if the forOp was known to have a single iteration.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00110">110</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="Operation_8h_source.html#l00097">mlir::Operation::getBlock()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00091">getConstantTripCount()</a>, <a class="el" href="Operation_8h_source.html#l00107">mlir::Operation::getLoc()</a>, <a class="el" href="AffineOps_8h_source.html#l00574">mlir::AffineBound::getMap()</a>, <a class="el" href="Block_8h_source.html#l00107">mlir::Block::getOperations()</a>, <a class="el" href="Operation_8h_source.html#l00121">mlir::Operation::getParentOfType()</a>, <a class="el" href="AffineOps_8h_source.html#l00585">mlir::AffineBound::operand_begin()</a>, <a class="el" href="AffineOps_8h_source.html#l00586">mlir::AffineBound::operand_end()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00133">createAffineDataCopyGenerationPass()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00167">generateLoop()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00410">loopUnrollByFactor()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00384">loopUnrollFull()</a>, <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">loopUnrollJamByFactor()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00154">promoteSingleIterationLoops()</a>.</p>

</div>
</div>
<a id="a30b3888bdf62ec2761952b4cd27770ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b3888bdf62ec2761952b4cd27770ef">&#9670;&nbsp;</a></span>promoteSingleIterationLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::promoteSingleIterationLoops </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1FuncOp.html">FuncOp</a>&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes all single iteration AffineForOp's in the Function, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>. </p>
<p>Promotes all single iteration for op's in the <a class="el" href="classmlir_1_1FuncOp.html" title="FuncOp represents a function, or an operation containing one region that forms a CFG(Control Flow Gra...">FuncOp</a>, i.e., moves their body into the containing <a class="el" href="classmlir_1_1Block.html" title="Block represents an ordered list of Operations. ">Block</a>.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00154">154</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00110">promoteIfSingleIteration()</a>, and <a class="el" href="OpDefinition_8h_source.html#l00214">mlir::OpState::walk()</a>.</p>

</div>
</div>
<a id="a7173c36d6b113dcdb0599eb672526b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7173c36d6b113dcdb0599eb672526b43">&#9670;&nbsp;</a></span>promoteToWorkgroupMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::promoteToWorkgroupMemory </td>
          <td>(</td>
          <td class="paramtype">gpu::GPUFuncOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Promotes a function argument to workgroup memory in the given function. </p>
<p>The copies will be inserted in the beginning and in the end of the function. </p>

<p class="reference">Referenced by <a class="el" href="MemoryPromotion_8cpp_source.html#l00136">insertCopies()</a>.</p>

</div>
</div>
<a id="a570c0f30ef4fa5cf0eadca4bfbe77a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570c0f30ef4fa5cf0eadca4bfbe77a85">&#9670;&nbsp;</a></span>registerAllDialects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerAllDialects </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers all dialects with the specified <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a>. </p>
<p>Registers all dialects and their const folding hooks with the specified <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a>.</p>

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8cpp_source.html#l00057">57</a> of file <a class="el" href="IR_2Dialect_8cpp_source.html">Dialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Dialect_8cpp_source.html#l00035">dialectHooksRegistry</a>, and <a class="el" href="IR_2Dialect_8cpp_source.html#l00031">dialectRegistry</a>.</p>

<p class="reference">Referenced by <a class="el" href="MLIRContext_8cpp_source.html#l00232">mlir::MLIRContext::MLIRContext()</a>.</p>

</div>
</div>
<a id="a45f01195b0860006a1eb061e17634963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f01195b0860006a1eb061e17634963">&#9670;&nbsp;</a></span>registerDialect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteDialect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerDialect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility to register a dialect. </p>
<p>Client can register their dialect with the global registry by calling <a class="el" href="namespacemlir.html#a45f01195b0860006a1eb061e17634963" title="Utility to register a dialect. ">registerDialect&lt;MyDialect&gt;()</a>; </p>

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8h_source.html#l00295">295</a> of file <a class="el" href="IR_2Dialect_8h_source.html">Dialect.h</a>.</p>

<p class="reference">References <a class="el" href="IR_2Dialect_8h_source.html#l00295">registerDialect()</a>, and <a class="el" href="IR_2Dialect_8cpp_source.html#l00039">registerDialectAllocator()</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Dialect_8h_source.html#l00249">mlir::Dialect::addInterfaces()</a>, and <a class="el" href="IR_2Dialect_8h_source.html#l00295">registerDialect()</a>.</p>

</div>
</div>
<a id="a251e44b317cf2b6a881db05d7c2110cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251e44b317cf2b6a881db05d7c2110cf">&#9670;&nbsp;</a></span>registerDialectAllocator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerDialectAllocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a94ae7dda0e636afc0a58acb0ed3342b4">DialectAllocatorFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a specific dialect creation function with the system, typically used through the <a class="el" href="structmlir_1_1DialectRegistration.html" title="DialectRegistration provides a global initializer that registers a Dialect allocation routine...">DialectRegistration</a> template. </p>

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8cpp_source.html#l00039">39</a> of file <a class="el" href="IR_2Dialect_8cpp_source.html">Dialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Dialect_8cpp_source.html#l00031">dialectRegistry</a>.</p>

<p class="reference">Referenced by <a class="el" href="IR_2Dialect_8h_source.html#l00295">registerDialect()</a>.</p>

</div>
</div>
<a id="adc637be7593f7a60dfc71a61256f41ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc637be7593f7a60dfc71a61256f41ea">&#9670;&nbsp;</a></span>registerDialectHooksSetter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerDialectHooksSetter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a485453da011e03403b043a915fd368ab">DialectHooksSetter</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a function that will set hooks in the registered dialects based on information coming from <a class="el" href="structmlir_1_1DialectHooksRegistration.html" title="DialectHooksRegistration provides a global initializer that registers a dialect hooks setter routine...">DialectHooksRegistration</a>. </p>
<p>Registers a function to set specific hooks for a specific dialect, typically used through the <a class="el" href="structmlir_1_1DialectHooksRegistration.html" title="DialectHooksRegistration provides a global initializer that registers a dialect hooks setter routine...">DialectHooksRegistration</a> template.</p>

<p class="definition">Definition at line <a class="el" href="IR_2Dialect_8cpp_source.html#l00047">47</a> of file <a class="el" href="IR_2Dialect_8cpp_source.html">Dialect.cpp</a>.</p>

<p class="reference">References <a class="el" href="IR_2Dialect_8cpp_source.html#l00035">dialectHooksRegistry</a>.</p>

<p class="reference">Referenced by <a class="el" href="DialectHooks_8h_source.html#l00051">mlir::DialectHooksRegistration&lt; ConcreteHooks &gt;::DialectHooksRegistration()</a>, and <a class="el" href="DialectHooks_8h_source.html#l00037">mlir::DialectHooks::getExtractElementHook()</a>.</p>

</div>
</div>
<a id="a0664e453602a0a69ceb9bad705d4ac10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0664e453602a0a69ceb9bad705d4ac10">&#9670;&nbsp;</a></span>registerPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPass </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a3bf899dff597a809a700779b46dc4972">PassID</a> *&#160;</td>
          <td class="paramname"><em>passID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a48db7fd5d49bfa7ca8c81e5a6a058683">PassAllocatorFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pass allocator function with the system, typically used through the <a class="el" href="structmlir_1_1PassRegistration.html" title="PassRegistration provides a global initializer that registers a Pass allocation routine for a concret...">PassRegistration</a> template. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00058">58</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00021">passRegistry</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00117">mlir::PassRegistration&lt; ConcretePass &gt;::PassRegistration()</a>.</p>

</div>
</div>
<a id="aa5c4edce10b597637635af55bb162477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5c4edce10b597637635af55bb162477">&#9670;&nbsp;</a></span>registerPassManagerCLOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPassManagerCLOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a set of useful command-line options that can be used to configure a pass manager. </p>
<p>The values of these options can be applied via the 'applyPassManagerCLOptions' method below. </p>

<p class="definition">Definition at line <a class="el" href="PassManagerOptions_8cpp_source.html#l00147">147</a> of file <a class="el" href="PassManagerOptions_8cpp_source.html">PassManagerOptions.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassManager_8h_source.html#l00193">mlir::PassManager::IRPrinterConfig::shouldPrintAfterOnlyOnChange()</a>.</p>

</div>
</div>
<a id="aff481c2677a398dcb9c3aacebebc42c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff481c2677a398dcb9c3aacebebc42c3">&#9670;&nbsp;</a></span>registerPassPipeline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::registerPassPipeline </td>
          <td>(</td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StringRef&#160;</td>
          <td class="paramname"><em>description</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemlir.html#a9d158c94373a029243fd7006eb79cc87">PassRegistryFunction</a> &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Register a specific dialect pipeline registry function with the system, typically used through the <a class="el" href="structmlir_1_1PassPipelineRegistration.html" title="PassPipelineRegistration provides a global initializer that registers a Pass pipeline builder routine...">PassPipelineRegistration</a> template. </p>

<p class="definition">Definition at line <a class="el" href="PassRegistry_8cpp_source.html#l00042">42</a> of file <a class="el" href="PassRegistry_8cpp_source.html">PassRegistry.cpp</a>.</p>

<p class="reference">References <a class="el" href="PassRegistry_8cpp_source.html#l00025">passPipelineRegistry</a>.</p>

<p class="reference">Referenced by <a class="el" href="PassRegistry_8h_source.html#l00142">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, and <a class="el" href="PassRegistry_8h_source.html#l00159">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>.</p>

</div>
</div>
<a id="a383f580b17a936443f42d199484926da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a383f580b17a936443f42d199484926da">&#9670;&nbsp;</a></span>replaceAllMemRefUsesWith() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::replaceAllMemRefUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oldMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexRemap</em> = <code><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>domInstFilter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>postDomInstFilter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all "dereferencing" uses of <code>oldMemRef</code> with <code>newMemRef</code> while optionally remapping the old memref's indices using the supplied affine map, <code>indexRemap</code>. </p>
<p>The new memref could be of a different shape or rank. <code>extraIndices</code> provides any additional access indices to be added to the start.</p>
<p><code>indexRemap</code> remaps indices of the old memref access to a new set of indices that are used to index the memref. Additional input operands to indexRemap can be optionally provided in <code>extraOperands</code>, and they occupy the start of its input list. <code>indexRemap</code>'s dimensional inputs are expected to correspond to memref's indices, and its symbolic inputs if any should be provided in <code>symbolOperands</code>.</p>
<p><code>domInstFilter</code>, if non-null, restricts the replacement to only those operations that are dominated by the former; similarly, <code>postDomInstFilter</code> restricts replacement to only those operations that are postdominated by it.</p>
<p>Returns true on success and false if the replacement is not possible, whenever a memref is used as an operand in a non-dereferencing context, except for dealloc's on the memref which are left untouched. See comments at function definition for an example. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00218">218</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00264">mlir::Type::cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00411">getElementType()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Operation_8h_source.html#l00121">mlir::Operation::getParentOfType()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Value_8h_source.html#l00167">mlir::Value::getUsers()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00033">isMemRefDereferencingOp()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l00887">createPrivateMemRef()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00064">doubleBuffer()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00390">normalizeMemRef()</a>.</p>

</div>
</div>
<a id="aeaafdc3b50b593f1156dfd34bfac0833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaafdc3b50b593f1156dfd34bfac0833">&#9670;&nbsp;</a></span>replaceAllMemRefUsesWith() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::replaceAllMemRefUsesWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>oldMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>newMemRef</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraIndices</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>indexRemap</em> = <code><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>extraOperands</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>symbolOperands</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the same replacement as the other version above but only for the dereferencing uses of <code>oldMemRef</code> in <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">49</a> of file <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html">Utils.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l00731">canonicalizeMapAndOperands()</a>, <a class="el" href="Types_8h_source.html#l00264">mlir::Type::cast()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00329">mlir::OpBuilder::createOperation()</a>, <a class="el" href="Matchers_8h_source.html#l00180">mlir::detail::enumerate()</a>, <a class="el" href="Operation_8cpp_source.html#l00501">mlir::Operation::erase()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00589">fullyComposeAffineMapAndOperands()</a>, <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00055">mlir::AffineMapAttr::get()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00041">getAffineMapAttrForMemRef()</a>, <a class="el" href="Operation_8h_source.html#l00277">mlir::Operation::getAttrs()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00411">getElementType()</a>, <a class="el" href="Operation_8h_source.html#l00107">mlir::Operation::getLoc()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00268">mlir::Builder::getMultiDimIdentityMap()</a>, <a class="el" href="Operation_8h_source.html#l00061">mlir::Operation::getName()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00162">mlir::AffineMap::getNumInputs()</a>, <a class="el" href="Operation_8h_source.html#l00207">mlir::Operation::getNumOperands()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00158">mlir::AffineMap::getNumResults()</a>, <a class="el" href="Operation_8cpp_source.html#l00548">mlir::Operation::getNumResults()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="Operation_8h_source.html#l00222">mlir::Operation::getOperands()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00167">mlir::AffineMap::getResults()</a>, <a class="el" href="Operation_8h_source.html#l00256">mlir::Operation::getResults()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Operation_8h_source.html#l00200">mlir::Operation::hasResizableOperandsList()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00033">isMemRefDereferencingOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00118">isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00179">isValidSymbol()</a>, <a class="el" href="Operation_8h_source.html#l00218">mlir::Operation::operand_begin()</a>, <a class="el" href="Operation_8h_source.html#l00219">mlir::Operation::operand_end()</a>, <a class="el" href="Operation_8h_source.html#l00146">mlir::Operation::replaceAllUsesWith()</a>, <a class="el" href="OperationSupport_8h_source.html#l00321">mlir::OperationState::setOperandListToResizable()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00280">simplifyAffineMap()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

</div>
</div>
<a id="a15a5d204dd78ac563241168e6b2e40eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a5d204dd78ac563241168e6b2e40eb">&#9670;&nbsp;</a></span>replaceAllUsesInRegionWith()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::replaceAllUsesInRegionWith </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>orig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Value.html">Value</a>&#160;</td>
          <td class="paramname"><em>replacement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all uses of <code>orig</code> within the given region with <code>replacement</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00021">21</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Value_8h_source.html#l00151">mlir::Value::getUses()</a>, and <a class="el" href="IR_2Region_8h_source.html#l00087">mlir::Region::isAncestor()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00023">areValuesDefinedAbove()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01041">coalesceLoops()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00341">createLaunchFromOp()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00681">stripmineSink()</a>.</p>

</div>
</div>
<a id="a3741dc3ccffcfafa71e4540ba59f08c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3741dc3ccffcfafa71e4540ba59f08c0">&#9670;&nbsp;</a></span>shapeRatio() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt; mlir::shapeRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>superShape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>subShape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the multi-dimensional ratio of <code>superShape</code> to <code>subShape</code>. </p>
<p>This is calculated by performing a traversal from minor to major dimensions (i.e. in reverse shape order). If integral division is not possible, returns None. The ArrayRefs are assumed (and enforced) to only contain &gt; 1 values. This constraint comes from the fact that they are meant to be used with VectorTypes, for which the property holds by construction.</p>
<p>Examples:</p><ul>
<li>shapeRatio({3, 4, 5, 8}, {2, 5, 2}) returns {3, 2, 1, 4}</li>
<li>shapeRatio({3, 4, 4, 8}, {2, 5, 2}) returns None</li>
<li>shapeRatio({1, 2, 10, 32}, {2, 5, 2}) returns {1, 1, 2, 16} </li>
</ul>

<p class="definition">Definition at line <a class="el" href="VectorAnalysis_8cpp_source.html#l00033">33</a> of file <a class="el" href="VectorAnalysis_8cpp_source.html">VectorAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00063">mlir::StandardTypes::None</a>, and <a class="el" href="Functional_8h_source.html#l00085">mlir::functional::zipApply()</a>.</p>

<p class="reference">Referenced by <a class="el" href="VectorTransforms_8cpp_source.html#l00126">generateExtractSlicesOpResultType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00493">generateTransferOpSlices()</a>, <a class="el" href="VectorAnalysis_8cpp_source.html#l00156">getEnclosingforOps()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00175">initUnrolledVectorState()</a>, <a class="el" href="VectorAnalysis_8cpp_source.html#l00073">shapeRatio()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00309">unrollSingleResultStructuredOp()</a>.</p>

</div>
</div>
<a id="a937430eb9b6e13bfb05e6ecc5649a816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937430eb9b6e13bfb05e6ecc5649a816">&#9670;&nbsp;</a></span>shapeRatio() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1Optional.html">Optional</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; int64_t, 4 &gt; &gt; mlir::shapeRatio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1VectorType.html">VectorType</a>&#160;</td>
          <td class="paramname"><em>superVectorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1VectorType.html">VectorType</a>&#160;</td>
          <td class="paramname"><em>subVectorType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the multi-dimensional ratio of the shapes of <code>superVector</code> to <code>subVector</code>. </p>
<p>If integral division is not possible, returns None. Assumes and enforces that the VectorTypes have the same elemental type. </p>

<p class="definition">Definition at line <a class="el" href="VectorAnalysis_8cpp_source.html#l00073">73</a> of file <a class="el" href="VectorAnalysis_8cpp_source.html">VectorAnalysis.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8cpp_source.html#l00228">mlir::VectorType::getShape()</a>, and <a class="el" href="VectorAnalysis_8cpp_source.html#l00033">shapeRatio()</a>.</p>

</div>
</div>
<a id="acbf369c69cfb613cd018ef4ce188809c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf369c69cfb613cd018ef4ce188809c">&#9670;&nbsp;</a></span>simplifyAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::simplifyAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a>&#160;</td>
          <td class="paramname"><em>expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify an affine expression by flattening and some amount of simple analysis. </p>
<p>Simplify the affine expression by flattening it and reconstructing it.</p>
<p>This has complexity linear in the number of nodes in 'expr'. Returns the simplified expression, which is the same as the input expression if it can't be simplified. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00839">839</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8cpp_source.html#l00021">mlir::AffineExpr::getContext()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00123">mlir::AffineExpr::isPureAffine()</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00269">mlir::SimpleAffineExprFlattener::localExprs</a>, <a class="el" href="AffineExprVisitor_8h_source.html#l00254">mlir::SimpleAffineExprFlattener::operandExprStack</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00594">toAffineExpr()</a>, and <a class="el" href="AffineExprVisitor_8h_source.html#l00073">mlir::AffineExprVisitor&lt; SubClass, RetTy &gt;::walkPostOrder()</a>.</p>

<p class="reference">Referenced by <a class="el" href="StandardTypes_8cpp_source.html#l00707">canonicalizeStridedLayout()</a>, <a class="el" href="AffineExpr_8h_source.html#l00241">mlir::AffineExpr::cast()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00887">createPrivateMemRef()</a>, <a class="el" href="LoopFusionUtils_8cpp_source.html#l00337">getConstDifference()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01579">mlir::FlatAffineConstraints::getSliceBounds()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00523">getStridesAndOffset()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00301">mlir::edsc::ops::linalg_conv_nhwc()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00335">mlir::edsc::ops::linalg_dilated_conv_nhwc()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00430">makeCanonicalStridedLayoutExpr()</a>, <a class="el" href="AffineStructures_8h_source.html#l00611">mlir::FlatAffineConstraints::setIdValues()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00172">mlir::MutableAffineMap::simplify()</a>, and <a class="el" href="AffineMap_8cpp_source.html#l00280">simplifyAffineMap()</a>.</p>

</div>
</div>
<a id="a014d8e82c51794d145267690b2b5bd58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014d8e82c51794d145267690b2b5bd58">&#9670;&nbsp;</a></span>simplifyAffineMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a> mlir::simplifyAffineMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1AffineMap.html">AffineMap</a>&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify an affine map by simplifying its underlying <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> results. </p>

<p class="definition">Definition at line <a class="el" href="AffineMap_8cpp_source.html#l00280">280</a> of file <a class="el" href="AffineMap_8cpp_source.html">AffineMap.cpp</a>.</p>

<p class="reference">References <a class="el" href="MLIRContext_8cpp_source.html#l00590">mlir::AffineMap::get()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00150">mlir::AffineMap::getNumDims()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00154">mlir::AffineMap::getNumSymbols()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00167">mlir::AffineMap::getResults()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00839">simplifyAffineExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l01751">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00456">mlir::AffineApplyNormalizer::AffineApplyNormalizer()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00220">mlir::AffineValueMap::difference()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00663">mlir::MemRefAccess::getAccessMap()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00044">getCleanupLoopLowerBound()</a>, <a class="el" href="AffineMap_8h_source.html#l00154">hash_value()</a>, and <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">replaceAllMemRefUsesWith()</a>.</p>

</div>
</div>
<a id="a303077ea0260053bc46cb584abb7767f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303077ea0260053bc46cb584abb7767f">&#9670;&nbsp;</a></span>simplifyRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::simplifyRegions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run a set of structural simplifications over the given regions. </p>
<p>This includes transformations like unreachable block elimination, dead argument elimination, as well as some other DCE. This function returns success if any of the regions were simplified, failure otherwise. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00342">342</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00076">eraseUnreachableBlocks()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00322">runRegionDCE()</a>, <a class="el" href="LogicalResult_8h_source.html#l00039">succeeded()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00023">areValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="ac2a23242fc1efaad4c85fb8f421d2d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a23242fc1efaad4c85fb8f421d2d72">&#9670;&nbsp;</a></span>sinkLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::sinkLoop </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>loopDepth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sinks 'forOp' by 'loopDepth' levels by performing a series of loop interchanges. </p>
<p>Performs a series of loop interchanges to sink 'forOp' 'loopDepth' levels deeper in the loop nest.</p>
<p>Requires that 'forOp' is part of a perfect nest with 'loopDepth' AffineForOps consecutively nested under it.</p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00646">646</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00499">interchangeLoops()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00572">interchangeLoops()</a>.</p>

</div>
</div>
<a id="ad4e57efabe41ec9f1d263ed7a42c7f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e57efabe41ec9f1d263ed7a42c7f15">&#9670;&nbsp;</a></span>sinkSequentialLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AffineForOp mlir::sinkSequentialLoops </td>
          <td>(</td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>forOp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00592">592</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00524">checkLoopInterchangeDependences()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00857">getDependenceComponents()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00373">getPerfectlyNestedLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00499">interchangeLoops()</a>, <a class="el" href="namespacemlir_1_1matcher.html#add2d6ea67e8745edd1987358b954a5e6">mlir::matcher::isParallelLoop()</a>, <a class="el" href="AffineAnalysis_8h_source.html#l00085">mlir::DependenceComponent::lb</a>, and <a class="el" href="AffineAnalysis_8h_source.html#l00087">mlir::DependenceComponent::ub</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopFusion_8cpp_source.html#l01099">isFusionProfitable()</a>, and <a class="el" href="LoopFusion_8cpp_source.html#l00861">sinkSequentialLoops()</a>.</p>

</div>
</div>
<a id="a2320d5e3423bb76edf4048a5674f8f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2320d5e3423bb76edf4048a5674f8f8e">&#9670;&nbsp;</a></span>splitAndProcessBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::splitAndProcessBuffer </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::MemoryBuffer &gt;&#160;</td>
          <td class="paramname"><em>originalBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#aafb0c2458571cd80ebb876d979e24346">ChunkBufferHandler</a>&#160;</td>
          <td class="paramname"><em>processChunkBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits the specified buffer on a marker (<code>// -----</code>), processes each chunk independently according to the normal <code>processChunkBuffer</code> logic, and writes all results to <code>os</code>. </p>
<p>This is used to allow a large number of small independent tests to be put into a single file. </p>

<p class="definition">Definition at line <a class="el" href="ToolUtilities_8cpp_source.html#l00021">21</a> of file <a class="el" href="ToolUtilities_8cpp_source.html">ToolUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>.</p>

<p class="reference">Referenced by <a class="el" href="MlirOptMain_8cpp_source.html#l00067">processBuffer()</a>.</p>

</div>
</div>
<a id="a57a1cb2e1046f84d6328600b92c99e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a1cb2e1046f84d6328600b92c99e52">&#9670;&nbsp;</a></span>succeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::succeeded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function that returns true if the provided <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> corresponds to a success value. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00039">39</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00019">mlir::LogicalResult::Success</a>, and <a class="el" href="structmlir_1_1LogicalResult.html#a367e2bef1a5e5122bc9d0484479a353a">mlir::LogicalResult::value</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l01595">affineDataCopyGenerate()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">canonicalizeLoopBounds()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00161">mlir::MemRefRegion::compute()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00387">computeReshapeCollapsedType()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00307">mlir::OpBuilder::createOrFold()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00887">createPrivateMemRef()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00261">deleteDeadness()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00221">mlir::detail::DiagnosticEngineImpl::emit()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00479">extractStrides()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01833">mlir::AffineLoadOp::fold()</a>, <a class="el" href="Operation_8cpp_source.html#l00603">mlir::Operation::fold()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01354">foldLoopBounds()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00167">generateLoop()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00054">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT &gt;::get()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02438">getNewNumDimsSymbols()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00523">getStridesAndOffset()</a>, <a class="el" href="Ops_8cpp_source.html#l02559">inferSubViewResultType()</a>, <a class="el" href="Inliner_8cpp_source.html#l00255">inlineSCC()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00050">isFnEntryBlock()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01584">mlir::TypeConverter::isLegal()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00734">isStrided()</a>, <a class="el" href="Matchers_8h_source.html#l00062">mlir::detail::constant_op_binder&lt; AttrT &gt;::match()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00966">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00789">mlir::detail::ConversionPatternRewriterImpl::notifyRegionWasClonedBefore()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00101">parseAnyType()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseArgumentList()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00239">parseArrayType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00625">parseAttributions()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01096">parseBranchConditionalOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00093">parseFunctionResultList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00127">mlir::impl::parseFunctionSignature()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00952">parseGlobalOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01784">parseGlobalVariableOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00658">parseGPUFuncOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01947">parseGroupNonUniformIAddOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00919">parseOptionalKeywordAlternative()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02926">parseSpecConstantOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00446">parseStructMemberDecorations()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00492">parseStructType()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00175">parseUniformType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00300">parseVariableDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03092">parseVariableOp()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00235">mlir::linalg::permuteGenericLinalgOp()</a>, <a class="el" href="Ops_8cpp_source.html#l02341">print()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00284">mlir::linalg::promoteSubviewsLinalgOp()</a>, <a class="el" href="Pass_8cpp_source.html#l00504">runWithCrashRecovery()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00446">mlir::UnrankedMemRefDescriptor::setMemRefDescPtr()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00342">simplifyRegions()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00906">tryIsolateBands()</a>, <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00216">tryRewriteAffineMulEwSigned()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00190">mlir::linalg::vectorizeLinalgOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00524">verify()</a>, and <a class="el" href="SymbolTable_8cpp_source.html#l00453">walkSymbolScopes()</a>.</p>

</div>
</div>
<a id="a5f55c06c7c4aeace3f6824dd68f8b1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f55c06c7c4aeace3f6824dd68f8b1ed">&#9670;&nbsp;</a></span>success()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::success </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isSuccess</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to generate a <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a>. </p>
<p>If isSuccess is true a <code>success</code> result is generated, otherwise a 'failure' result is generated. </p>

<p class="definition">Definition at line <a class="el" href="LogicalResult_8h_source.html#l00025">25</a> of file <a class="el" href="LogicalResult_8h_source.html">LogicalResult.h</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00019">mlir::LogicalResult::Failure</a>, and <a class="el" href="LogicalResult_8h_source.html#l00019">mlir::LogicalResult::Success</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8cpp_source.html#l00833">mlir::FlatAffineConstraints::addAffineForOpDomain()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01751">mlir::FlatAffineConstraints::addLowerOrUpperBound()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00383">addMemRefAccessConstraints()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00474">addMissingLoopIVBounds()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01842">mlir::FlatAffineConstraints::addSliceBounds()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00532">mlir::PassPipelineCLParser::addToPipeline()</a>, <a class="el" href="OpImplementation_8h_source.html#l00608">mlir::OpAsmParser::addTypesToList()</a>, <a class="el" href="OpImplementation_8h_source.html#l00600">mlir::OpAsmParser::addTypeToList()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00661">analyzeProfitability()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00371">boundCheckLoadOrStoreOp()</a>, <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01400">canonicalizeLoopBounds()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00127">checkLoopNestMappable()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00101">checkLoopNestMappableImpl()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00145">checkLoopOpMappable()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00236">checkTensorElementType()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00036">collectValidReferencesFor()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00139">compileAndExecute()</a>, <a class="el" href="JitRunner_8cpp_source.html#l00177">compileAndExecuteSingleFloatReturnFunction()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00641">mlir::FlatAffineConstraints::composeMap()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00713">mlir::FlatAffineConstraints::composeMatchingMap()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00161">mlir::MemRefRegion::compute()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00029">computeConversionSet()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00520">computeSliceUnion()</a>, <a class="el" href="AffineMap_8cpp_source.html#l00180">mlir::AffineMap::constantFold()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02064">mlir::FlatAffineConstraints::constantFoldId()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00731">mlir::detail::ConversionPatternRewriterImpl::convertBlockSignature()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00485">convertLoopNestToGPULaunch()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00270">mlir::LLVM::ModuleTranslation::convertOperation()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01599">mlir::TypeConverter::convertSignatureArg()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01562">mlir::TypeConverter::convertType()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l01574">mlir::TypeConverter::convertTypes()</a>, <a class="el" href="AffineDataCopyGeneration_8cpp_source.html#l00133">createAffineDataCopyGenerationPass()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00305">createLaunchBody()</a>, <a class="el" href="LoopsToGPU_8cpp_source.html#l00341">createLaunchFromOp()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00261">deleteDeadness()</a>, <a class="el" href="LinalgToLoops_8cpp_source.html#l00071">emitLoopRanges()</a>, <a class="el" href="Serializer_8cpp_source.html#l00038">encodeInstructionInto()</a>, <a class="el" href="SPIRVBinaryUtils_8cpp_source.html#l00052">mlir::spirv::encodeStringLiteralInto()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00076">eraseUnreachableBlocks()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00479">extractStrides()</a>, <a class="el" href="Parser_8cpp_source.html#l01430">extractSymbolReference()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00076">extractValueFromConstOp()</a>, <a class="el" href="Operation_8cpp_source.html#l00603">mlir::Operation::fold()</a>, <a class="el" href="OpDefinition_8h_source.html#l00316">mlir::FoldingHook&lt; ConcreteType, isSingleResult, typename std::enable_if&lt; isSingleResult &gt;::type &gt;::foldHook()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01354">foldLoopBounds()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00820">foldMemRefCast()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="Analysis_2Utils_8cpp_source.html#l00047">mlir::ComputationSliceState::getAsConstraints()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00115">mlir::DialectAsmParser::getCurrentLocation()</a>, <a class="el" href="OpImplementation_8h_source.html#l00229">mlir::OpAsmParser::getCurrentLocation()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00068">getFlattenedAffineExprs()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l00115">getFlattenedAffineExprs()</a>, <a class="el" href="OpDefinition_8h_source.html#l01044">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;::getFromOpaquePointer()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00113">getI64SubArray()</a>, <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00542">getICmpPredicate()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00091">getIndexSet()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00073">getInterfaceVariables()</a>, <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00248">getOrInsertBuiltinVariable()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00523">getStridesAndOffset()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00864">hoistOpsBetween()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00024">mlir::detail::inferReturnTensorTypes()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00279">inlineCall()</a>, <a class="el" href="Inliner_8cpp_source.html#l00156">inlineCallsInSCC()</a>, <a class="el" href="InliningUtils_8cpp_source.html#l00128">inlineRegion()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00229">instBodySkew()</a>, <a class="el" href="ExecutionEngine_8h_source.html#l00112">mlir::ExecutionEngine::invoke()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00050">isFnEntryBlock()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00936">isIntegerArrayAttrConfinedToRange()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00956">isIntegerArrayAttrConfinedToShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00921">isIntegerArrayAttrSmallerThanShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00979">isSumOfIntegerArrayAttrConfinedToShape()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00509">isValidExtractOrInsertSlicesType()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00410">loopUnrollByFactor()</a>, <a class="el" href="LoopUnrollAndJam_8cpp_source.html#l00116">loopUnrollJamByFactor()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00100">lowerEntryPointABIAttr()</a>, <a class="el" href="DialectConversion_8cpp_source.html#l00966">mlir::ConversionPattern::matchAndRewrite()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00390">normalizeMemRef()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00107">mlir::OperationFolder::notifyRemoval()</a>, <a class="el" href="Ops_8cpp_source.html#l02753">operator&lt;&lt;()</a>, <a class="el" href="Diagnostics_8cpp_source.html#l00799">mlir::detail::ParallelDiagnosticHandlerImpl::ParallelDiagnosticHandlerImpl()</a>, <a class="el" href="Module_8cpp_source.html#l00035">mlir::ModuleOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00238">mlir::AffineApplyOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01385">mlir::DmaStartOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00881">mlir::AffineDmaStartOp::parse()</a>, <a class="el" href="Ops_8cpp_source.html#l01511">mlir::DmaWaitOp::parse()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01029">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00760">parseAccessChainOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00776">parseAddressOfOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01244">parseAffineForOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01624">parseAffineIfOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l02013">parseAffinePrefetchOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00130">parseAllocaOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00258">parseAllocOp()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00017">parseArgumentList()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01355">parseAtomicBinOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01478">parseAtomicCmpXchgOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01381">parseAtomicOrdering()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01418">parseAtomicRMWOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00279">mlir::DialectAsmParser::parseAttribute()</a>, <a class="el" href="OpImplementation_8h_source.html#l00356">mlir::OpAsmParser::parseAttribute()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00625">parseAttributions()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00493">parseBitFieldExtractOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01022">parseBitFieldInsertOp()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01153">parseBound()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01096">parseBranchConditionalOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01070">parseBranchOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00650">parseBrOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00304">parseCallOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00775">parseCmpFOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00622">parseCmpIOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00055">parseCmpOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00568">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01262">parseCompositeExtractOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00934">parseCondBranchOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00676">parseCondBrOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00815">parseConstantOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00075">parseContractionOp()</a>, <a class="el" href="Ops_8cpp_source.html#l00177">parseDimAndSymbolList()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01555">parseEntryPointOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00107">parseEnumAttribute()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01616">parseExecutionModeOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00410">parseExtractElementOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00492">parseExtractValueOp()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00094">parseForOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00091">mlir::detail::PassOptions::parseFromString()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00093">parseFunctionResultList()</a>, <a class="el" href="FunctionImplementation_8cpp_source.html#l00127">mlir::impl::parseFunctionSignature()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00171">parseGEPOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00952">parseGlobalOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01784">parseGlobalVariableOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00828">parseGPUModuleOp()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00174">parseIfOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00530">parseInsertElementOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00575">parseInsertValueOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00204">mlir::DialectAsmParser::parseKeyword()</a>, <a class="el" href="OpImplementation_8h_source.html#l00281">mlir::OpAsmParser::parseKeyword()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00225">parseLoadOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00641">parseLogicalBinaryOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00629">parseLogicalUnaryOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00142">parseMemoryAccessAttributes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02391">parseModuleOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00592">parseNoIOOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00045">parseNVVMSpecialRegisterOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00150">mlir::DialectAsmParser::parseOptionalInteger()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00934">parseOptionalLinkageKeyword()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00274">parseParallelOp()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00377">parsePassPipeline()</a>, <a class="el" href="Ops_8cpp_source.html#l01790">parsePrefetchOp()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00143">parseQuantParams()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00359">parseReduceOp()</a>, <a class="el" href="LoopOps_8cpp_source.html#l00401">parseReduceReturnOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00718">parseReturnOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00617">parseSelectOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00658">parseShiftOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00172">parseShuffleOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01058">parseShuffleVectorOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l02926">parseSpecConstantOp()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00063">parseStorageRange()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00253">parseStoreOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00446">parseStructMemberDecorations()</a>, <a class="el" href="Parser_8cpp_source.html#l00839">parseSymbol()</a>, <a class="el" href="OpImplementation_8h_source.html#l00394">mlir::OpAsmParser::parseSymbolName()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00677">parseTransposeOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01648">parseTupleGetOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00308">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00604">parseUnaryOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00745">parseUndefOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00300">parseVariableDecorations()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03092">parseVariableOp()</a>, <a class="el" href="PassRegistry_8h_source.html#l00142">mlir::PassPipelineRegistration&lt; Options &gt;::PassPipelineRegistration()</a>, <a class="el" href="PassRegistry_8h_source.html#l00159">mlir::PassPipelineRegistration&lt; EmptyPipelineOptions &gt;::PassPipelineRegistration()</a>, <a class="el" href="MlirOptMain_8cpp_source.html#l00040">performActions()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00220">mlir::linalg::permuteGenericLinalgOpPrecondition()</a>, <a class="el" href="OptUtils_8cpp_source.html#l00063">populatePassManagers()</a>, <a class="el" href="PassRegistry_8cpp_source.html#l00134">mlir::detail::PassOptions::print()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01672">print()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00732">printGPUFuncOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01217">printLLVMFuncOp()</a>, <a class="el" href="TranslateClParser_8cpp_source.html#l00031">printMLIROutput()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00110">promoteIfSingleIteration()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00271">mlir::linalg::promoteSubviewsLinalgOpPrecondition()</a>, <a class="el" href="Diagnostics_8h_source.html#l00434">mlir::DiagnosticEngine::registerHandler()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">replaceAllMemRefUsesWith()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00689">replaceAllSymbolUsesImpl()</a>, <a class="el" href="OpImplementation_8h_source.html#l00468">mlir::OpAsmParser::resolveOperands()</a>, <a class="el" href="LegalizeStandardForSPIRV_8cpp_source.html#l00061">resolveSourceIndices()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00107">roundTripModule()</a>, <a class="el" href="Pass_8cpp_source.html#l00230">mlir::OpPassManager::run()</a>, <a class="el" href="Pass_8cpp_source.html#l00504">runWithCrashRecovery()</a>, <a class="el" href="TranslateRegistration_8cpp_source.html#l00074">serializeModule()</a>, <a class="el" href="AffineStructures_8h_source.html#l00611">mlir::FlatAffineConstraints::setIdValues()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00342">simplifyRegions()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00053">mlir::linalg::tileAndFuseLinalgOpAndSetMarker()</a>, <a class="el" href="LoopTiling_8cpp_source.html#l00177">tileCodeGen()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00041">mlir::linalg::tileLinalgOpAndSetMarker()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00502">topologicalSort()</a>, <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00024">translateModuleToLLVMIR()</a>, <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00068">translateModuleToNVVMIR()</a>, <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00077">translateModuleToROCDLIR()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00336">mlir::OpBuilder::tryFold()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00906">tryIsolateBands()</a>, <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00144">tryRewriteAffineAddEwIsomorphicSigned()</a>, <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00216">tryRewriteAffineMulEwSigned()</a>, <a class="el" href="FoldUtils_8cpp_source.html#l00075">mlir::OperationFolder::tryToFold()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l02744">mlir::FlatAffineConstraints::unionBoundingBox()</a>, <a class="el" href="InferQuantizedTypesPass_8cpp_source.html#l00099">validateTypeConversion()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00847">vectorizeAffineForOp()</a>, <a class="el" href="LinalgTransforms_8cpp_source.html#l00161">mlir::linalg::vectorizeLinalgOpPrecondition()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00903">vectorizeLoopsAndLoadsRecursively()</a>, <a class="el" href="Vectorize_8cpp_source.html#l01109">vectorizeNonTerminals()</a>, <a class="el" href="Vectorize_8cpp_source.html#l01025">vectorizeOneOperation()</a>, <a class="el" href="Vectorize_8cpp_source.html#l01153">vectorizeRootMatch()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00797">vectorizeRootOrTerminal()</a>, <a class="el" href="Module_8cpp_source.html#l00072">mlir::ModuleOp::verify()</a>, <a class="el" href="Function_8cpp_source.html#l00088">mlir::FuncOp::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00267">mlir::AffineApplyOp::verify()</a>, <a class="el" href="OpDefinition_8h_source.html#l00228">mlir::OpState::verify()</a>, <a class="el" href="Ops_8cpp_source.html#l01469">mlir::DmaStartOp::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00954">mlir::AffineDmaStartOp::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01059">mlir::AffineDmaWaitOp::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01801">mlir::AffineLoadOp::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01898">mlir::AffineStoreOp::verify()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01123">verify()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00127">verifyAllReduce()</a>, <a class="el" href="Operation_8cpp_source.html#l00768">mlir::OpTrait::impl::verifyAtLeastNOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00838">mlir::OpTrait::impl::verifyAtLeastNResults()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00573">verifyAtomicUpdateOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00773">verifyAttributions()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00518">verifyBitFieldExtractOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00108">verifyBlockArgs()</a>, <a class="el" href="FunctionSupport_8h_source.html#l00354">mlir::OpTrait::FunctionLike&lt; ConcreteType &gt;::verifyBody()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00187">verifyCastOp()</a>, <a class="el" href="Traits_8cpp_source.html#l00171">mlir::OpTrait::impl::verifyCompatibleOperandBroadcast()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00054">verifyCompatibleShape()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00026">mlir::quant::QuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="StorageUniquerSupport_8h_source.html#l00075">mlir::detail::StorageUserBase&lt; ConcreteT, BaseT, StorageT, UniquerT &gt;::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00055">mlir::IntegerType::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00627">mlir::ComplexType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00217">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="Types_8cpp_source.html#l00074">mlir::OpaqueType::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00210">mlir::VectorType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00258">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00221">mlir::FloatAttr::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00315">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00320">mlir::OpaqueAttr::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00410">mlir::UnrankedMemRefType::verifyConstructionInvariants()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00213">verifyDimAndSymbolIdentifiers()</a>, <a class="el" href="Ops_8cpp_source.html#l02362">verifyDynamicStrides()</a>, <a class="el" href="Attributes_8cpp_source.html#l00208">verifyFloatTypeInvariants()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00178">verifyFuncArgs()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00160">verifyFuncArgsGeneric()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00231">verifyGenericOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00120">verifyIndexOp()</a>, <a class="el" href="InferTypeOpInterface_8cpp_source.html#l00049">mlir::detail::verifyInferredResultTypes()</a>, <a class="el" href="Operation_8cpp_source.html#l00971">mlir::OpTrait::impl::verifyIsTerminator()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00286">verifyLoadStorePtrAndValTypes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00222">verifyMemoryAccessAttribute()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00262">verifyMemorySemantics()</a>, <a class="el" href="Operation_8cpp_source.html#l00759">mlir::OpTrait::impl::verifyNOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00831">mlir::OpTrait::impl::verifyNResults()</a>, <a class="el" href="Operation_8cpp_source.html#l00753">mlir::OpTrait::impl::verifyOneOperand()</a>, <a class="el" href="Operation_8cpp_source.html#l00825">mlir::OpTrait::impl::verifyOneResult()</a>, <a class="el" href="Operation_8cpp_source.html#l00797">mlir::OpTrait::impl::verifyOperandsAreFloatLike()</a>, <a class="el" href="Operation_8cpp_source.html#l00788">mlir::OpTrait::impl::verifyOperandsAreIntegerLike()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00648">mlir::spirv::SPIRVDialect::verifyOperationAttribute()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00046">mlir::gpu::GPUDialect::verifyOperationAttribute()</a>, <a class="el" href="IR_2Dialect_8h_source.html#l00152">mlir::Dialect::verifyOperationAttribute()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01386">verifyPermutationMap()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00081">mlir::Dialect::verifyRegionArgAttribute()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01617">mlir::LLVM::LLVMDialect::verifyRegionArgAttribute()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00680">verifyRegionAttribute()</a>, <a class="el" href="IR_2Dialect_8cpp_source.html#l00090">mlir::Dialect::verifyRegionResultAttribute()</a>, <a class="el" href="Operation_8cpp_source.html#l00983">mlir::OpTrait::impl::verifyResultsAreBoolLike()</a>, <a class="el" href="Operation_8cpp_source.html#l00994">mlir::OpTrait::impl::verifyResultsAreFloatLike()</a>, <a class="el" href="Operation_8cpp_source.html#l01002">mlir::OpTrait::impl::verifyResultsAreIntegerLike()</a>, <a class="el" href="Operation_8cpp_source.html#l00891">mlir::OpTrait::impl::verifySameOperandsAndResultElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00858">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00915">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, <a class="el" href="Operation_8cpp_source.html#l00877">mlir::OpTrait::impl::verifySameOperandsElementType()</a>, <a class="el" href="Operation_8cpp_source.html#l00846">mlir::OpTrait::impl::verifySameOperandsShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00806">mlir::OpTrait::impl::verifySameTypeOperands()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00682">verifyShiftOp()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00154">verifyShuffleOp()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00837">verifyStrideOrDilation()</a>, <a class="el" href="Operation_8cpp_source.html#l00937">verifySuccessor()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00307">mlir::OpTrait::impl::verifySymbol()</a>, <a class="el" href="SymbolTable_8cpp_source.html#l00277">mlir::OpTrait::impl::verifySymbolTable()</a>, <a class="el" href="Operation_8cpp_source.html#l00957">verifyTerminatorSuccessors()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00221">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l00406">mlir::OpTrait::TraitBase&lt; ConcreteType, NResults&lt; N &gt;::Impl &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l00836">mlir::OpTrait::IsIsolatedFromAbove&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l00850">mlir::OpTrait::SingleBlockImplicitTerminator&lt; TerminatorOpType &gt;::Impl&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="OpDefinition_8h_source.html#l00897">mlir::OpTrait::HasParent&lt; ParentOpType &gt;::Impl&lt; ConcreteType &gt;::verifyTrait()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01414">verifyTransferOp()</a>, <a class="el" href="FunctionSupport_8h_source.html#l00348">mlir::OpTrait::FunctionLike&lt; ConcreteType &gt;::verifyType()</a>, <a class="el" href="Operation_8cpp_source.html#l01009">verifyValueSizeAttr()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00718">verifyYield()</a>, <a class="el" href="Operation_8cpp_source.html#l00747">mlir::OpTrait::impl::verifyZeroOperands()</a>, <a class="el" href="Operation_8cpp_source.html#l00819">mlir::OpTrait::impl::verifyZeroResult()</a>, and <a class="el" href="Serializer_8cpp_source.html#l00062">visitInPrettyBlockOrder()</a>.</p>

</div>
</div>
<a id="a623f987acfe618f9aa4823d6c7aec9d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623f987acfe618f9aa4823d6c7aec9d6">&#9670;&nbsp;</a></span>tile() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt;, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00786">786</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00773">tileImpl()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopUtils_8cpp_source.html#l00923">extractFixedOuterLoops()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00799">tileImpl()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00819">tilePerfectlyNested()</a>.</p>

</div>
</div>
<a id="a9494b926a631ef97a52df05ffb305c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9494b926a631ef97a52df05ffb305c00">&#9670;&nbsp;</a></span>tile() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; <a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a>, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; loop::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; loop::ForOp &gt;&#160;</td>
          <td class="paramname"><em>targets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00791">791</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00773">tileImpl()</a>.</p>

</div>
</div>
<a id="a8605009295454f6ebebbbaed546f7963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8605009295454f6ebebbbaed546f7963">&#9670;&nbsp;</a></span>tile() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classllvm_1_1SmallVector.html">SmallVector</a>&lt; AffineForOp, 8 &gt; mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; uint64_t &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AffineForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs tiling (with interchange) by strip-mining the <code>forOps</code> by <code>sizes</code> and sinking them, in their order of occurrence in <code>forOps</code>, under <code>target</code>. </p>
<p>Returns the new AffineForOps, one per <code>forOps</code>, nested immediately under <code>target</code>. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00808">808</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00773">tileImpl()</a>.</p>

</div>
</div>
<a id="a4cc1b7fa275766e04e6ba0ae46fdf181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc1b7fa275766e04e6ba0ae46fdf181">&#9670;&nbsp;</a></span>tile() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a> mlir::tile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; loop::ForOp &gt;&#160;</td>
          <td class="paramname"><em>forOps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">loop::ForOp&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00814">814</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00773">tileImpl()</a>.</p>

</div>
</div>
<a id="afd4c74fa5976a79f6dacf4b212513c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4c74fa5976a79f6dacf4b212513c86">&#9670;&nbsp;</a></span>tileCodeGen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::tileCodeGen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; AffineForOp &gt;&#160;</td>
          <td class="paramname"><em>band</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; unsigned &gt;&#160;</td>
          <td class="paramname"><em>tileSizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tiles the specified band of perfectly nested loops creating tile-space loops and intra-tile loops. </p>
<p>A band is a contiguous set of loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopTiling_8cpp_source.html#l00177">177</a> of file <a class="el" href="LoopTiling_8cpp_source.html">LoopTiling.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopTiling_8cpp_source.html#l00101">constructTiledIndexSetHyperRect()</a>, <a class="el" href="IR_2Builders_8h_source.html#l00294">mlir::OpBuilder::create()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01582">extractForInductionVars()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="AffineAnalysis_8cpp_source.html#l00091">getIndexSet()</a>, <a class="el" href="LoopTiling_8cpp_source.html#l00082">moveLoopBody()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="LoopTiling_8cpp_source.html#l00274">adjustToDivisorsOfTripCounts()</a>.</p>

</div>
</div>
<a id="a8ea72c4e80474afe62e5e8fcbf4bbc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ea72c4e80474afe62e5e8fcbf4bbc75">&#9670;&nbsp;</a></span>tilePerfectlyNested()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacemlir.html#abb10c37aa0b69dce04cbdf7a84e64228">Loops</a> mlir::tilePerfectlyNested </td>
          <td>(</td>
          <td class="paramtype">loop::ForOp&#160;</td>
          <td class="paramname"><em>rootForOp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1Value.html">Value</a> &gt;&#160;</td>
          <td class="paramname"><em>sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tile a nest of loop::ForOp loops rooted at <code>rootForOp</code> with the given (parametric) sizes. </p>
<p>Sizes are expected to be strictly positive values at runtime. If more sizes than loops are provided, discard the trailing values in sizes. Assumes the loop nest is permutable. Returns the newly created intra-tile loops. </p>

<p class="definition">Definition at line <a class="el" href="LoopUtils_8cpp_source.html#l00819">819</a> of file <a class="el" href="LoopUtils_8cpp_source.html">LoopUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="LoopUtils_8cpp_source.html#l00354">getPerfectlyNestedLoopsImpl()</a>, and <a class="el" href="LoopUtils_8cpp_source.html#l00786">tile()</a>.</p>

</div>
</div>
<a id="a99196ca62d2b439656321b2bb00cc309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99196ca62d2b439656321b2bb00cc309">&#9670;&nbsp;</a></span>toAffineExpr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> mlir::toAffineExpr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>eq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numDims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>numSymbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; <a class="el" href="classmlir_1_1AffineExpr.html">AffineExpr</a> &gt;&#160;</td>
          <td class="paramname"><em>localExprs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs an affine expression from a flat ArrayRef. </p>
<p>If there are local identifiers (neither dimensional nor symbolic) that appear in the sum of products expression, 'localExprs' is expected to have the <a class="el" href="classmlir_1_1AffineExpr.html" title="Base type for affine expression. ">AffineExpr</a> for it, and is substituted into. The ArrayRef 'eq' is expected to be in the format [dims, symbols, locals, constant term]. </p>

<p class="definition">Definition at line <a class="el" href="AffineExpr_8cpp_source.html#l00594">594</a> of file <a class="el" href="AffineExpr_8cpp_source.html">AffineExpr.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8h_source.html#l00153">mlir::AffineExpr::expr</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00277">getAffineConstantExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00252">getAffineDimExpr()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00262">getAffineSymbolExpr()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineStructures_8h_source.html#l00366">mlir::FlatAffineConstraints::getInequality()</a>, <a class="el" href="AffineStructures_8cpp_source.html#l01518">mlir::FlatAffineConstraints::getLowerAndUpperBound()</a>, <a class="el" href="AffineExpr_8h_source.html#l00201">operator-()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00839">simplifyAffineExpr()</a>, <a class="el" href="AffineExpr_8cpp_source.html#l00742">mlir::SimpleAffineExprFlattener::visitConstantExpr()</a>, and <a class="el" href="AffineExpr_8cpp_source.html#l00668">mlir::SimpleAffineExprFlattener::visitModExpr()</a>.</p>

</div>
</div>
<a id="a67f5deb263dc3ca56a8c5ae015cba4af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f5deb263dc3ca56a8c5ae015cba4af">&#9670;&nbsp;</a></span>topologicalSort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">llvm::SetVector&lt;<a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; mlir::topologicalSort </td>
          <td>(</td>
          <td class="paramtype">const llvm::SetVector&lt; <a class="el" href="classmlir_1_1Operation.html">Operation</a> *&gt; &amp;&#160;</td>
          <td class="paramname"><em>toSort</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-root DAG topological sort. </p>
<p>Performs a topological sort of the <a class="el" href="classmlir_1_1Operation.html" title="Operation is a basic unit of execution within a function. ">Operation</a> in the <code>toSort</code> SetVector. Returns a topologically sorted SetVector. </p>

<p class="reference">Referenced by <a class="el" href="SliceAnalysis_8cpp_source.html#l00173">DFSPostorder()</a>, <a class="el" href="SliceAnalysis_8cpp_source.html#l00134">getSlice()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00502">topologicalSort()</a>, and <a class="el" href="Vectorize_8cpp_source.html#l01109">vectorizeNonTerminals()</a>.</p>

</div>
</div>
<a id="ae41497963c69c44476e78ff2043d4651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41497963c69c44476e78ff2043d4651">&#9670;&nbsp;</a></span>translateLLVMIRToModule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1OwningModuleRef.html">OwningModuleRef</a> mlir::translateLLVMIRToModule </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; llvm::Module &gt;&#160;</td>
          <td class="paramname"><em>llvmModule</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> module into MLIR's <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> dialect. </p>
<p>The <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context is extracted from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>{}</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00796">796</a> of file <a class="el" href="ConvertFromLLVMIR_8cpp_source.html">ConvertFromLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="Module_8cpp_source.html#l00028">mlir::ModuleOp::create()</a>, <a class="el" href="LogicalResult_8h_source.html#l00045">failed()</a>, <a class="el" href="Location_8cpp_source.html#l00041">mlir::FileLineColLoc::get()</a>, and <a class="el" href="Module_8h_source.html#l00135">mlir::OwningModuleRef::get()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertFromLLVMIR_8cpp_source.html#l00816">translateLLVMIRToModule()</a>.</p>

</div>
</div>
<a id="a0e4058138ab0e09ce0f2a5feb8914d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4058138ab0e09ce0f2a5feb8914d96">&#9670;&nbsp;</a></span>translateModuleToLLVMIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::Module &gt; mlir::translateModuleToLLVMIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1ModuleOp.html">ModuleOp</a>&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given MLIR module into <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR. </p>
<p>The <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context is extracted from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>nullptr</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToLLVMIR_8cpp_source.html#l00024">24</a> of file <a class="el" href="ConvertToLLVMIR_8cpp_source.html">ConvertToLLVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="ConvertToLLVMIR_8cpp.html#ad435b72d0b59c359d51ae381a6b59fcc">registration</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="ExecutionEngine_8cpp_source.html#l00187">mlir::ExecutionEngine::create()</a>.</p>

</div>
</div>
<a id="a3441a2171191be8197234c816fa275d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3441a2171191be8197234c816fa275d6">&#9670;&nbsp;</a></span>translateModuleToNVVMIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::Module &gt; mlir::translateModuleToNVVMIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given LLVM-module-like operation into <a class="el" href="namespacemlir_1_1NVVM.html">NVVM</a> IR. </p>
<p>This conversion requires the registration of the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect and will extract the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>nullptr</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToNVVMIR_8cpp_source.html#l00068">68</a> of file <a class="el" href="ConvertToNVVMIR_8cpp_source.html">ConvertToNVVMIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00033">mlir::gpu::GPUDialect::isKernel()</a>, <a class="el" href="ConvertToNVVMIR_8cpp.html#ab037d293443d09424ecc638f820c0796">registration</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

</div>
</div>
<a id="a1bc65d8bfacc95e54f8bf534fb66b8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc65d8bfacc95e54f8bf534fb66b8db">&#9670;&nbsp;</a></span>translateModuleToROCDLIR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; llvm::Module &gt; mlir::translateModuleToROCDLIR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the given LLVM-module-like operation into <a class="el" href="namespacemlir_1_1ROCDL.html">ROCDL</a> IR. </p>
<p>This conversion requires the registration of the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect and will extract the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> context from the registered <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR dialect. In case of error, report it to the error handler registered with the MLIR context, if any (obtained from the MLIR module), and return <code>nullptr</code>. </p>

<p class="definition">Definition at line <a class="el" href="ConvertToROCDLIR_8cpp_source.html#l00077">77</a> of file <a class="el" href="ConvertToROCDLIR_8cpp_source.html">ConvertToROCDLIR.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="GPUDialect_8h_source.html#l00047">mlir::gpu::GPUDialect::getKernelFuncAttrName()</a>, <a class="el" href="ConvertToROCDLIR_8cpp.html#a9cfe5f4346c60c23df127c8cecd85f68">registration</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

</div>
</div>
<a id="a8311703578f50c8d610c687db37a8dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8311703578f50c8d610c687db37a8dc4">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Operation.html">Operation</a> *&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform (potentially expensive) checks of invariants, used to detect compiler bugs, on this operation and any nested operations. </p>
<p>Perform (potentially expensive) checks of invariants, used to detect compiler bugs.</p>
<p>On error, this reports the error through the <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a> and returns failure. </p>

<p class="definition">Definition at line <a class="el" href="Verifier_8cpp_source.html#l00264">264</a> of file <a class="el" href="Verifier_8cpp_source.html">Verifier.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8cpp_source.html#l00248">mlir::Operation::getContext()</a>.</p>

<p class="reference">Referenced by <a class="el" href="AffineOps_8h_source.html#l00084">mlir::AffineApplyOp::getMapOperands()</a>, <a class="el" href="Ops_8h_source.html#l00256">mlir::DmaStartOp::getOperationName()</a>, <a class="el" href="AffineOps_8h_source.html#l00284">mlir::AffineDmaStartOp::getOperationName()</a>, <a class="el" href="AffineOps_8h_source.html#l00434">mlir::AffineLoadOp::getOperationName()</a>, <a class="el" href="AffineOps_8h_source.html#l00505">mlir::AffineStoreOp::getOperationName()</a>, <a class="el" href="AffineOps_8h_source.html#l00368">mlir::AffineDmaWaitOp::getTagMapAttrName()</a>, <a class="el" href="Parser_8cpp_source.html#l04761">parseSourceFile()</a>, <a class="el" href="Pass_8cpp_source.html#l00052">mlir::Pass::printAsTextualPipeline()</a>, <a class="el" href="TranslateClParser_8cpp_source.html#l00031">printMLIROutput()</a>, and <a class="el" href="OpDefinition_8h_source.html#l01016">mlir::Op&lt; AffineLoadOp, OpTrait::OneResult, OpTrait::AtLeastNOperands&lt; 1 &gt;::Impl &gt;::verifyInvariants()</a>.</p>

</div>
</div>
<a id="acb414ad1d507c2ab841305c273f4deb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb414ad1d507c2ab841305c273f4deb8">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classllvm_1_1ArrayRef.html">ArrayRef</a>&lt; int64_t &gt;&#160;</td>
          <td class="paramname"><em>shape2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two shapes are compatible. </p>
<p>That is, they have the same size and each pair of the elements are equal or one of them is dynamic. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00054">54</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="StandardTypes_8h_source.html#l00248">mlir::ShapedType::isDynamic()</a>, and <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>.</p>

<p class="reference">Referenced by <a class="el" href="Ops_8cpp_source.html#l02126">verify()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00073">verifyCompatibleShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00858">mlir::OpTrait::impl::verifySameOperandsAndResultShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00915">mlir::OpTrait::impl::verifySameOperandsAndResultType()</a>, and <a class="el" href="Operation_8cpp_source.html#l00846">mlir::OpTrait::impl::verifySameOperandsShape()</a>.</p>

</div>
</div>
<a id="ac54e5e6c31f51ef648f7c03652a29ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54e5e6c31f51ef648f7c03652a29ce6">&#9670;&nbsp;</a></span>verifyCompatibleShape() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> mlir::verifyCompatibleShape </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>type2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns success if the given two types have compatible shape. </p>
<p>That is, they are both scalars (not shaped), or they are both shaped types and at least one is unranked or they have compatible dimensions. Dimensions are compatible if at least one is dynamic or both are equal. The element type does not matter. </p>

<p class="definition">Definition at line <a class="el" href="TypeUtilities_8cpp_source.html#l00073">73</a> of file <a class="el" href="TypeUtilities_8cpp_source.html">TypeUtilities.cpp</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00258">mlir::Type::dyn_cast()</a>, <a class="el" href="LogicalResult_8h_source.html#l00032">failure()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00170">mlir::ShapedType::getShape()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00138">mlir::ShapedType::hasRank()</a>, <a class="el" href="LogicalResult_8h_source.html#l00025">success()</a>, and <a class="el" href="TypeUtilities_8cpp_source.html#l00054">verifyCompatibleShape()</a>.</p>

</div>
</div>
<a id="a6b6bf62f92ba677b78bd16aa0f34fd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6bf62f92ba677b78bd16aa0f34fd07">&#9670;&nbsp;</a></span>viewGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::viewGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::GraphProgram::Name&#160;</td>
          <td class="paramname"><em>program</em> = <code>llvm::GraphProgram::DOT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the graph in a window. </p>
<p>This is for use from the debugger and depends on Graphviz to generate the graph. </p>

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00149">149</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewRegionGraph_8cpp_source.html#l00057">mlir::Region::viewGraph()</a>.</p>

</div>
</div>
<a id="aeeb01423a036ce7642b34f08a4d39e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeb01423a036ce7642b34f08a4d39e8b">&#9670;&nbsp;</a></span>viewGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::viewGraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::GraphProgram::Name&#160;</td>
          <td class="paramname"><em>program</em> = <code>llvm::GraphProgram::DOT</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Displays the CFG in a window. </p>
<p>This is for use from the debugger and depends on Graphviz to generate the graph. </p>

<p class="definition">Definition at line <a class="el" href="ViewRegionGraph_8cpp_source.html#l00047">47</a> of file <a class="el" href="ViewRegionGraph_8cpp_source.html">ViewRegionGraph.cpp</a>.</p>

</div>
</div>
<a id="ae644ec0854505ef60f12c23b96de595b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae644ec0854505ef60f12c23b96de595b">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within <code>region</code> or its descendants that was defined at the ancestors of the <code>limit</code>. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00029">29</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="Operation_8h_source.html#l00227">mlir::Operation::getOpOperands()</a>, <a class="el" href="Region_8cpp_source.html#l00036">mlir::Region::getParentRegion()</a>, <a class="el" href="IR_2Region_8h_source.html#l00087">mlir::Region::isAncestor()</a>, <a class="el" href="LoopCoalescing_8cpp.html#a330ef62cae576796f141c733ef3db249">reg</a>, and <a class="el" href="IR_2Region_8h_source.html#l00123">mlir::Region::walk()</a>.</p>

<p class="reference">Referenced by <a class="el" href="RegionUtils_8h_source.html#l00023">areValuesDefinedAbove()</a>, <a class="el" href="RegionUtils_8cpp_source.html#l00056">getUsedValuesDefinedAbove()</a>, and <a class="el" href="RegionUtils_8cpp_source.html#l00050">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a036e7ce3c7c3bf73fc0a653cd98bb7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e7ce3c7c3bf73fc0a653cd98bb7c0">&#9670;&nbsp;</a></span>visitUsedValuesDefinedAbove() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mlir::visitUsedValuesDefinedAbove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classllvm_1_1MutableArrayRef.html">MutableArrayRef</a>&lt; <a class="el" href="classmlir_1_1Region.html">Region</a> &gt;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacemlir.html#a0bff6226b7c81b6134b8c1130403a172">function_ref</a>&lt; void(<a class="el" href="classmlir_1_1OpOperand.html">OpOperand</a> *)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calls <code>callback</code> for each use of a value within any of the regions provided that was defined in one of the ancestors. </p>

<p class="definition">Definition at line <a class="el" href="RegionUtils_8cpp_source.html#l00050">50</a> of file <a class="el" href="RegionUtils_8cpp_source.html">RegionUtils.cpp</a>.</p>

<p class="reference">References <a class="el" href="RegionUtils_8cpp_source.html#l00029">visitUsedValuesDefinedAbove()</a>.</p>

</div>
</div>
<a id="a3637269c766005364583ba36db13bacd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3637269c766005364583ba36db13bacd">&#9670;&nbsp;</a></span>writeGraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::writeGraph </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewRegionGraph_8cpp_source.html#l00052">52</a> of file <a class="el" href="ViewRegionGraph_8cpp_source.html">ViewRegionGraph.cpp</a>.</p>

</div>
</div>
<a id="aa9dab397b212cccb9be9497581485293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9dab397b212cccb9be9497581485293">&#9670;&nbsp;</a></span>writeGraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">raw_ostream &amp; mlir::writeGraph </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Block.html">Block</a> &amp;&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shortNames</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Twine &amp;&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ViewOpGraph_8cpp_source.html#l00154">154</a> of file <a class="el" href="ViewOpGraph_8cpp_source.html">ViewOpGraph.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="ViewRegionGraph_8cpp_source.html#l00060">mlir::Region::viewGraph()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a2aeb0828d77d6958e5bc1fabe03734b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeb0828d77d6958e5bc1fabe03734b5">&#9670;&nbsp;</a></span>makeLLVMPassesTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt; mlir::makeLLVMPassesTransformer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes explicitly specified, plus an optional optimization level, Any optimization passes, if present, will be inserted before the pass at position optPassesInsertPos. </p>
<p>If not null, <code>targetMachine</code> is used to initialize passes that provide target-specific information to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> optimizer. <code>targetMachine</code> must outlive the returned std::function. </p>

<p class="definition">Definition at line <a class="el" href="OptUtils_8h_source.html#l00050">50</a> of file <a class="el" href="OptUtils_8h_source.html">OptUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="JitRunner_8cpp_source.html#l00177">compileAndExecuteSingleFloatReturnFunction()</a>, and <a class="el" href="OptUtils_8cpp_source.html#l00063">populatePassManagers()</a>.</p>

</div>
</div>
<a id="a159f88d87b78c353731e1661c65a0b98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159f88d87b78c353731e1661c65a0b98">&#9670;&nbsp;</a></span>makeOptimizingTransformer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="namespacemlir.html#a247bc9a6d1f1577f2d876cb55e2ea752a902b0d55fddef6f8d651fe1035b7d4bd">llvm::Error</a>(llvm::Module *)&gt; mlir::makeOptimizingTransformer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a module transformer function for MLIR <a class="el" href="classmlir_1_1ExecutionEngine.html" title="JIT-backed execution engine for MLIR modules. ">ExecutionEngine</a> that runs <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> IR passes corresponding to the given speed and size optimization levels (e.g. </p>
<p>-O2 or -Os). If not null, <code>targetMachine</code> is used to initialize passes that provide target-specific information to the <a class="el" href="namespacemlir_1_1LLVM.html">LLVM</a> optimizer. <code>targetMachine</code> must outlive the returned std::function. </p>

<p class="definition">Definition at line <a class="el" href="OptUtils_8h_source.html#l00040">40</a> of file <a class="el" href="OptUtils_8h_source.html">OptUtils.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="OptUtils_8cpp_source.html#l00063">populatePassManagers()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 28 2020 00:23:13 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
