<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MLIR: mlir::Type Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MLIR
   &#160;<span id="projectnumber">11.0.0git</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacemlir.html">mlir</a></li><li class="navelem"><a class="el" href="classmlir_1_1Type.html">Type</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmlir_1_1Type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mlir::Type Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> class are immutable and uniqued.  
 <a href="classmlir_1_1Type.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="Types_8h_source.html">mlir/IR/Types.h</a>&quot;</code></p>
<div class="dynheader">
Inheritance diagram for mlir::Type:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1Type__inherit__graph.png" border="0" usemap="#mlir_1_1Type_inherit__map" alt="Inheritance graph"/></div>
<map name="mlir_1_1Type_inherit__map" id="mlir_1_1Type_inherit__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for mlir::Type:</div>
<div class="dyncontent">
<div class="center"><img src="classmlir_1_1Type__coll__graph.png" border="0" usemap="#mlir_1_1Type_coll__map" alt="Collaboration graph"/></div>
<map name="mlir_1_1Type_coll__map" id="mlir_1_1Type_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab90b5287ad4211defb81009855047557"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557">Kind</a> { <br />
&#160;&#160;<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a0e7baa30be66118faf0a000eb6d5c052">Function</a>, 
<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a29757f2265087eaa32051dc000f55bd0">Opaque</a>, 
<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a40d878fc34e40e22a30c4c0316443b09">LAST_BUILTIN_TYPE</a> = Opaque, 
<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a2a3698ae6ae4e77082b2f91425a993ad">DEFINE_SYM_KIND_RANGE</a>, 
<br />
&#160;&#160;<a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557a2a3698ae6ae4e77082b2f91425a993ad">DEFINE_SYM_KIND_RANGE</a>
<br />
 }<tr class="memdesc:ab90b5287ad4211defb81009855047557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Integer identifier for all the concrete type kinds.  <a href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ab90b5287ad4211defb81009855047557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac685aa79d9ab1459609a38bd63479338"><td class="memTemplParams" colspan="2">template&lt;typename ConcreteType , typename BaseType , typename StorageType  = DefaultTypeStorage&gt; </td></tr>
<tr class="memitem:ac685aa79d9ab1459609a38bd63479338"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac685aa79d9ab1459609a38bd63479338">TypeBase</a> = <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt; ConcreteType, BaseType, StorageType, <a class="el" href="classmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a> &gt;</td></tr>
<tr class="memdesc:ac685aa79d9ab1459609a38bd63479338"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class for implementing types.  <a href="#ac685aa79d9ab1459609a38bd63479338">More...</a><br /></td></tr>
<tr class="separator:ac685aa79d9ab1459609a38bd63479338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89de246b01ef652963e1ddde953d62e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> = <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td></tr>
<tr class="separator:a89de246b01ef652963e1ddde953d62e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5472fc9326984b512232b1ac27114629"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a5472fc9326984b512232b1ac27114629">Type</a> ()</td></tr>
<tr class="separator:a5472fc9326984b512232b1ac27114629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8871458ee7b2abdca3e94788ae3048"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aaa8871458ee7b2abdca3e94788ae3048">Type</a> (const <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *<a class="el" href="classmlir_1_1Type.html#a54af6c081e012a32bba9b650480c6c06">impl</a>)</td></tr>
<tr class="separator:aaa8871458ee7b2abdca3e94788ae3048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237023ae4dcab369d064457a10bcf518"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a237023ae4dcab369d064457a10bcf518">Type</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="separator:a237023ae4dcab369d064457a10bcf518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860e9e7612215565aadad622ccf4cbb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a860e9e7612215565aadad622ccf4cbb0">operator=</a> (const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;other)=default</td></tr>
<tr class="separator:a860e9e7612215565aadad622ccf4cbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53df1249058e8c2ec0fa70f172f0b59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac53df1249058e8c2ec0fa70f172f0b59">operator==</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="separator:ac53df1249058e8c2ec0fa70f172f0b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1be45203a0010965388d41e712dc268"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad1be45203a0010965388d41e712dc268">operator!=</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> other) const</td></tr>
<tr class="separator:ad1be45203a0010965388d41e712dc268"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeb8b20e59002a0fedfcb93e314b416f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#afeb8b20e59002a0fedfcb93e314b416f">operator bool</a> () const</td></tr>
<tr class="separator:afeb8b20e59002a0fedfcb93e314b416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac516f7c8eb957068555b5781d78f23af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ac516f7c8eb957068555b5781d78f23af">operator!</a> () const</td></tr>
<tr class="separator:ac516f7c8eb957068555b5781d78f23af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#adcd295cf88ab7faa33601d3bbee5c4b8">isa</a> () const</td></tr>
<tr class="separator:adcd295cf88ab7faa33601d3bbee5c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6b8d33d03b9736dfcc3cc0e9351b1826">dyn_cast</a> () const</td></tr>
<tr class="separator:a6b8d33d03b9736dfcc3cc0e9351b1826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a33ca8bbee5e3e8a02e0df18897981edf">dyn_cast_or_null</a> () const</td></tr>
<tr class="separator:a33ca8bbee5e3e8a02e0df18897981edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1a9c3e06d3b23ad9457c13cb828a7c48">cast</a> () const</td></tr>
<tr class="separator:a1a9c3e06d3b23ad9457c13cb828a7c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770133e69450b7252813d64642b3d6c5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a770133e69450b7252813d64642b3d6c5">getKind</a> () const</td></tr>
<tr class="memdesc:a770133e69450b7252813d64642b3d6c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the classification for this type.  <a href="#a770133e69450b7252813d64642b3d6c5">More...</a><br /></td></tr>
<tr class="separator:a770133e69450b7252813d64642b3d6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3951cad794a5bc5ad086158c20f8e50e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a3951cad794a5bc5ad086158c20f8e50e">getContext</a> () const</td></tr>
<tr class="memdesc:a3951cad794a5bc5ad086158c20f8e50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the LLVMContext in which this type was uniqued.  <a href="#a3951cad794a5bc5ad086158c20f8e50e">More...</a><br /></td></tr>
<tr class="separator:a3951cad794a5bc5ad086158c20f8e50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21810b671ec68509499ee2d4f10a8a6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a21810b671ec68509499ee2d4f10a8a6b">getDialect</a> () const</td></tr>
<tr class="memdesc:a21810b671ec68509499ee2d4f10a8a6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dialect this type is registered to.  <a href="#a21810b671ec68509499ee2d4f10a8a6b">More...</a><br /></td></tr>
<tr class="separator:a21810b671ec68509499ee2d4f10a8a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04cd125cd035f98f0bbbdec875f4f90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ae04cd125cd035f98f0bbbdec875f4f90">isIndex</a> ()</td></tr>
<tr class="separator:ae04cd125cd035f98f0bbbdec875f4f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219cbb23b0bbf98773dc73d5ba5b13ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a219cbb23b0bbf98773dc73d5ba5b13ed">isBF16</a> ()</td></tr>
<tr class="separator:a219cbb23b0bbf98773dc73d5ba5b13ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf9ffe711f6a40ec2558f094e0fe3d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#addf9ffe711f6a40ec2558f094e0fe3d0">isF16</a> ()</td></tr>
<tr class="separator:addf9ffe711f6a40ec2558f094e0fe3d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee1dfc71fe79d72fb86df381afa28f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a2ee1dfc71fe79d72fb86df381afa28f8">isF32</a> ()</td></tr>
<tr class="separator:a2ee1dfc71fe79d72fb86df381afa28f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15aebbbf2b0d7cefda956b63af8ee0d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a15aebbbf2b0d7cefda956b63af8ee0d4">isF64</a> ()</td></tr>
<tr class="separator:a15aebbbf2b0d7cefda956b63af8ee0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ffc49524ecdd46d15a8449e23267b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad3ffc49524ecdd46d15a8449e23267b1">isInteger</a> (unsigned width)</td></tr>
<tr class="memdesc:ad3ffc49524ecdd46d15a8449e23267b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer type with the specified width.  <a href="#ad3ffc49524ecdd46d15a8449e23267b1">More...</a><br /></td></tr>
<tr class="separator:ad3ffc49524ecdd46d15a8449e23267b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae211db2caefd9718134acd88becc670c"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ae211db2caefd9718134acd88becc670c">getIntOrFloatBitWidth</a> ()</td></tr>
<tr class="memdesc:ae211db2caefd9718134acd88becc670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bit width of an integer or a float type, assert failure on other types.  <a href="#ae211db2caefd9718134acd88becc670c">More...</a><br /></td></tr>
<tr class="separator:ae211db2caefd9718134acd88becc670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4fa1595a42d6b3ae872fc303249b5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a6a4fa1595a42d6b3ae872fc303249b5e">isIntOrIndex</a> ()</td></tr>
<tr class="memdesc:a6a4fa1595a42d6b3ae872fc303249b5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer or index type.  <a href="#a6a4fa1595a42d6b3ae872fc303249b5e">More...</a><br /></td></tr>
<tr class="separator:a6a4fa1595a42d6b3ae872fc303249b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4258b26dd83dba9fc87fc7220639bf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#ad4258b26dd83dba9fc87fc7220639bf4">isIntOrIndexOrFloat</a> ()</td></tr>
<tr class="memdesc:ad4258b26dd83dba9fc87fc7220639bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if this is an integer, index, or float type.  <a href="#ad4258b26dd83dba9fc87fc7220639bf4">More...</a><br /></td></tr>
<tr class="separator:ad4258b26dd83dba9fc87fc7220639bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2f2df233ac9b650c85992d365b08419"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#af2f2df233ac9b650c85992d365b08419">isIntOrFloat</a> ()</td></tr>
<tr class="memdesc:af2f2df233ac9b650c85992d365b08419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true of this is an integer or a float type.  <a href="#af2f2df233ac9b650c85992d365b08419">More...</a><br /></td></tr>
<tr class="separator:af2f2df233ac9b650c85992d365b08419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f326ccb845e5e7f384a8069153f305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a94f326ccb845e5e7f384a8069153f305">print</a> (raw_ostream &amp;os)</td></tr>
<tr class="memdesc:a94f326ccb845e5e7f384a8069153f305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the current type.  <a href="#a94f326ccb845e5e7f384a8069153f305">More...</a><br /></td></tr>
<tr class="separator:a94f326ccb845e5e7f384a8069153f305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a975aa15f5744af5a899e491135ab1384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a975aa15f5744af5a899e491135ab1384">dump</a> ()</td></tr>
<tr class="separator:a975aa15f5744af5a899e491135ab1384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c6a69dacb6f508f73ca9ddc86613d5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#aa6c6a69dacb6f508f73ca9ddc86613d5">getSubclassData</a> () const</td></tr>
<tr class="separator:aa6c6a69dacb6f508f73ca9ddc86613d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a663843e1a6ab7ce6214e4732b64787ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a663843e1a6ab7ce6214e4732b64787ba">setSubclassData</a> (unsigned val)</td></tr>
<tr class="separator:a663843e1a6ab7ce6214e4732b64787ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1035844c344d17a9e6081c6a0e101b80"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a1035844c344d17a9e6081c6a0e101b80">getAsOpaquePointer</a> () const</td></tr>
<tr class="memdesc:a1035844c344d17a9e6081c6a0e101b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods for supporting PointerLikeTypeTraits.  <a href="#a1035844c344d17a9e6081c6a0e101b80">More...</a><br /></td></tr>
<tr class="separator:a1035844c344d17a9e6081c6a0e101b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a20187f3bc53c94040a83d41de0119a59"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a20187f3bc53c94040a83d41de0119a59">classof</a> (<a class="el" href="classmlir_1_1Type.html">Type</a>)</td></tr>
<tr class="separator:a20187f3bc53c94040a83d41de0119a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b903c935dfc504b4f4e3f77939b113"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a58b903c935dfc504b4f4e3f77939b113">getFromOpaquePointer</a> (const void *pointer)</td></tr>
<tr class="separator:a58b903c935dfc504b4f4e3f77939b113"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a54af6c081e012a32bba9b650480c6c06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54af6c081e012a32bba9b650480c6c06">impl</a></td></tr>
<tr class="separator:a54af6c081e012a32bba9b650480c6c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a54ee333db7234f6ada1036072a24b877"><td class="memItemLeft" align="right" valign="top">::llvm::hash_code&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmlir_1_1Type.html#a54ee333db7234f6ada1036072a24b877">hash_value</a> (<a class="el" href="classmlir_1_1Type.html">Type</a> arg)</td></tr>
<tr class="separator:a54ee333db7234f6ada1036072a24b877"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Instances of the <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> class are immutable and uniqued. </p>
<p>They wrap a pointer to the storage object owned by <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a>. Therefore, instances of <a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> are passed around by value.</p>
<p>Some types are "primitives" meaning they do not have any parameters, for example the Index type. Parametric types have additional information that differentiates the types of the same kind between them, for example the Integer type has bitwidth, making i8 and i16 belong to the same kind by be different instances of the <a class="el" href="classmlir_1_1IntegerType.html" title="Integer types can have arbitrary bitwidth up to a large fixed limit. ">IntegerType</a>.</p>
<p>Types are constructed and uniqued via the '<a class="el" href="classmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>' class.</p>
<p>Derived type classes are expected to implement several required implementation hooks:</p><ul>
<li>Required:<ul>
<li>static bool kindof(unsigned kind);<ul>
<li>Returns if the provided type kind corresponds to an instance of the current type. Used for isa/dyn_cast casting functionality.</li>
</ul>
</li>
</ul>
</li>
<li>Optional:<ul>
<li>static <a class="el" href="structmlir_1_1LogicalResult.html">LogicalResult</a> verifyConstructionInvariants( Optional&lt;Location&gt; loc, <a class="el" href="classmlir_1_1MLIRContext.html" title="MLIRContext is the top-level object for a collection of MLIR modules. ">MLIRContext</a> *context, Args... args)<ul>
<li>This method is invoked when calling the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a6ee6987fa155c547771c77a4680e320a" title="Get or create a new ConcreteT instance within the ctx. ">TypeBase::get</a>/getChecked' methods to ensure that the arguments passed in are valid to construct a type instance with.</li>
<li>This method is expected to return failure if a type cannot be constructed with 'args', success otherwise.</li>
<li>'args' must correspond with the arguments passed into the '<a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html#a6ee6987fa155c547771c77a4680e320a" title="Get or create a new ConcreteT instance within the ctx. ">TypeBase::get</a>' call after the type kind.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><a class="el" href="classmlir_1_1Type.html" title="Instances of the Type class are immutable and uniqued. ">Type</a> storage objects inherit from <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type. ">TypeStorage</a> and contain the following:</p><ul>
<li>The type kind (for LLVM-style RTTI).</li>
<li>The dialect that defined the type.</li>
<li>Any parameters of the type. For non-parametric types, a convenience DefaultTypeStorage is provided. Parametric storage types must derive <a class="el" href="classmlir_1_1TypeStorage.html" title="Base storage class appearing in a Type. ">TypeStorage</a> and respect the following:</li>
<li>Define a type alias, KeyTy, to a type that uniquely identifies the instance of the type within its kind.<ul>
<li>The key type must be constructible from the values passed into the <a class="el" href="classmlir_1_1detail_1_1TypeUniquer.html#acdabc2f7217d189350aca91d32a3dd66" title="Get an uniqued instance of a type T. ">detail::TypeUniquer::get</a> call after the type kind.</li>
<li>If the KeyTy does not have an <a class="el" href="structllvm_1_1DenseMapInfo.html">llvm::DenseMapInfo</a> specialization, the storage class must define a hashing method: 'static unsigned hashKey(const KeyTy &amp;)'</li>
</ul>
</li>
<li>Provide a method, 'bool operator==(const KeyTy &amp;) const', to compare the storage instance against an instance of the key type.</li>
<li>Provide a construction method: 'DerivedStorage *construct(TypeStorageAllocator &amp;, const KeyTy &amp;key)' that builds a unique instance of the derived storage. The arguments to this function are an allocator to store any uniqued data within the context and the key type for this storage. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00084">84</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a89de246b01ef652963e1ddde953d62e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89de246b01ef652963e1ddde953d62e7">&#9670;&nbsp;</a></span>ImplType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">mlir::Type::ImplType</a> =  <a class="el" href="classmlir_1_1TypeStorage.html">TypeStorage</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00109">109</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ac685aa79d9ab1459609a38bd63479338"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac685aa79d9ab1459609a38bd63479338">&#9670;&nbsp;</a></span>TypeBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ConcreteType , typename BaseType , typename StorageType  = DefaultTypeStorage&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmlir_1_1Type.html#ac685aa79d9ab1459609a38bd63479338">mlir::Type::TypeBase</a> =  <a class="el" href="classmlir_1_1detail_1_1StorageUserBase.html">detail::StorageUserBase</a>&lt;ConcreteType, BaseType, StorageType, <a class="el" href="classmlir_1_1detail_1_1TypeUniquer.html">detail::TypeUniquer</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility class for implementing types. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00107">107</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab90b5287ad4211defb81009855047557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90b5287ad4211defb81009855047557">&#9670;&nbsp;</a></span>Kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classmlir_1_1Type.html#ab90b5287ad4211defb81009855047557">mlir::Type::Kind</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Integer identifier for all the concrete type kinds. </p>
<p>Note: This is not an enum class as each dialect will likely define a separate enumeration for the specific types that they define. Not being an enum class also simplifies the handling of type kinds by not requiring casts for each use. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a0e7baa30be66118faf0a000eb6d5c052"></a>Function&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a29757f2265087eaa32051dc000f55bd0"></a>Opaque&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a40d878fc34e40e22a30c4c0316443b09"></a>LAST_BUILTIN_TYPE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a2a3698ae6ae4e77082b2f91425a993ad"></a>DEFINE_SYM_KIND_RANGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab90b5287ad4211defb81009855047557a2a3698ae6ae4e77082b2f91425a993ad"></a>DEFINE_SYM_KIND_RANGE&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00091">91</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5472fc9326984b512232b1ac27114629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5472fc9326984b512232b1ac27114629">&#9670;&nbsp;</a></span>Type() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr mlir::Type::Type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00111">111</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="aaa8871458ee7b2abdca3e94788ae3048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8871458ee7b2abdca3e94788ae3048">&#9670;&nbsp;</a></span>Type() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a> *&#160;</td>
          <td class="paramname"><em>impl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00112">112</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00139">mlir::StandardAttributes::Type</a>.</p>

</div>
</div>
<a id="a237023ae4dcab369d064457a10bcf518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237023ae4dcab369d064457a10bcf518">&#9670;&nbsp;</a></span>Type() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::Type </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1a9c3e06d3b23ad9457c13cb828a7c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9c3e06d3b23ad9457c13cb828a7c48">&#9670;&nbsp;</a></span>cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00264">264</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="UniformKernelUtils_8h_source.html#l00181">mlir::fxpmath::detail::broadcastScalarConstIntValue()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01752">mlir::AffineLoadOp::build()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01855">mlir::AffineStoreOp::build()</a>, <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="UniformKernelUtils_8h_source.html#l00161">mlir::fxpmath::detail::castElementType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00142">mlir::quant::QuantizedType::castFromExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00098">mlir::quant::QuantizedType::castFromStorageType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00167">mlir::quant::QuantizedType::castToExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00118">mlir::quant::QuantizedType::castToStorageType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00858">mlir::DenseFPElementsAttr::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l00877">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00044">mlir::quant::ExpressedToQuantizedConverter::convert()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00089">convertLinalgType()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="PipelineDataTransfer_8cpp_source.html#l00064">doubleBuffer()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00101">extractOne()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00255">mlir::StructBuilder::extractPtr()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00021">mlir::quant::ExpressedToQuantizedConverter::forInputType()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01264">generateCopy()</a>, <a class="el" href="Attributes_8cpp_source.html#l00271">mlir::IntegerAttr::get()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00414">mlir::MemRefDescriptor::getElementType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00762">mlir::DenseElementsAttr::getFloatValues()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01547">getFullMemRefAsRegion()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00156">mlir::detail::FloatAttributeStorage::getKey()</a>, <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>, <a class="el" href="Helpers_8cpp_source.html#l00016">getMemRefSizes()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l01168">getMultiLevelStrides()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00219">getOrCreateUnrolledVectorSlice()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00089">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00469">getSymbolLessAffineMaps()</a>, <a class="el" href="Value_8cpp_source.html#l00034">mlir::Value::getType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00359">mlir::ElementsAttr::getType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00938">mlir::SparseElementsAttr::getValue()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00213">mlir::Builder::getZeroAttr()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00389">inferExtractOpResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01225">inferStridedSliceOpResultType()</a>, <a class="el" href="Ops_8cpp_source.html#l02566">inferSubViewResultType()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01594">inferVectorTypeCastResultType()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00136">insertCopies()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00074">insertOne()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00080">mlir::quant::QuantizedType::isCompatibleExpressedType()</a>, <a class="el" href="Tiling_8cpp_source.html#l00234">makeTiledViews()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00272">mlir::MemRefDescriptor::MemRefDescriptor()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00089">mlir::OperandElementTypeIterator::OperandElementTypeIterator()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00304">parseCallOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00065">parseNVVMShflSyncBflyOp()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01317">printDenseFloatElement()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00367">mlir::quant::QuantizationDialect::printType()</a>, <a class="el" href="LinalgTypes_8cpp_source.html#l00057">mlir::linalg::LinalgDialect::printType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00609">mlir::spirv::SPIRVDialect::printType()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l02170">mlir::LLVMTypeConverter::promoteOneMemRefDescriptor()</a>, <a class="el" href="Transforms_2Utils_2Utils_8cpp_source.html#l00049">mlir::replaceAllMemRefUsesWith()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00098">mlir::ResultElementTypeIterator::ResultElementTypeIterator()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00250">mlir::StructBuilder::StructBuilder()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00280">mlir::MemRefDescriptor::undef()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00428">mlir::UnrankedMemRefDescriptor::undef()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00309">unrollSingleResultStructuredOp()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00944">vectorizeConstant()</a>, <a class="el" href="Helpers_8cpp_source.html#l00044">mlir::edsc::VectorView::VectorView()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00524">verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00573">verifyAtomicUpdateOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00187">verifyCastOp()</a>, <a class="el" href="Attributes_8cpp_source.html#l00221">mlir::FloatAttr::verifyConstructionInvariants()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l00286">verifyLoadStorePtrAndValTypes()</a>.</p>

</div>
</div>
<a id="a20187f3bc53c94040a83d41de0119a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20187f3bc53c94040a83d41de0119a59">&#9670;&nbsp;</a></span>classof()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool mlir::Type::classof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00130">130</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="AffineExpr_8h_source.html#l00195">mlir::hash_value()</a>, and <a class="el" href="AffineOps_8cpp_source.html#l01334">print()</a>.</p>

</div>
</div>
<a id="a975aa15f5744af5a899e491135ab1384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a975aa15f5744af5a899e491135ab1384">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02142">2142</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">References <a class="el" href="AffineOps_8cpp_source.html#l01334">print()</a>.</p>

</div>
</div>
<a id="a6b8d33d03b9736dfcc3cc0e9351b1826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b8d33d03b9736dfcc3cc0e9351b1826">&#9670;&nbsp;</a></span>dyn_cast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::dyn_cast </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00258">258</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01019">appendMangledType()</a>, <a class="el" href="UniformKernelUtils_8h_source.html#l00207">mlir::fxpmath::detail::broadcastScalarConstFloatValue()</a>, <a class="el" href="UniformKernelUtils_8h_source.html#l00181">mlir::fxpmath::detail::broadcastScalarConstIntValue()</a>, <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l00223">canRegisterAlias()</a>, <a class="el" href="UniformKernelUtils_8h_source.html#l00161">mlir::fxpmath::detail::castElementType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00101">convertStdType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00390">getBitWidth()</a>, <a class="el" href="Attributes_8cpp_source.html#l00732">mlir::DenseElementsAttr::getBoolValues()</a>, <a class="el" href="Ops_8cpp_source.html#l00593">getCheckedI1SameShape()</a>, <a class="el" href="TypeUtils_8cpp_source.html#l00016">mlir::quantizer::getElementOrPrimitiveType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00696">getElementPtrType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00411">getElementType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00021">mlir::getElementTypeOrSelf()</a>, <a class="el" href="VectorAnalysis_8cpp_source.html#l00156">getEnclosingforOps()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00113">getI64SubArray()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00446">getInsertExtractValueElementType()</a>, <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00054">mlir::LLVMTypeConverter::getLLVMContext()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00212">getLoadStoreElementType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00089">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="Traits_8cpp_source.html#l00074">getShape()</a>, <a class="el" href="Operation_8cpp_source.html#l00778">getTensorOrVectorElementType()</a>, <a class="el" href="Ops_8cpp_source.html#l02241">getTensorTypeFromMemRefType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00043">getTypeNumBytes()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00621">getUnaryOpResultType()</a>, <a class="el" href="MemoryPromotion_8cpp_source.html#l00136">insertCopies()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00050">isFnEntryBlock()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00135">mlir::VulkanLayoutUtils::isLegalType()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00043">mlir::isOpaqueTypeWithName()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00157">mlir::spirv::SPIRVDialect::isValidScalarType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00173">mlir::spirv::SPIRVDialect::isValidType()</a>, <a class="el" href="Ops_8cpp_source.html#l01514">mlir::DmaWaitOp::parse()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00862">parseAddressOfOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00130">parseAllocaOp()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00188">parseAndVerifyType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00910">parseAtomicCompareExchangeWeakOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00530">parseAtomicUpdateOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00304">parseCallOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00055">parseCmpOp()</a>, <a class="el" href="OpImplementation_8h_source.html#l00568">mlir::OpAsmParser::parseColonType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01183">parseCompositeConstructOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00410">parseExtractElementOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l00412">parseExtractOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00171">parseGEPOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l00530">parseInsertElementOp()</a>, <a class="el" href="NVVMDialect_8cpp_source.html#l00108">parseNVVMMmaOp()</a>, <a class="el" href="VectorOps_8cpp_source.html#l01058">parseOuterProductOp()</a>, <a class="el" href="Ops_8cpp_source.html#l01855">parseRankOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01058">parseShuffleVectorOp()</a>, <a class="el" href="DialectImplementation_8h_source.html#l00308">mlir::DialectAsmParser::parseType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l03092">parseVariableOp()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01609">mlir::LLVM::LLVMDialect::printType()</a>, <a class="el" href="QuantizeUtils_8cpp_source.html#l00127">mlir::quant::quantizeAttr()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00446">mlir::UnrankedMemRefDescriptor::setMemRefDescPtr()</a>, <a class="el" href="ModuleTranslation_8cpp_source.html#l00502">topologicalSort()</a>, <a class="el" href="LLVMDialect_8cpp_source.html#l01285">verify()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00187">verifyCastOp()</a>, <a class="el" href="TypeUtilities_8cpp_source.html#l00073">mlir::verifyCompatibleShape()</a>, and <a class="el" href="QuantTypes_8cpp_source.html#l00026">mlir::quant::QuantizedType::verifyConstructionInvariants()</a>.</p>

</div>
</div>
<a id="a33ca8bbee5e3e8a02e0df18897981edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ca8bbee5e3e8a02e0df18897981edf">&#9670;&nbsp;</a></span>dyn_cast_or_null()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">U mlir::Type::dyn_cast_or_null </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00261">261</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00114">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="LowerUniformRealMath_8cpp_source.html#l00091">emitDequantize()</a>, <a class="el" href="UniformKernelUtils_8h_source.html#l00023">mlir::fxpmath::detail::getUniformElementType()</a>, <a class="el" href="VectorTransforms_8cpp_source.html#l00436">getVectorElementwiseOpUnrollState()</a>, and <a class="el" href="VectorTransforms_8cpp_source.html#l00309">unrollSingleResultStructuredOp()</a>.</p>

</div>
</div>
<a id="a1035844c344d17a9e6081c6a0e101b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1035844c344d17a9e6081c6a0e101b80">&#9670;&nbsp;</a></span>getAsOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* mlir::Type::getAsOpaquePointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Methods for supporting PointerLikeTypeTraits. </p>

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00173">173</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00290">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getAsVoidPointer()</a>, <a class="el" href="CoreAPIs_8cpp_source.html#l00085">mlirParseType()</a>, and <a class="el" href="Attributes_8cpp_source.html#l00034">mlir::AttributeStorage::setType()</a>.</p>

</div>
</div>
<a id="a3951cad794a5bc5ad086158c20f8e50e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3951cad794a5bc5ad086158c20f8e50e">&#9670;&nbsp;</a></span>getContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1MLIRContext.html">MLIRContext</a> * Type::getContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the LLVMContext in which this type was uniqued. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00027">27</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgToLLVM_8cpp_source.html#l00089">convertLinalgType()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00101">convertStdType()</a>, <a class="el" href="FakeQuantSupport_8cpp_source.html#l00099">mlir::quant::fakeQuantAttrsToType()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00121">mlir::spirv::ArrayType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00405">mlir::spirv::PointerType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00616">mlir::ComplexType::get()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00436">mlir::spirv::RuntimeArrayType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00199">mlir::quant::AnyQuantizedType::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00199">mlir::VectorType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00236">mlir::quant::UniformQuantizedType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00175">mlir::FloatAttr::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00248">mlir::RankedTensorType::get()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00293">mlir::quant::UniformQuantizedPerAxisType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00267">mlir::IntegerAttr::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00279">mlir::UnrankedTensorType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00339">mlir::StringAttr::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00392">mlir::UnrankedMemRefType::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00349">mlir::TypeAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00886">mlir::OpaqueElementsAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00917">mlir::SparseElementsAttr::get()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00621">mlir::ComplexType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00207">mlir::quant::AnyQuantizedType::getChecked()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00204">mlir::VectorType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00248">mlir::quant::UniformQuantizedType::getChecked()</a>, <a class="el" href="Attributes_8cpp_source.html#l00179">mlir::FloatAttr::getChecked()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00254">mlir::RankedTensorType::getChecked()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00304">mlir::quant::UniformQuantizedPerAxisType::getChecked()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00284">mlir::UnrankedTensorType::getChecked()</a>, <a class="el" href="Attributes_8cpp_source.html#l00305">mlir::OpaqueAttr::getChecked()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00318">mlir::MemRefType::getChecked()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00398">mlir::UnrankedMemRefType::getChecked()</a>, <a class="el" href="Attributes_8cpp_source.html#l00046">mlir::Attribute::getContext()</a>, <a class="el" href="Value_8h_source.html#l00104">mlir::Value::getContext()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00054">mlir::LLVMTypeConverter::getLLVMContext()</a>, <a class="el" href="Attributes_8cpp_source.html#l00664">mlir::DenseElementsAttr::getRaw()</a>, <a class="el" href="Parser_8cpp_source.html#l04833">parseSymbol()</a>, and <a class="el" href="Value_8cpp_source.html#l00047">mlir::Value::setType()</a>.</p>

</div>
</div>
<a id="a21810b671ec68509499ee2d4f10a8a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21810b671ec68509499ee2d4f10a8a6b">&#9670;&nbsp;</a></span>getDialect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Dialect.html">Dialect</a> Type::getDialect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dialect this type is registered to. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00025">25</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LLVMDialect_8cpp_source.html#l01668">mlir::LLVM::LLVMType::getDialect()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00188">parseAndVerifyType()</a>, and <a class="el" href="AsmPrinter_8cpp_source.html#l01317">printDenseFloatElement()</a>.</p>

</div>
</div>
<a id="a58b903c935dfc504b4f4e3f77939b113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b903c935dfc504b4f4e3f77939b113">&#9670;&nbsp;</a></span>getFromOpaquePointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classmlir_1_1Type.html">Type</a> mlir::Type::getFromOpaquePointer </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pointer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00176">176</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Attributes_8h_source.html#l00139">mlir::StandardAttributes::Type</a>.</p>

<p class="reference">Referenced by <a class="el" href="Diagnostics_8cpp_source.html#l00057">mlir::DiagnosticArgument::getAsType()</a>, <a class="el" href="Types_8h_source.html#l00293">llvm::PointerLikeTypeTraits&lt; mlir::Type &gt;::getFromVoidPointer()</a>, <a class="el" href="Attributes_8cpp_source.html#l00031">mlir::AttributeStorage::getType()</a>, <a class="el" href="CoreAPIs_8cpp_source.html#l00036">makeFunctionType()</a>, <a class="el" href="CoreAPIs_8cpp_source.html#l00056">makeIntegerAttr()</a>, and <a class="el" href="CoreAPIs_8cpp_source.html#l00025">makeMemRefType()</a>.</p>

</div>
</div>
<a id="ae211db2caefd9718134acd88becc670c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae211db2caefd9718134acd88becc670c">&#9670;&nbsp;</a></span>getIntOrFloatBitWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Type::getIntOrFloatBitWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the bit width of an integer or a float type, assert failure on other types. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00103">103</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00186">mlir::ShapedType::kDynamicSize</a>, and <a class="el" href="StandardTypes_8h_source.html#l00187">mlir::ShapedType::kDynamicStrideOrOffset</a>.</p>

<p class="reference">Referenced by <a class="el" href="Promotion_8cpp_source.html#l00049">allocBuffer()</a>, <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00390">getBitWidth()</a>, <a class="el" href="Attributes_8cpp_source.html#l00444">getDenseElementBitwidth()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00123">mlir::ShapedType::getElementTypeBitWidth()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00115">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="SPIRVLowering_8cpp_source.html#l00043">getTypeNumBytes()</a>, <a class="el" href="UniformKernelUtils_8h_source.html#l00028">mlir::fxpmath::detail::hasStorageBitWidth()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l00187">verifyCastOp()</a>.</p>

</div>
</div>
<a id="a770133e69450b7252813d64642b3d6c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770133e69450b7252813d64642b3d6c5">&#9670;&nbsp;</a></span>getKind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Type::getKind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the classification for this type. </p>

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00022">22</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8h_source.html#l00075">mlir::quant::QuantizedType::classof()</a>, <a class="el" href="SPIRVTypes_8cpp_source.html#l00149">mlir::spirv::CompositeType::classof()</a>, <a class="el" href="StandardTypes_8h_source.html#l00239">mlir::ShapedType::classof()</a>, <a class="el" href="StandardTypes_8h_source.html#l00305">mlir::TensorType::classof()</a>, <a class="el" href="StandardTypes_8h_source.html#l00380">mlir::BaseMemRefType::classof()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00044">mlir::quant::ExpressedToQuantizedConverter::convert()</a>, <a class="el" href="LayoutUtils_8cpp_source.html#l00020">mlir::VulkanLayoutUtils::decorateType()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00021">mlir::quant::ExpressedToQuantizedConverter::forInputType()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00213">mlir::Builder::getZeroAttr()</a>, <a class="el" href="StandardTypes_8h_source.html#l00295">mlir::TensorType::isValidElementType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00173">mlir::spirv::SPIRVDialect::isValidType()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01317">printDenseFloatElement()</a>, <a class="el" href="TypeParser_8cpp_source.html#l00367">mlir::quant::QuantizationDialect::printType()</a>, <a class="el" href="LinalgTypes_8cpp_source.html#l00057">mlir::linalg::LinalgDialect::printType()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00609">mlir::spirv::SPIRVDialect::printType()</a>, and <a class="el" href="SPIRVOps_8cpp_source.html#l01396">verify()</a>.</p>

</div>
</div>
<a id="aa6c6a69dacb6f508f73ca9ddc86613d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c6a69dacb6f508f73ca9ddc86613d5">&#9670;&nbsp;</a></span>getSubclassData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Type::getSubclassData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00029">29</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<a id="adcd295cf88ab7faa33601d3bbee5c4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd295cf88ab7faa33601d3bbee5c4b8">&#9670;&nbsp;</a></span>isa()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::isa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00254">254</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="UniformKernelUtils_8h_source.html#l00181">mlir::fxpmath::detail::broadcastScalarConstIntValue()</a>, <a class="el" href="Ops_8cpp_source.html#l01144">mlir::ConstantIntOp::build()</a>, <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00142">mlir::quant::QuantizedType::castFromExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00098">mlir::quant::QuantizedType::castFromStorageType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00167">mlir::quant::QuantizedType::castToExpressedType()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00118">mlir::quant::QuantizedType::castToStorageType()</a>, <a class="el" href="Ops_8cpp_source.html#l01125">mlir::ConstantFloatOp::classof()</a>, <a class="el" href="Ops_8cpp_source.html#l01130">mlir::ConstantIntOp::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l00858">mlir::DenseFPElementsAttr::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l00877">mlir::DenseIntElementsAttr::classof()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00114">mlir::LLVMTypeConverter::convertFunctionSignature()</a>, <a class="el" href="LinalgToLLVM_8cpp_source.html#l00089">convertLinalgType()</a>, <a class="el" href="Parser_8cpp_source.html#l01430">extractSymbolReference()</a>, <a class="el" href="Attributes_8cpp_source.html#l00626">mlir::DenseElementsAttr::get()</a>, <a class="el" href="Attributes_8cpp_source.html#l00917">mlir::SparseElementsAttr::get()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00390">getBitWidth()</a>, <a class="el" href="Traits_8cpp_source.html#l00089">mlir::OpTrait::util::getBroadcastedType()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00318">mlir::MemRefType::getChecked()</a>, <a class="el" href="Ops_8cpp_source.html#l00593">getCheckedI1SameShape()</a>, <a class="el" href="Statistics_8cpp_source.html#l00053">getElementsStatistics()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8h_source.html#l00117">mlir::edsc::StructuredIndexed::getExprs()</a>, <a class="el" href="ConvertVectorToLLVM_8cpp_source.html#l00113">getI64SubArray()</a>, <a class="el" href="Serializer_8cpp_source.html#l00079">getLastStructuredControlFlowOpMergeBlock()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00089">mlir::quant::QuantizedType::getQuantizedElementType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00664">mlir::DenseElementsAttr::getRaw()</a>, <a class="el" href="LinalgTraits_8h_source.html#l00212">mlir::OpTrait::linalg::StructuredOpTraits&lt; ConcreteType &gt;::hasBufferSemantics()</a>, <a class="el" href="Traits_8cpp_source.html#l00146">hasTensorOrVectorType()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00205">mlir::detail::IntegerAttributeStorage::IntegerAttributeStorage()</a>, <a class="el" href="LoopAnalysis_8cpp_source.html#l00167">isAccessIndexInvariant()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00080">mlir::quant::QuantizedType::isCompatibleExpressedType()</a>, <a class="el" href="Deserializer_8cpp_source.html#l00050">isFnEntryBlock()</a>, <a class="el" href="LoopFusion_8cpp_source.html#l00113">isMemRefDereferencingOp()</a>, <a class="el" href="UniformSupport_8cpp_source.html#l00016">isQuantizablePrimitiveType()</a>, <a class="el" href="LowerABIAttributesPass_8cpp_source.html#l00027">isScalarOrVectorType()</a>, <a class="el" href="StandardTypes_8h_source.html#l00295">mlir::TensorType::isValidElementType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00676">isValidIntOrFloat()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00157">mlir::spirv::SPIRVDialect::isValidScalarType()</a>, <a class="el" href="Dialect_2Linalg_2EDSC_2Builders_8cpp_source.html#l00216">mlir::edsc::ops::linalg_pointwise()</a>, <a class="el" href="Attributes_8cpp_source.html#l00809">mappingHelper()</a>, <a class="el" href="Helpers_8cpp_source.html#l00033">mlir::edsc::MemRefView::MemRefView()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00489">mlir::edsc::op::operator!=()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00495">mlir::edsc::op::operator&lt;()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00503">mlir::edsc::op::operator&lt;=()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00483">mlir::edsc::op::operator==()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00509">mlir::edsc::op::operator&gt;()</a>, <a class="el" href="EDSC_2Builders_8cpp_source.html#l00515">mlir::edsc::op::operator&gt;=()</a>, <a class="el" href="AffineOps_8cpp_source.html#l01029">mlir::AffineDmaWaitOp::parse()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01376">parseConstantOp()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01784">parseGlobalVariableOp()</a>, <a class="el" href="AsmPrinter_8cpp_source.html#l01317">printDenseFloatElement()</a>, <a class="el" href="OpImplementation_8h_source.html#l00112">mlir::OpAsmPrinter::printFunctionalType()</a>, <a class="el" href="GPUDialect_8cpp_source.html#l00732">printGPUFuncOp()</a>, <a class="el" href="ConvertStandardToLLVM_8cpp_source.html#l00446">mlir::UnrankedMemRefDescriptor::setMemRefDescPtr()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00944">vectorizeConstant()</a>, <a class="el" href="Vectorize_8cpp_source.html#l00982">vectorizeOperand()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l01396">verify()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00627">mlir::ComplexType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00217">mlir::quant::AnyQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00258">mlir::quant::UniformQuantizedType::verifyConstructionInvariants()</a>, <a class="el" href="QuantTypes_8cpp_source.html#l00315">mlir::quant::UniformQuantizedPerAxisType::verifyConstructionInvariants()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00410">mlir::UnrankedMemRefType::verifyConstructionInvariants()</a>, <a class="el" href="Attributes_8cpp_source.html#l00208">verifyFloatTypeInvariants()</a>, and <a class="el" href="Operation_8cpp_source.html#l00994">mlir::OpTrait::impl::verifyResultsAreFloatLike()</a>.</p>

</div>
</div>
<a id="a219cbb23b0bbf98773dc73d5ba5b13ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219cbb23b0bbf98773dc73d5ba5b13ed">&#9670;&nbsp;</a></span>isBF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isBF16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00025">25</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00044">mlir::StandardTypes::BF16</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributes_8cpp_source.html#l00444">getDenseElementBitwidth()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00156">mlir::detail::FloatAttributeStorage::getKey()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00423">mlir::detail::DenseElementsAttributeStorage::getKey()</a>, <a class="el" href="QuantTypes_8h_source.html#l00117">mlir::quant::QuantizedType::isSigned()</a>, <a class="el" href="SPIRVDialect_8cpp_source.html#l00157">mlir::spirv::SPIRVDialect::isValidScalarType()</a>, and <a class="el" href="SPIRVDialect_8cpp_source.html#l00188">parseAndVerifyType()</a>.</p>

</div>
</div>
<a id="addf9ffe711f6a40ec2558f094e0fe3d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf9ffe711f6a40ec2558f094e0fe3d0">&#9670;&nbsp;</a></span>isF16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF16 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00026">26</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00045">mlir::StandardTypes::F16</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8h_source.html#l00117">mlir::quant::QuantizedType::isSigned()</a>.</p>

</div>
</div>
<a id="a2ee1dfc71fe79d72fb86df381afa28f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee1dfc71fe79d72fb86df381afa28f8">&#9670;&nbsp;</a></span>isF32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF32 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00027">27</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00046">mlir::StandardTypes::F32</a>.</p>

<p class="reference">Referenced by <a class="el" href="QuantTypes_8h_source.html#l00117">mlir::quant::QuantizedType::isSigned()</a>.</p>

</div>
</div>
<a id="a15aebbbf2b0d7cefda956b63af8ee0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15aebbbf2b0d7cefda956b63af8ee0d4">&#9670;&nbsp;</a></span>isF64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isF64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00028">28</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00047">mlir::StandardTypes::F64</a>.</p>

<p class="reference">Referenced by <a class="el" href="AttributeDetail_8h_source.html#l00156">mlir::detail::FloatAttributeStorage::getKey()</a>, and <a class="el" href="QuantTypes_8h_source.html#l00117">mlir::quant::QuantizedType::isSigned()</a>.</p>

</div>
</div>
<a id="ae04cd125cd035f98f0bbbdec875f4f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04cd125cd035f98f0bbbdec875f4f90">&#9670;&nbsp;</a></span>isIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00030">30</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, <a class="el" href="LoopUtils_8cpp_source.html#l00834">ceilDivPositive()</a>, <a class="el" href="Ops_8cpp_source.html#l01152">mlir::ConstantIndexOp::classof()</a>, <a class="el" href="Attributes_8cpp_source.html#l00271">mlir::IntegerAttr::get()</a>, <a class="el" href="IR_2Builders_8cpp_source.html#l00115">mlir::Builder::getIntegerAttr()</a>, <a class="el" href="AttributeDetail_8h_source.html#l00205">mlir::detail::IntegerAttributeStorage::IntegerAttributeStorage()</a>, <a class="el" href="QuantTypes_8h_source.html#l00117">mlir::quant::QuantizedType::isSigned()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00118">mlir::isValidDim()</a>, <a class="el" href="AffineOps_8cpp_source.html#l00179">mlir::isValidSymbol()</a>, <a class="el" href="Ops_8cpp_source.html#l01577">verify()</a>, <a class="el" href="LinalgOps_8cpp_source.html#l00127">verifyBlockArgs()</a>, and <a class="el" href="LinalgOps_8cpp_source.html#l00202">verifyFuncArgs()</a>.</p>

</div>
</div>
<a id="ad3ffc49524ecdd46d15a8449e23267b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ffc49524ecdd46d15a8449e23267b1">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isInteger </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer type with the specified width. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00033">33</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Attributes_8cpp_source.html#l00612">mlir::DenseElementsAttr::get()</a>, <a class="el" href="QuantTypes_8h_source.html#l00117">mlir::quant::QuantizedType::isSigned()</a>, and <a class="el" href="EDSC_2Builders_8cpp_source.html#l00438">mlir::edsc::op::operator!()</a>.</p>

</div>
</div>
<a id="af2f2df233ac9b650c85992d365b08419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2f2df233ac9b650c85992d365b08419">&#9670;&nbsp;</a></span>isIntOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true of this is an integer or a float type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00045">45</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">References <a class="el" href="StandardTypes_8h_source.html#l00110">mlir::IntegerType::kMaxWidth</a>.</p>

<p class="reference">Referenced by <a class="el" href="UniformKernelUtils_8h_source.html#l00161">mlir::fxpmath::detail::castElementType()</a>, <a class="el" href="Attributes_8cpp_source.html#l00572">mlir::DenseElementsAttr::get()</a>, <a class="el" href="SPIRVOps_8cpp_source.html#l00390">getBitWidth()</a>, <a class="el" href="StandardTypes_8cpp_source.html#l00318">mlir::MemRefType::getChecked()</a>, <a class="el" href="StandardTypes_8h_source.html#l00280">mlir::VectorType::isValidElementType()</a>, <a class="el" href="StandardTypes_8h_source.html#l00295">mlir::TensorType::isValidElementType()</a>, and <a class="el" href="StandardTypes_8cpp_source.html#l00410">mlir::UnrankedMemRefType::verifyConstructionInvariants()</a>.</p>

</div>
</div>
<a id="a6a4fa1595a42d6b3ae872fc303249b5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4fa1595a42d6b3ae872fc303249b5e">&#9670;&nbsp;</a></span>isIntOrIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer or index type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00039">39</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Parser_8cpp_source.html#l01710">buildHexadecimalFloatLiteral()</a>, and <a class="el" href="Operation_8cpp_source.html#l01002">mlir::OpTrait::impl::verifyResultsAreIntegerLike()</a>.</p>

</div>
</div>
<a id="ad4258b26dd83dba9fc87fc7220639bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4258b26dd83dba9fc87fc7220639bf4">&#9670;&nbsp;</a></span>isIntOrIndexOrFloat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Type::isIntOrIndexOrFloat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if this is an integer, index, or float type. </p>

<p class="definition">Definition at line <a class="el" href="StandardTypes_8cpp_source.html#l00041">41</a> of file <a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="LinalgOps_8cpp_source.html#l01019">appendMangledType()</a>, and <a class="el" href="Ops_8cpp_source.html#l00593">getCheckedI1SameShape()</a>.</p>

</div>
</div>
<a id="afeb8b20e59002a0fedfcb93e314b416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeb8b20e59002a0fedfcb93e314b416f">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mlir::Type::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00120">120</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ac516f7c8eb957068555b5781d78f23af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac516f7c8eb957068555b5781d78f23af">&#9670;&nbsp;</a></span>operator!()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::operator! </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00122">122</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="ad1be45203a0010965388d41e712dc268"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1be45203a0010965388d41e712dc268">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmlir_1_1Type.html#ac516f7c8eb957068555b5781d78f23af">mlir::Type::operator!</a>= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00119">119</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<a id="a860e9e7612215565aadad622ccf4cbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860e9e7612215565aadad622ccf4cbb0">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html">Type</a>&amp; mlir::Type::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmlir_1_1Type.html">Type</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac53df1249058e8c2ec0fa70f172f0b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53df1249058e8c2ec0fa70f172f0b59">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool mlir::Type::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00118">118</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">References <a class="el" href="Types_8h_source.html#l00181">impl</a>.</p>

</div>
</div>
<a id="a94f326ccb845e5e7f384a8069153f305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f326ccb845e5e7f384a8069153f305">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type::print </td>
          <td>(</td>
          <td class="paramtype">raw_ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print the current type. </p>

<p class="definition">Definition at line <a class="el" href="AsmPrinter_8cpp_source.html#l02140">2140</a> of file <a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00184">mlir::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="a663843e1a6ab7ce6214e4732b64787ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a663843e1a6ab7ce6214e4732b64787ba">&#9670;&nbsp;</a></span>setSubclassData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Type::setSubclassData </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8cpp_source.html#l00030">30</a> of file <a class="el" href="Types_8cpp_source.html">Types.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a54ee333db7234f6ada1036072a24b877"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ee333db7234f6ada1036072a24b877">&#9670;&nbsp;</a></span>hash_value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::llvm::hash_code hash_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmlir_1_1Type.html">Type</a>&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00250">250</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a54af6c081e012a32bba9b650480c6c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54af6c081e012a32bba9b650480c6c06">&#9670;&nbsp;</a></span>impl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmlir_1_1Type.html#a89de246b01ef652963e1ddde953d62e7">ImplType</a>* mlir::Type::impl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="Types_8h_source.html#l00181">181</a> of file <a class="el" href="Types_8h_source.html">Types.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="Types_8h_source.html#l00250">mlir::hash_value()</a>, and <a class="el" href="Types_8h_source.html#l00118">operator==()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/mlir/IR/<a class="el" href="Types_8h_source.html">Types.h</a></li>
<li>lib/IR/<a class="el" href="AsmPrinter_8cpp_source.html">AsmPrinter.cpp</a></li>
<li>lib/IR/<a class="el" href="StandardTypes_8cpp_source.html">StandardTypes.cpp</a></li>
<li>lib/IR/<a class="el" href="Types_8cpp_source.html">Types.cpp</a></li>
<li>lib/TableGen/<a class="el" href="Type_8cpp_source.html">Type.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 26 2020 16:22:20 for MLIR by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
